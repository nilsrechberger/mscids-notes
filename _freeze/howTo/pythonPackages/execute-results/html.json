{
  "hash": "4499486b9ff5b1e14b9dae799cbad722",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"How to... Python Packages\"\n---\n\n\n\n\n\n\n# Introduction\n\nPython inherently offers useful functionalities such as `print()`, `enumerate()`, or `list.append()`. However, our projects often require more specific tools. This is where packages (or libraries) come in. Packages are extensions for Python that provide specialized functions and tools to efficiently solve a variety of problems.\n\nThe most frequently used packages include:\n\n- `numpy`: For fast numerical and mathematical computations.\n- `pandas`: For the efficient processing of large amounts of structured data (tables).\n- `matplotlib`: For creating data visualizations and diagrams.\n\nInstead of treating every function of these packages in detail, which would be too extensive, this summary focuses on practical application examples for each presented package.\n\n# NumPy\n\nTransposing a matrix means swapping rows and columns. If $A$ is a matrix, then its transposed matrix $A^T$ is defined by:\n\n$$\n(A^T)_{ij} = A_{ji}\n$$\n\nIf one were to perform a matrix transposition with pure Python, one would have to manually iterate over rows and columns, leading to comparatively inefficient code.\n\n::: {#c5259aa7 .cell execution_count=1}\n``` {.python .cell-code}\nmatrix = [[1, 2], [3, 4]]\nrows = len(matrix)\ncols = len(matrix[0])\ntransposed = []\n\nfor i in range(cols):\n    new_row = []\n    for j in range(rows):\n        new_row.append(matrix[j][i])\n    transposed.append(new_row)\n\nprint(transposed)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1, 3], [2, 4]]\n```\n:::\n:::\n\n\nDepending on the size of the matrix, this process can be very time-consuming. With NumPy, we can use the optimized transposition function to solve this problem quickly and elegantly. NumPy operations are vectorized and run with significantly better performance.\n\n::: {#6a57408a .cell execution_count=2}\n``` {.python .cell-code}\nimport numpy as np\n\nmatrix = np.array([[1, 2], [3, 4]])\ntransposed = matrix.T\n\nprint(transposed)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1 3]\n [2 4]]\n```\n:::\n:::\n\n\n::: {.callout-tip}\nCheck out the [Numpy Cheat Sheet](../files/cheat_sheet_numpy.pdf).\n:::\n\n# Pandas\n\nWorking with structured data in native Python is possible, but quickly becomes complicated and error-prone with larger data sets. Even simply summarizing a table already requires a considerable amount of code and manual data processing.\n\n::: {#0ae6a403 .cell execution_count=3}\n``` {.python .cell-code}\nsum_col_a = 0.0\nsum_col_b = 0.0\ncount = 0\n\nwith open(\"data/pandasTable.csv\", \"r\") as f:\n    header = f.readline() \n    \n    for line in f:\n        values = line.strip().split(',')\n        sum_col_a += float(values[1])\n        sum_col_b += float(values[2])\n        count += 1\n\navg_col_a = 0.0\navg_col_b = 0.0\n\nif count > 0:\n    avg_col_a = sum_col_a / count\n    avg_col_b = sum_col_b / count\n\nprint(\"Number of Records:\", count)\nprint(\"Column ColA:\")\nprint(\"  Sum:\", sum_col_a)\nprint(\"  Average:\", avg_col_a)\nprint(\"Column ColB:\")\nprint(\"  Sum:\", sum_col_b)\nprint(\"  Average:\", avg_col_b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNumber of Records: 5\nColumn ColA:\n  Sum: 82.2\n  Average: 16.44\nColumn ColB:\n  Sum: 805.0\n  Average: 161.0\n```\n:::\n:::\n\n\nWith Pandas, we can easily read in structured data and retrieve summary statistics with a single function call, which simplifies data analysis considerably.\n\n::: {#133a0799 .cell execution_count=4}\n``` {.python .cell-code}\nimport pandas as pd\n\ndf = pd.read_csv(\"data/pandasTable.csv\")\ndf.describe()\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>ID</th>\n      <th>hight</th>\n      <th>width</th>\n      <th>Group</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>count</th>\n      <td>5.000000</td>\n      <td>5.000000</td>\n      <td>5.000000</td>\n      <td>5.00000</td>\n    </tr>\n    <tr>\n      <th>mean</th>\n      <td>3.000000</td>\n      <td>16.440000</td>\n      <td>161.000000</td>\n      <td>1.80000</td>\n    </tr>\n    <tr>\n      <th>std</th>\n      <td>1.581139</td>\n      <td>10.582911</td>\n      <td>108.880669</td>\n      <td>0.83666</td>\n    </tr>\n    <tr>\n      <th>min</th>\n      <td>1.000000</td>\n      <td>5.900000</td>\n      <td>50.000000</td>\n      <td>1.00000</td>\n    </tr>\n    <tr>\n      <th>25%</th>\n      <td>2.000000</td>\n      <td>10.500000</td>\n      <td>100.000000</td>\n      <td>1.00000</td>\n    </tr>\n    <tr>\n      <th>50%</th>\n      <td>3.000000</td>\n      <td>12.700000</td>\n      <td>125.000000</td>\n      <td>2.00000</td>\n    </tr>\n    <tr>\n      <th>75%</th>\n      <td>4.000000</td>\n      <td>20.100000</td>\n      <td>200.000000</td>\n      <td>2.00000</td>\n    </tr>\n    <tr>\n      <th>max</th>\n      <td>5.000000</td>\n      <td>33.000000</td>\n      <td>330.000000</td>\n      <td>3.00000</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {.callout-tip}\nCheck out the [Pandas Cheat Sheet](../files/cheat_sheet_pandas.pdf).\n:::\n\n# Matplotlib\n\nData visualization in pure Python is a challenge, as the language was not designed for drawing diagrams without specialized packages.\n\n::: {#a653717d .cell execution_count=5}\n``` {.python .cell-code}\ndata = {\"A\": 5, \"B\": 10, \"C\": 3}\nmax_val = max(data.values())\nscale = 50 / max_val  # Skalierung auf max. 50 Zeichen Breite\n\nfor key, value in data.items():\n    bar_length = int(value * scale)\n    print(f\"{key}: {'#' * bar_length} {value}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA: ######################### 5\nB: ################################################## 10\nC: ############### 3\n```\n:::\n:::\n\n\nFortunately, Matplotlib provides us with a versatile library with which we can create various types of diagrams.\n\n::: {#57181a68 .cell execution_count=6}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\n\ndata = {\"A\": 5, \"B\": 10, \"C\": 3}\n\nkeys = list(data.keys())\nvalues = list(data.values())\n\nplt.figure()\nplt.bar(keys, values, color=['blue', 'red', 'green'])\n\nplt.title('Simple Data Visualization')\nplt.xlabel('Category')\nplt.ylabel('Value')\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](pythonPackages_files/figure-html/cell-7-output-1.png){}\n:::\n:::\n\n\n::: {.callout-tip}\nCheck out the [Matplotlib Cheat Sheet](../files/cheat_sheet_matplotlib.pdf).\n:::\n\n# More to explore\n\nThousands of packages are available for Python. However, it is advisable to use well-maintained and established standard packages such as `numpy`, `pandas`, and `matplotlib`, as these are regularly updated and have large communities.\n\nIf you are looking for a specific tool, PyPI (Python Package Index) is the central hub: [PIPY](https://pypi.org/)\n\n",
    "supporting": [
      "pythonPackages_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}