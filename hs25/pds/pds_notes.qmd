---
title: "Python for Data Science - Notes"
toc: true
---

# Introduction

## Interpreter vs. Compiler Languages

An interpreter translates code and sends it to the CPU. The code is sent to the interpreter line by line. The interpreter provides a console for ad-hoc commands. It's usually slower than a compiler and not good for optimization.

A compiler processes source code and returns an executable file. Compiler languages are usually fast and made for optimization (speed, storage use). Executable code is almost impossible to reverse-engineer.

# Intelligent Development Environment (IDE)

Typically, an IDE provides additional tools to make programming more convenient. IDEs provide tools such as:

- Debuggers
- Deployment chain control
- File browser
- Terminal
- Version control interface
- etc.

> Note: Python is a text-only language that can be written in a simple text editor.

## Python console vs. script

The Python console is a direct interface to the interpreter. Every instruction is sent sequentially to the interpreter. Commands sent in the console are sent directly to the interpreter.

A Python script is a collection of commands. Executing a Python script means sending all the commands it contains consecutively to the interpreter.

## Virtual enviroments (venv)

To avoid dependency issues of packages and keep the development environment clean, developers programme applications in virtual environments.

```{bash}
Python3 -m venv .venv # Standard name
```

> Note: It is best practice to name the virtual environment .venv to hide it in the file system.

You need to activate the virtual environment.

```{bash}
. .venv/bin/activate # For Linux
```

You can install packages into the venv with `python3-pip`.

# Python Basics

## Variabels and Basic data types

A variable is a name that refers to a particular or undefined value. In programming languages, we use them as a reference to a particular storage location. A variable always consists of a name, a data type, a storage location and a value. Python does not require any type for variable definitions. It assumes the type from the value.

> Note: Variable names are usually written in lowercase.

Basic data types:

- Integer (int)
- String (str)
- Boolean (bool).
- List
- Dictionary

## Mathematical Operations

Depending on the context, two particular mathematical operators can have different meanings. The sum operator ($+$), except for numerical values, means appending one element to another. This usually requires two elements of the same data type. The multiplication operation ($*$) always has to be applied with an integer.

> Note: Sum and multiplication can be used with strings.

## Boolean operations

Two Boolean values can be combined in different ways using the keywords `and`, `or` and `xor`. Any Boolean operation can be inverted using the keyword `not`.

# Sequential data types

In Python, sequential data types can comprise mixed data types and can have multiple dimensions.

- List: Ordered, changeable.
- Tuple: Ordered, unchangeable.
- Dictonary: Key-Value-Pairs.
- Set: No Duplicates.

# Type casting

Depending on the operation, the same data may have to appear in different types. Data of a particular type can be transformed into a different data type.

```{python}
x = 3

# Same variable but different data type
print("x as int= ", int(x))
print("x as float= ", float(x))
print("x as string= ", str(x)) # Looks like int but is type str!
```

# Input and Output

Interaction with an application requires input and output. Use the `input()` function to print the passed string to the standard output (i.e., terminal). The input is read from the terminal and converted to a string.

# Boolean

A boolean expression can be of two states only (`True` or `False`).

> Note: Python treats all that is NOT 'empty', '0', 'False' or 'None' as 'True'

Priority-List:

1. not
2. and
3. or

## Bitwise operations

Bitwise operations in Python are used to manipulate individual bits of integer values.

- `x | y` bitwise or of x and y
- `x ^ y` bitwise exclusive or of x and y
- `x & y` bitwise and of x and y
- `x << n` x shifted left by n bits
- `x >> n` x shifted right by n bits
- `~x` the bits of x inverted

## Comparison operations

- `<` strictly less than
- `<=` less than or equal
- `>` strictly greater than
- `>=` greater than or equal
- `==` equal
- `!=` not equal
- `is` object identity
- `is not` negated object identity

> Note: Comparisons can be chained arbitrarily.

# Indentation and syntax

Block operations start with a colon (:) and are defined by indentations. Indentations can have an arbitrary number of spaces but must be constant for all instructions within the same block.

## Single block

```{markdown}
instruction
instruction
block header:
••••block instruction
••••block instruction
••••block instruction
instruction
instruction
```

## Nested blocks

```{markdown}
instruction
instruction
block 1 header:
••••block 1 instruction
••••block 2 header:
••••••••block 2 instruction
••••••••block 2 instruction
••••block 1 instruction
••••block 1 instruction
instruction
```

# If-else condition

The if-else statement is a control structure for checking a condition, allowing you to execute different code blocks depending on whether the condition is met.

```{python}
x = 10

if x == 10:
    print("x has the value 10")
else:
    print("x does not have the value 10")
```

## Elif concatenation

`elif` allows for concatenating multiple conditions.

```{python}
x = 6

if x == 10:
    print("x has the value 10")
elif x % 2 == 0:
    print("x is an even number")
```

## Shorthand statement

Shorthand `if` statements allow for less code and better readability.

```{python}
x = 10

# Block
if x == 10:
    x += 1
    print(x)
else:
    None

## Is the same as

x = 10
# One Line
x = x + 1 if x == 10 else None
print(x)
```

# Match case

Instead of using multiple combined conditions with elif statements, an expression can be directly checked against multiple specific cases.

```{python}
x = 2
match x:
    case 0:
        print("number is 0")
    case 1:
        print("number is 1")
    case 2:
        print("number is 2")
    case _: # Default case
        print("number unknown")
```

# Loops

## range ()

The class range() allows creating sequence objects with constant step sizes. Ranges implement all of the common sequence operations except concatenation and repetition. 

> Notes: The stop element is not included.

```{python}
my_range = list(range(2, 11, 2)) # Start = 2, End = 11, Steps = 2
print(my_range)
```

## `len()`

`len()` returns the number of elements in a sequence. Returns positive integer: 0 indicates an empty sequence.

```{python}
my_lenght = len(range(1, 11, 1))
print(my_lenght)
```

## Sequence Slicing

Extracting sub-sequences of larger data containers is an important and often used operation. Slicing options are:

- By integer (particular element)
- By range or slice object

```{python}
my_list = list(range(1, 11, 1))
print(f"My list: {my_list}")

# Extract only even numbers
even_numbers = my_list[1:11:2] # Start = Index 1 (second entry), Steps = 2
print(f"All even numbers in my list: {even_numbers}")

# Extract only odd numbers
odd_numbers = my_list[0:11:2] # Start = Index 0 (first entry), Steps = 2
print(f"All odd numbers in my list: {odd_numbers}")
```

> Note: Same as `slice()`

## `for`-loop

Loops are used to iterate over sequence objects by providing each element one after the other through a loop variable. Assign each element of the sequence one after another to the loop variable.

```{python}
# Single loop
my_list = list(range(1, 11, 1))
print(f"My list: {my_list}")

for element in my_list:
    print(f"Element is {element}")
else:
    print("No more elements in my list")
```

> Note: The loop variable is often called `i`: `for i in my_list:`.

## `while`-loop

A while loop executes the loop body as long as the condition equals True. The while loop checks the condition each time before re-executing the loop body and terminates as soon as the condition is False.

```{python}
aim = 5
counter = 0

while counter != aim: # != means not equal
    print(f"Counter at value {counter}")
    counter += 1 # Add 1 to the counter
else:
    print("Aim reached")
```

> Note: Check whether the condition can be reached! Otherwise, you will end up in an infinite loop.

## `break`, `continue` and `pass`

Python has three keywords to control the loop (and function) process flow:

### `break`

Immediately break the current loop.

```{python}
aim = 5
counter = 0

while counter != aim:
    print(f"Counter at value {counter}")
    counter += 1
    break # Force a loop break
else:
    print("Aim reached")
```

### `continue`

Ignoring the rest of the loop body and jumping back to the header.

```{python}
aim = 5
counter = 0

while counter != aim:
    print(f"Counter at value {counter}")
    counter += 1
    continue
    print("This msg will not be printed")
else:
    print("Aim reached")
```

### `pass`

No operation. Regular iteration with no execution.

```{python}
aim = 5
counter = 0

while counter != aim:
    print(f"Counter at value {counter}")
    counter += 1
    pass
else:
    print("Aim reached")
```

## Enumerate

The enumerate returns an iterator that returns a tuple with an incrementing number for each element of the sequence.

```{python}
x = list(range(0, 11, 2))

for idx, i in enumerate(x):
    print(f"Value {i} at Index {idx}")
```

# SW05: Python Debugging

## Remote App Development

Modern data analysis methods (e.g. deep learning, optimisation) require large computational resources such as memory or gpu. Remote resources can be provided by individual institutions like HSLU, or rent from web service providers like Amazone Web Services (AWS) or Google Cloud Platform (GCP). Data scientists use two popular Python development environments for data analysis and reporting: Desktop IDE (PyCharm) and Notebooks (Jupyter).

## Jupyter Nootebooks

A Jupyter Notebook is a web-based, open-source tool that combines live code (like Python), equations, output, and narrative text (Markdown) into a single, interactive document. It is organized into cells and is a cornerstone of data science for combining execution and documentation, making analysis transparent and reproducible.

## Debugging

- Semantic errors: violating rules of coding language.
- Syntax errors: missing code elements (e.g. parathesis).
- Logical errors: correct syntax but incorrect directions causing undesired output.
- Runtime errors: error happens when application is running or starting up.
- ect.

### Breakpoints

Breakpoints define code locations where the execution shall stop. The execution is stopped before the selected line of code.

### Debugger

A debugger is a tool that allows developers to meticulously examine and control the execution of their code. It enables the setting of breakpoints, allowing the developer to inspect the current state of variables, the call stack (the sequence of function calls that led to the current point), and memory. This step-by-step execution, often called stepping (e.g., step over, step into, step out), is fundamental for isolating and understanding the root cause of bugs or unexpected behavior.

## Enum data type

An Enum is a set of symbolic names bound to unique values. Enumeration requires the package Enum.

```{python}
from enum import Enum
```

Enum allows handle a set of values:

- days of the week
- Colors
- ect.

# SW06: Functions, Strings & Files

## Functions

Functions allow to combine multiple instruction into a function block that can be executed multiple times. Main advantages of functions are modularity (mitigates code duplication) and readability. Functions tackle only **one** particular issue at once. Ideally operate on its input only and produce some output.

> Note: Functions are named by convention in snake case (i.e. lower case separated with ‘_’): `my_function()`.

The function header is made up of the function name and any optional parameters.

> Note: Functions in Python are defined by the term `def`.

```{python}
# Name = my_function
# Parameters: parameter1
def my_function(parameter1):
    pass # Do nothing, just pass.
```

The body of a function contains a sequence of operations and should always have an output value. The number of operations within a function is unlimited, and they can call other functions.

```{python}
def my_function(parameter1):
    print(parameter1) # Call the print function
    return True

my_function("Test run") # Call my_function
```

### Return Values

All functions (including purely functional) have one return value; at least `None`. Return value is a pointer to a storage location.

### Documentation

Python offers a centralized documentation with docstrings; a built-in attribute assigned to each function named `__doc__`. If the `__doc__` attribute is set with a documentation string, it is callable by means of the `help()` function. You can place a string block (triple-quotes “””doc text”””) immediately next to the function definition to define the docstring.

```{python}
def my_function(parameter1):
    """ Prints a given parameter to the console """ # Docstring of my_function
    print(parameter1) # Call the print function
    return True
```

## String Formatting

Python treats a string as a sequence (list) of characters (single letters, symbols or escape characters). Strings can be sliced, concatenated, allows index based access and formatting based on character position.

![String as a sequence of characters](img/string_format.png)

Formatting strings means defining the representation and treatment of particular sequences.

### f-Strings

An f-string can be used to add variables to a string. Rather than writing the string again every time the variable changes, we can use the f-string to add multiple variables to the string.

```{python}
for i in range(1, 5):
    # Using f-String
    print(f"i is {i}") # i changes over time
```

## File Handling

Files enable storing data outside of the application and hence to keep the information for next execution or share data between different application. Python accesses files through a file object.

```python
file_object = open(file_name, mode)
```

::: {.callout-important}
The buffer results in unfinished writing process as long as the file stream (file_object) is not flushed by '`file_object.flush()` or `file_object.close()`'.
:::
