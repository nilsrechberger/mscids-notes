---
title: "Python for Data Science - Notes"
toc: true
---

# Introduction

## Interpreter vs. Compiler Languages

An interpreter translates code and sends it to the CPU. The code is sent to the interpreter line by line. The interpreter provides a console for ad-hoc commands. It's usually slower than a compiler and not good for optimization.

A compiler processes source code and returns an executable file. Compiler languages are usually fast and made for optimization (speed, storage use). Executable code is almost impossible to reverse-engineer.

# Intelligent Development Environment (IDE)

Typically, an IDE provides additional tools to make programming more convenient. IDEs provide tools such as:

- Debuggers
- Deployment chain control
- File browser
- Terminal
- Version control interface
- etc.

> Note: Python is a text-only language that can be written in a simple text editor.

## Python console vs. script

The Python console is a direct interface to the interpreter. Every instruction is sent sequentially to the interpreter. Commands sent in the console are sent directly to the interpreter.

A Python script is a collection of commands. Executing a Python script means sending all the commands it contains consecutively to the interpreter.

## Virtual enviroments (venv)

To avoid dependency issues of packages and keep the development environment clean, developers programme applications in virtual environments.

```{bash}
Python3 -m venv .venv # Standard name
```

> Note: It is best practice to name the virtual environment .venv to hide it in the file system.

You need to activate the virtual environment.

```{bash}
. .venv/bin/activate # For Linux
```

You can install packages into the venv with `python3-pip`.

# Python Basics

## Variabels and Basic data types

A variable is a name that refers to a particular or undefined value. In programming languages, we use them as a reference to a particular storage location. A variable always consists of a name, a data type, a storage location and a value. Python does not require any type for variable definitions. It assumes the type from the value.

> Note: Variable names are usually written in lowercase.

Basic data types:

- Integer (int)
- String (str)
- Boolean (bool).
- List
- Dictionary

## Mathematical Operations

Depending on the context, two particular mathematical operators can have different meanings. The sum operator ($+$), except for numerical values, means appending one element to another. This usually requires two elements of the same data type. The multiplication operation ($*$) always has to be applied with an integer.

> Note: Sum and multiplication can be used with strings.

## Boolean operations

Two Boolean values can be combined in different ways using the keywords `and`, `or` and `xor`. Any Boolean operation can be inverted using the keyword `not`.

# Sequential data types

In Python, sequential data types may comprise mixed data types and can have multiple dimensions.

- List: Ordered, changeable.
- Tuple: Ordered, unchangeable.
- Dictonary: Key-Value-Pairs.
- Set: No Duplicates.

# Type casting

Depending on operation, same data have to appear in different types. Data of a particular type can be transformed into a different data type.

```{python}
x = 3

# Same variable, different data type
print("x as int= ", int(x))
print("x as float= ", float(x))
print("x as string= ", str(x)) # Looks like int, bit is type str!
```

# Input and Output

Interaction with an application requires input and output. Use the 'input()' function to print the passed string to the standard output (i.e. terminal). The input is read from the terminal and converted to a string.

# Boolean

A boolean expression can be of two states only

> Note: Python treats all that is NOT 'empty', '0', 'False' or 'None' as 'True'

Priority-List:

1. not
2. and
3. or

## Bitwise operations

tbd

## Comparison operations

- `<` strictly less than
- `<=` less than or equal
- `>` strictly greater than
- `>=` greater than or equal
- `==` equal
- `!=` not equal
- `is` object identity
- `is not` negated object identity

# Indentation and syntax

Block operations start with a column (:) and are defined by indentations. Indentations can have arbitrary number of spaces but must be constant for all instructions of the same block content.

## Single block

```{markdown}
instruction
instruction
block header:
••••block instruction
••••block instruction
••••block instruction
instruction
instruction
```

## Nested blocks

```{markdown}
instruction
instruction
block 1 header:
••••block 1 instruction
••••block 2 header:
••••••••block 2 instruction
••••••••block 2 instruction
••••block 1 instruction
••••block 1 instruction
instruction
```

# If-else condition

The if-else statement is a switch for proving and catching a condition being required for a conditional expression.

```{python}
x = 10

if x == 10:
    print("x has the value 10")
else:
    print("x does not have the value 10")
```

## Elif concatenation

`elif` allows for concatenating conditions.

```{python}
x = 6

if x == 10:
    print("x has the value 10")
elif x % 2 == 0:
    print("x is an even number")
```

## Shorthand statement

Shorthand if-statements allow for less code and better readability.

```{python}
x = 10

# Block
if x == 10:
    x += 1
    print(x)
else:
    None

## Is the same as

x = 10
# One Line
x = x + 1 if x == 10 else None
print(x)
```

# Match case
Instead of using multiple combined conditions with elif-statements, an expression can be directly checked against multiple specific cases to which it matches.

```{python}
x = 2
match x:
    case 0:
        print("number is 0")
    case 1:
        print("number is 1")
    case 2:
        print("number is 2")
    case _: # Default case
        print("number unknown")
```