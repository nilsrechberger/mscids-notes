---
title: "Python for Data Science - Notes"
toc: true
---

# Introduction

## Interpreter vs. Compiler Languages

An interpreter translates code and sends it to the CPU. The code is sent to the interpreter line by line. The interpreter provides a console for ad-hoc commands. It's usually slower than a compiler and not good for optimization.

A compiler processes source code and returns an executable file. Compiler languages are usually fast and made for optimization (speed, storage use). Executable code is almost impossible to reverse-engineer.

# Intelligent Development Environment (IDE)

Typically, an IDE provides additional tools to make programming more convenient. IDEs provide tools such as:

- Debuggers
- Deployment chain control
- File browser
- Terminal
- Version control interface
- etc.

> Note: Python is a text-only language that can be written in a simple text editor.

## Python console vs. script

The Python console is a direct interface to the interpreter. Every instruction is sent sequentially to the interpreter. Commands sent in the console are sent directly to the interpreter.

A Python script is a collection of commands. Executing a Python script means sending all the commands it contains consecutively to the interpreter.

## Virtual enviroments (venv)

To avoid dependency issues of packages and keep the development environment clean, developers programme applications in virtual environments.

```{bash}
Python3 -m venv .venv # Standard name
```

> Note: It is best practice to name the virtual environment .venv to hide it in the file system.

You need to activate the virtual environment.

```{bash}
. .venv/bin/activate # For Linux
```

You can install packages into the venv with `python3-pip`.

# Python Basics

## Variabels and Basic data types

A variable is a name that refers to a particular or undefined value. In programming languages, we use them as a reference to a particular storage location. A variable always consists of a name, a data type, a storage location and a value. Python does not require any type for variable definitions. It assumes the type from the value.

> Note: Variable names are usually written in lowercase.

Basic data types:

- Integer (int)
- String (str)
- Boolean (bool).
- List
- Dictionary

## Mathematical Operations

Depending on the context, two particular mathematical operators can have different meanings. The sum operator ($+$), except for numerical values, means appending one element to another. This usually requires two elements of the same data type. The multiplication operation ($*$) always has to be applied with an integer.

> Note: Sum and multiplication can be used with strings.

## Boolean operations

Two Boolean values can be combined in different ways using the keywords `and`, `or` and `xor`. Any Boolean operation can be inverted using the keyword `not`.

# Sequential data types

In Python, sequential data types can comprise mixed data types and can have multiple dimensions.

- List: Ordered, changeable.
- Tuple: Ordered, unchangeable.
- Dictonary: Key-Value-Pairs.
- Set: No Duplicates.

# Type casting

Depending on the operation, the same data may have to appear in different types. Data of a particular type can be transformed into a different data type.

```{python}
x = 3

# Same variable but different data type
print("x as int= ", int(x))
print("x as float= ", float(x))
print("x as string= ", str(x)) # Looks like int but is type str!
```

# Input and Output

Interaction with an application requires input and output. Use the `input()` function to print the passed string to the standard output (i.e., terminal). The input is read from the terminal and converted to a string.

# Boolean

A boolean expression can be of two states only (`True` or `False`).

> Note: Python treats all that is NOT 'empty', '0', 'False' or 'None' as 'True'

Priority-List:

1. not
2. and
3. or

## Bitwise operations

Bitwise operations in Python are used to manipulate individual bits of integer values.

- `x | y` bitwise or of x and y
- `x ^ y` bitwise exclusive or of x and y
- `x & y` bitwise and of x and y
- `x << n` x shifted left by n bits
- `x >> n` x shifted right by n bits
- `~x` the bits of x inverted

## Comparison operations

- `<` strictly less than
- `<=` less than or equal
- `>` strictly greater than
- `>=` greater than or equal
- `==` equal
- `!=` not equal
- `is` object identity
- `is not` negated object identity

> Note: Comparisons can be chained arbitrarily.

# Indentation and syntax

Block operations start with a colon (:) and are defined by indentations. Indentations can have an arbitrary number of spaces but must be constant for all instructions within the same block.

## Single block

```{markdown}
instruction
instruction
block header:
••••block instruction
••••block instruction
••••block instruction
instruction
instruction
```

## Nested blocks

```{markdown}
instruction
instruction
block 1 header:
••••block 1 instruction
••••block 2 header:
••••••••block 2 instruction
••••••••block 2 instruction
••••block 1 instruction
••••block 1 instruction
instruction
```

# If-else condition

The if-else statement is a control structure for checking a condition, allowing you to execute different code blocks depending on whether the condition is met.

```{python}
x = 10

if x == 10:
    print("x has the value 10")
else:
    print("x does not have the value 10")
```

## Elif concatenation

`elif` allows for concatenating multiple conditions.

```{python}
x = 6

if x == 10:
    print("x has the value 10")
elif x % 2 == 0:
    print("x is an even number")
```

## Shorthand statement

Shorthand `if` statements allow for less code and better readability.

```{python}
x = 10

# Block
if x == 10:
    x += 1
    print(x)
else:
    None

## Is the same as

x = 10
# One Line
x = x + 1 if x == 10 else None
print(x)
```

# Match case

Instead of using multiple combined conditions with elif statements, an expression can be directly checked against multiple specific cases.

```{python}
x = 2
match x:
    case 0:
        print("number is 0")
    case 1:
        print("number is 1")
    case 2:
        print("number is 2")
    case _: # Default case
        print("number unknown")
```

# Loops

## range ()

The class range() allows creating sequence objects with constant step sizes. Ranges implement all of the common sequence operations except concatenation and repetition. 

> Notes: The stop element is not included.

```{python}
my_range = list(range(2, 11, 2)) # Start = 2, End = 11, Steps = 2
print(my_range)
```

## `len()`

`len()` returns the number of elements in a sequence. Returns positive integer: 0 indicates an empty sequence.

```{python}
my_lenght = len(range(1, 11, 1))
print(my_lenght)
```

## Sequence Slicing

Extracting sub-sequences of larger data containers is an important and often used operation. Slicing options are:

- By integer (particular element)
- By range or slice object

```{python}
my_list = list(range(1, 11, 1))
print(f"My list: {my_list}")

# Extract only even numbers
even_numbers = my_list[1:11:2] # Start = Index 1 (second entry), Steps = 2
print(f"All even numbers in my list: {even_numbers}")

# Extract only odd numbers
odd_numbers = my_list[0:11:2] # Start = Index 0 (first entry), Steps = 2
print(f"All odd numbers in my list: {odd_numbers}")
```

> Note: Same as `slice()`

## `for`-loop

Loops are used to iterate over sequence objects by providing each element one after the other through a loop variable. Assign each element of the sequence one after another to the loop variable.

```{python}
# Single loop
my_list = list(range(1, 11, 1))
print(f"My list: {my_list}")

for element in my_list:
    print(f"Element is {element}")
else:
    print("No more elements in my list")
```

> Note: The loop variable is often called `i`: `for i in my_list:`.

## `while`-loop

A while loop executes the loop body as long as the condition equals True. The while loop checks the condition each time before re-executing the loop body and terminates as soon as the condition is False.

```{python}
aim = 5
counter = 0

while counter != aim: # != means not equal
    print(f"Counter at value {counter}")
    counter += 1 # Add 1 to the counter
else:
    print("Aim reached")
```

> Note: Check whether the condition can be reached! Otherwise, you will end up in an infinite loop.

## `break`, `continue` and `pass`

Python has three keywords to control the loop (and function) process flow:

### `break`

Immediately break the current loop.

```{python}
aim = 5
counter = 0

while counter != aim:
    print(f"Counter at value {counter}")
    counter += 1
    break # Force a loop break
else:
    print("Aim reached")
```

### `continue`

Ignoring the rest of the loop body and jumping back to the header.

```{python}
aim = 5
counter = 0

while counter != aim:
    print(f"Counter at value {counter}")
    counter += 1
    continue
    print("This msg will not be printed")
else:
    print("Aim reached")
```

### `pass`

No operation. Regular iteration with no execution.

```{python}
aim = 5
counter = 0

while counter != aim:
    print(f"Counter at value {counter}")
    counter += 1
    pass
else:
    print("Aim reached")
```

## Enumerate

The enumerate returns an iterator that returns a tuple with an incrementing number for each element of the sequence.

```{python}
x = list(range(0, 11, 2))

for idx, i in enumerate(x):
    print(f"Value {i} at Index {idx}")
```
