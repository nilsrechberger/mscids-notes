---
title: "Python for Data Science - Notes"
toc: true
---

# Introduction

## Interpreter vs. Compiler Languages

An interpreter translates code and sends it to the CPU. The code is sent to the interpreter line by line. The interpreter provides a console for ad-hoc commands. It's usually slower than a compiler and not good for optimization.

A compiler processes source code and returns an executable file. Compiler languages are usually fast and made for optimization (speed, storage use). Executable code is almost impossible to reverse-engineer.

# Intelligent Development Environment (IDE)

Typically, an IDE provides additional tools to make programming more convenient. IDEs provide tools such as:

- Debuggers
- Deployment chain control
- File browser
- Terminal
- Version control interface
- etc.

> Note: Python is a text-only language that can be written in a simple text editor.

## Python console vs. script

The Python console is a direct interface to the interpreter. Every instruction is sent sequentially to the interpreter. Commands sent in the console are sent directly to the interpreter.

A Python script is a collection of commands. Executing a Python script means sending all the commands it contains consecutively to the interpreter.

## Virtual enviroments (venv)

To avoid dependency issues of packages and keep the development environment clean, developers programme applications in virtual environments.

```{bash}
Python3 -m venv .venv # Standard name
```

> Note: It is best practice to name the virtual environment .venv to hide it in the file system.

You need to activate the virtual environment.

```{bash}
. .venv/bin/activate # For Linux
```

You can install packages into the venv with `python3-pip`.

# Python Basics

## Variabels and Basic data types

A variable is a name that refers to a particular or undefined value. In programming languages, we use them as a reference to a particular storage location. A variable always consists of a name, a data type, a storage location and a value. Python does not require any type for variable definitions. It assumes the type from the value.

> Note: Variable names are usually written in lowercase.

Basic data types:

- Integer (int)
- String (str)
- Boolean (bool).
- List
- Dictionary

## Mathematical Operations

Depending on the context, two particular mathematical operators can have different meanings. The sum operator ($+$), except for numerical values, means appending one element to another. This usually requires two elements of the same data type. The multiplication operation ($*$) always has to be applied with an integer.

> Note: Sum and multiplication can be used with strings.

## Boolean operations

Two Boolean values can be combined in different ways using the keywords `and`, `or` and `xor`. Any Boolean operation can be inverted using the keyword `not`.

# Sequential data types

In Python, sequential data types can comprise mixed data types and can have multiple dimensions.

- List: Ordered, changeable.
- Tuple: Ordered, unchangeable.
- Dictonary: Key-Value-Pairs.
- Set: No Duplicates.

# Type casting

Depending on the operation, the same data may have to appear in different types. Data of a particular type can be transformed into a different data type.

```{python}
x = 3

# Same variable but different data type
print("x as int= ", int(x))
print("x as float= ", float(x))
print("x as string= ", str(x)) # Looks like int but is type str!
```

# Input and Output

Interaction with an application requires input and output. Use the `input()` function to print the passed string to the standard output (i.e., terminal). The input is read from the terminal and converted to a string.

# Boolean

A boolean expression can be of two states only (`True` or `False`).

> Note: Python treats all that is NOT 'empty', '0', 'False' or 'None' as 'True'

Priority-List:

1. not
2. and
3. or

## Bitwise operations

Bitwise operations in Python are used to manipulate individual bits of integer values.

- `x | y` bitwise or of x and y
- `x ^ y` bitwise exclusive or of x and y
- `x & y` bitwise and of x and y
- `x << n` x shifted left by n bits
- `x >> n` x shifted right by n bits
- `~x` the bits of x inverted

## Comparison operations

- `<` strictly less than
- `<=` less than or equal
- `>` strictly greater than
- `>=` greater than or equal
- `==` equal
- `!=` not equal
- `is` object identity
- `is not` negated object identity

> Note: Comparisons can be chained arbitrarily.

# Indentation and syntax

Block operations start with a colon (:) and are defined by indentations. Indentations can have an arbitrary number of spaces but must be constant for all instructions within the same block.

## Single block

```{markdown}
instruction
instruction
block header:
••••block instruction
••••block instruction
••••block instruction
instruction
instruction
```

## Nested blocks

```{markdown}
instruction
instruction
block 1 header:
••••block 1 instruction
••••block 2 header:
••••••••block 2 instruction
••••••••block 2 instruction
••••block 1 instruction
••••block 1 instruction
instruction
```

# If-else condition

The if-else statement is a control structure for checking a condition, allowing you to execute different code blocks depending on whether the condition is met.

```{python}
x = 10

if x == 10:
    print("x has the value 10")
else:
    print("x does not have the value 10")
```

## Elif concatenation

`elif` allows for concatenating multiple conditions.

```{python}
x = 6

if x == 10:
    print("x has the value 10")
elif x % 2 == 0:
    print("x is an even number")
```

## Shorthand statement

Shorthand `if` statements allow for less code and better readability.

```{python}
x = 10

# Block
if x == 10:
    x += 1
    print(x)
else:
    None

## Is the same as

x = 10
# One Line
x = x + 1 if x == 10 else None
print(x)
```

# Match case

Instead of using multiple combined conditions with elif statements, an expression can be directly checked against multiple specific cases.

```{python}
x = 2
match x:
    case 0:
        print("number is 0")
    case 1:
        print("number is 1")
    case 2:
        print("number is 2")
    case _: # Default case
        print("number unknown")
```

# Loops

## range ()

The class range() allows creating sequence objects with constant step sizes. Ranges implement all of the common sequence operations except concatenation and repetition. 

> Notes: The stop element is not included.

```{python}
my_range = list(range(2, 11, 2)) # Start = 2, End = 11, Steps = 2
print(my_range)
```

## `len()`

`len()` returns the number of elements in a sequence. Returns positive integer: 0 indicates an empty sequence.

```{python}
my_lenght = len(range(1, 11, 1))
print(my_lenght)
```

## Sequence Slicing

Extracting sub-sequences of larger data containers is an important and often used operation. Slicing options are:

- By integer (particular element)
- By range or slice object

```{python}
my_list = list(range(1, 11, 1))
print(f"My list: {my_list}")

# Extract only even numbers
even_numbers = my_list[1:11:2] # Start = Index 1 (second entry), Steps = 2
print(f"All even numbers in my list: {even_numbers}")

# Extract only odd numbers
odd_numbers = my_list[0:11:2] # Start = Index 0 (first entry), Steps = 2
print(f"All odd numbers in my list: {odd_numbers}")
```

> Note: Same as `slice()`

## `for`-loop

Loops are used to iterate over sequence objects by providing each element one after the other through a loop variable. Assign each element of the sequence one after another to the loop variable.

```{python}
# Single loop
my_list = list(range(1, 11, 1))
print(f"My list: {my_list}")

for element in my_list:
    print(f"Element is {element}")
else:
    print("No more elements in my list")
```

> Note: The loop variable is often called `i`: `for i in my_list:`.

## `while`-loop

A while loop executes the loop body as long as the condition equals True. The while loop checks the condition each time before re-executing the loop body and terminates as soon as the condition is False.

```{python}
aim = 5
counter = 0

while counter != aim: # != means not equal
    print(f"Counter at value {counter}")
    counter += 1 # Add 1 to the counter
else:
    print("Aim reached")
```

> Note: Check whether the condition can be reached! Otherwise, you will end up in an infinite loop.

## `break`, `continue` and `pass`

Python has three keywords to control the loop (and function) process flow:

### `break`

Immediately break the current loop.

```{python}
aim = 5
counter = 0

while counter != aim:
    print(f"Counter at value {counter}")
    counter += 1
    break # Force a loop break
else:
    print("Aim reached")
```

### `continue`

Ignoring the rest of the loop body and jumping back to the header.

```{python}
aim = 5
counter = 0

while counter != aim:
    print(f"Counter at value {counter}")
    counter += 1
    continue
    print("This msg will not be printed")
else:
    print("Aim reached")
```

### `pass`

No operation. Regular iteration with no execution.

```{python}
aim = 5
counter = 0

while counter != aim:
    print(f"Counter at value {counter}")
    counter += 1
    pass
else:
    print("Aim reached")
```

## Enumerate

The enumerate returns an iterator that returns a tuple with an incrementing number for each element of the sequence.

```{python}
x = list(range(0, 11, 2))

for idx, i in enumerate(x):
    print(f"Value {i} at Index {idx}")
```

# SW05: Python Debugging

## Remote App Development

Modern data analysis methods (e.g. deep learning, optimisation) require large computational resources such as memory or gpu. Remote resources can be provided by individual institutions like HSLU, or rent from web service providers like Amazone Web Services (AWS) or Google Cloud Platform (GCP). Data scientists use two popular Python development environments for data analysis and reporting: Desktop IDE (PyCharm) and Notebooks (Jupyter).

## Jupyter Nootebooks

A Jupyter Notebook is a web-based, open-source tool that combines live code (like Python), equations, output, and narrative text (Markdown) into a single, interactive document. It is organized into cells and is a cornerstone of data science for combining execution and documentation, making analysis transparent and reproducible.

## Debugging

- Semantic errors: violating rules of coding language.
- Syntax errors: missing code elements (e.g. parathesis).
- Logical errors: correct syntax but incorrect directions causing undesired output.
- Runtime errors: error happens when application is running or starting up.
- ect.

### Breakpoints

Breakpoints define code locations where the execution shall stop. The execution is stopped before the selected line of code.

### Debugger

A debugger is a tool that allows developers to meticulously examine and control the execution of their code. It enables the setting of breakpoints, allowing the developer to inspect the current state of variables, the call stack (the sequence of function calls that led to the current point), and memory. This step-by-step execution, often called stepping (e.g., step over, step into, step out), is fundamental for isolating and understanding the root cause of bugs or unexpected behavior.

## Enum data type

An Enum is a set of symbolic names bound to unique values. Enumeration requires the package Enum.

```{python}
from enum import Enum
```

Enum allows handle a set of values:

- days of the week
- Colors
- ect.

# SW06: Functions, Strings & Files

## Functions

Functions allow to combine multiple instruction into a function block that can be executed multiple times. Main advantages of functions are modularity (mitigates code duplication) and readability. Functions tackle only **one** particular issue at once. Ideally operate on its input only and produce some output.

> Note: Functions are named by convention in snake case (i.e. lower case separated with ‘_’): `my_function()`.

The function header is made up of the function name and any optional parameters.

> Note: Functions in Python are defined by the term `def`.

```{python}
# Name = my_function
# Parameters: parameter1
def my_function(parameter1):
    pass # Do nothing, just pass.
```

The body of a function contains a sequence of operations and should always have an output value. The number of operations within a function is unlimited, and they can call other functions.

```{python}
def my_function(parameter1):
    print(parameter1) # Call the print function
    return True

my_function("Test run") # Call my_function
```

### Return Values

All functions (including purely functional) have one return value; at least `None`. Return value is a pointer to a storage location.

### Documentation

Python offers a centralized documentation with docstrings; a built-in attribute assigned to each function named `__doc__`. If the `__doc__` attribute is set with a documentation string, it is callable by means of the `help()` function. You can place a string block (triple-quotes “””doc text”””) immediately next to the function definition to define the docstring.

```{python}
def my_function(parameter1):
    """ Prints a given parameter to the console """ # Docstring of my_function
    print(parameter1) # Call the print function
    return True
```

## String Formatting

Python treats a string as a sequence (list) of characters (single letters, symbols or escape characters). Strings can be sliced, concatenated, allows index based access and formatting based on character position.

![String as a sequence of characters](img/string_format.png)

Formatting strings means defining the representation and treatment of particular sequences.

### f-Strings

An f-string can be used to add variables to a string. Rather than writing the string again every time the variable changes, we can use the f-string to add multiple variables to the string.

```{python}
for i in range(1, 5):
    # Using f-String
    print(f"i is {i}") # i changes over time
```

## File Handling

Files enable storing data outside of the application and hence to keep the information for next execution or share data between different application. Python accesses files through a file object.

```python
file_object = open(file_name, mode)
```

::: {.callout-important}
The buffer results in unfinished writing process as long as the file stream (file_object) is not flushed by '`file_object.flush()` or `file_object.close()`'.
:::

# SW07: Functions part II Recursion

## Namespace

Namespace is the definition of the visibility of a unique name for every single object (variables or methods). Object names must only be unique within a given namespace. Hence, the global namespace can have multiple local namespaces having objects with the same naming. The scope of an object refers to the code section from which an object is accessible.

- built-in: encompasses no programmer defined objects. Ends when the application ends.
- global: programmer defined objects available across the whole script. Ends when the module (i.e. script) is unloaded or the application ends.
- local: programmer defined objects in function blocks. Ends when the function (i.e. block) has been finished.

## Local and Global Variables

Python allows creating variables without any restricted visibility. This variables in the global scope are accessible in the whole
script and are called global variables. Local variables being restricted to a specific function block.

```{python}
global_var = 123 # Free/Global variable

def my_function():
    local_var = "Hello" # Local variable
    print(local_var, global_var)

# The function can use both variables
my_function()

# This is not possible!
# print(local_var)
```

### Keyword `global`

In some problem solutions it is meaningful to have a global variable which gets updated from within a local scope of a function.

```{python}
counter = 10
print(counter)

def reset():
    global counter
    counter = 0
    print(f"Counter reseted: {counter}")

reset()
```

> Note: It's best practice to avoid global variables.

### Keyword `nonelocal`

The Python keywords `global` and `nonlocal` target different scope levels when modifying a variable from within a function.

```{python}
def outer():
    enclosing_var = 20

    def inner():
        nonlocal enclosing_var
        enclosing_var = 200

        global global_var
        global_var = 100

        print(f"Inner: global_var={global_var}, enclosing_var={enclosing_var}")

    inner()
    print(f"Outer: global_var={global_var}, enclosing_var={enclosing_var}")

print(f"Start Global: {global_var}")
outer()
print(f"End Global: {global_var}")
```

## Parameter Value

Parameters are always refernces to arguments. An argument can be of a mutable (like lists) or immutable data type. The content of mutable data types can be “globally altered in functions.

```{python}
def my_add(p):
    result = p
    result [-1] = 99 # Change last value to 99
    return result

var = [9,8,7,6,5,4,3,2,0] # Last value is 0
print(my_add(var))
print(var) # List was changed by the function
```

## Unpacking Arguments (*args and **kwargs)

Python assigns one object to the first and the last variable and packs all the remaining objects into a tuple that is assigned to the variable with the packing operator

```{python}
var1 = 1
var2 = ["hello", "-", "world"]
var3 = 22
print(var1, var2, var3)

# Using the packing operator
var1, *var2, var3 = 1, "hello", "-", "world", 22
print(var1, var2, var3)
```

- `*args`: packing operator (*) packs all non-keyword arguments into a tuple.
- `**kwargs`: double packing operator(**) packs all keyword arguments into a dictionary

```{python}
def my_fun(*args, **kwargs):
    print(args); print(kwargs)
    
my_fun('hello', 'world', arg1=33, arg2=55)
```

In contrast, lists and tuples can be unpacked using the packing operator (*) and (**) for dictionaries, respectively.

## Recursion

A recursive function is simply a function that calls itself during its execution. It is especially useful to loop through a data set with undefined dimension and undefined iteration count. Despite increased complexity and risks, recursion allows to solve complex problems in a short way.

```{python}
def factorial(n):
    if n == 1:
        return 1
    else:
        return n * factorial(n-1)

factorial(5)
```

# SW08: Object-Orientated Programming

## Definition

Object-Oriented Programming (OOP) is a programming paradigm that structures code around objects rather than functions and logic. It's a powerful way to model real-world entities and relationships in your code, leading to more modular, reusable, and scalable applications.

## Classes

Assembly instructions for box construction are represented by the class. The produced boxes, all with the same set of tools but different property values, are called objects. In Python everything is an object and variables hold references to these objects. This means, when you assign an object to a variable, you actually create a reference to that object in memory.

A class in python consist of several elements:
- **header** with class name indicates the beginning of a class description.
- __init__() method: The constructor constructs a new object of the class. 
- **variables**: class: Variables belonging to the class description. Object: variables belonging to a particular object.
- **methods** (functions): Class: methods provided by the class description. Object: methods provided by the object.
- **self** attribute: Reference to the object: required to access object attributes.

```{python}
class MyClass(): # The class
    def __init__(self): # Initial function
        pass

    def my_function(): # Methode of the class object
        pass
```

> Note: For class names, we use CamelCase instead of underscores, as in function names.

### `__init__`

Generating a new object, requires calling the class name and defining the specific properties by attributes passed to the constructor. Each time when generating a new object, python calls the constructor and passes the “properties” (attributes) to the __init__() method.

### Methodes and variables

The class definition fully describes the class (i.e. the object). It comprises a mix of all variables and methods provided for the whole class and particular objects. Methods and variables are called with the object or by reference (self-keyword), respectively. Similarly to variables, methods can belong to an object or a class itself. The declaration and call is the same as for regular functions, yet always requires a reference

```{python}
class MyClass(): # The class
    def __init__(self): # Initial function
        pass

    def my_function(self): # Methode of the class object
        pass
    
    @classmethod
    def class_function(cls): # Methode only of of the class
        pass
```

> Note: The keyword `cls` is a convention but not necessary.

### `self`

The self keyword points to the object it belongs to (namely itself). It allows to call or apply a variable and method, respectively, of (on) a particular object.

## Method types

### Object Methods

Belong to a particular object. Modifying object’s state.

```python
def change_obj_state(self):
    self.state = "New State"
    return True
```

### Class Methods

Belong to a particular class. Modifying class’ state.

```python
@classmethod
def change_cls_state(cls):
    cls.state = "New State"
    return True
```

### Static Methods

Don’t belong to object nor class. Provide operations independent of any object or class state.

```python
@staticmethod
def utility_func():
    print("Done")
    return True
```

### Dunder Methodes

Dunder Methods (or Magic methods), are special methods in Python classes marked by double leading and trailing underscores (e.g., `__init__`, `__str__`).

### `__str__()`

By implementing a __str__() method, the programmer can define what is printed when an object of an own class is passed to the print function.

```python
def __str__(self):
    return self.cls_name
```
