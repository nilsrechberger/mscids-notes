[
  {
    "objectID": "howTo/python.html",
    "href": "howTo/python.html",
    "title": "How to‚Ä¶ Python",
    "section": "",
    "text": "Python is a programming language designed for its simple readability and ease of use.\nPython is primarily executed as an interpreted language. This means that when you run your Python code, the Python Interpreter (which you get when you install Python) translates the code line by line into machine code that the computer understands at runtime (while the program is running).\nWhat you install: Installing Python primarily downloads the Python Interpreter ‚Äì the ‚Äútranslator‚Äù that makes your scripts work."
  },
  {
    "objectID": "howTo/python.html#interactively-in-the-terminal",
    "href": "howTo/python.html#interactively-in-the-terminal",
    "title": "How to‚Ä¶ Python",
    "section": "Interactively in the Terminal",
    "text": "Interactively in the Terminal\nThe terminal (also called Shell, PowerShell, or Command Line) is a text-based interface to your computer.\nBy running python3 (or just python on some systems), you start the interactive interpreter and can directly enter and immediately execute Python commands: Bash\npython3\nTo exit the Python interpreter and return to the regular terminal, use the quit() function: Python\nquit()"
  },
  {
    "objectID": "howTo/python.html#as-a-python-script-file",
    "href": "howTo/python.html#as-a-python-script-file",
    "title": "How to‚Ä¶ Python",
    "section": "As a Python Script (File)",
    "text": "As a Python Script (File)\nIf you want to save code and run it repeatedly, you write it into a Python file (file extension .py). Python code is plain text, so you can create and edit it with any text editor.\nTo run a script, you enter the interpreter command followed by the path to your file in the terminal:\n\n# my_script.py\n\nfor i in range(1, 4):\n    print(i)\n\n1\n2\n3\n\n\npython3 path/to/my_script.py"
  },
  {
    "objectID": "howTo/pythonProject.html",
    "href": "howTo/pythonProject.html",
    "title": "How to‚Ä¶ Python Project",
    "section": "",
    "text": "When starting a new Python project, I follow a consistent setup workflow. This approach ensures a fast, clean, and professional start every time.\n\nNote: Even if some steps (like creating certain subdirectories) aren‚Äôt immediately necessary, I perform them upfront. It‚Äôs better to be ready than to interrupt a session later to add structure."
  },
  {
    "objectID": "howTo/pythonProject.html#create-the-project-folder",
    "href": "howTo/pythonProject.html#create-the-project-folder",
    "title": "How to‚Ä¶ Python Project",
    "section": "1. Create the Project Folder",
    "text": "1. Create the Project Folder\nFirst, we create an empty directory to serve as our project‚Äôs root.\nmkdir my_project\nRemember to navigate into your new project folder:\ncd my_project"
  },
  {
    "objectID": "howTo/pythonProject.html#initialize-a-git-repository",
    "href": "howTo/pythonProject.html#initialize-a-git-repository",
    "title": "How to‚Ä¶ Python Project",
    "section": "2. Initialize a Git Repository",
    "text": "2. Initialize a Git Repository\nTo enable version control and code tracking, we initialize a new Git repository within the project folder.\ngit init"
  },
  {
    "objectID": "howTo/pythonProject.html#create-essential-subdirectories",
    "href": "howTo/pythonProject.html#create-essential-subdirectories",
    "title": "How to‚Ä¶ Python Project",
    "section": "3. Create Essential Subdirectories",
    "text": "3. Create Essential Subdirectories\nI always create the subdirectories src, data, and img, even if I don‚Äôt need all of them at the start.\nsrc: Stores all source code files (the heart of the project). data: Intended for project-specific datasets and external data. img: For images, figures, and plots generated or used by the project.\nmkdir src data img"
  },
  {
    "objectID": "howTo/pythonProject.html#create-necessary-files",
    "href": "howTo/pythonProject.html#create-necessary-files",
    "title": "How to‚Ä¶ Python Project",
    "section": "4. Create Necessary Files",
    "text": "4. Create Necessary Files\nA standard Python project requires a few essential configuration and documentation files:\n\nREADME.md: A Markdown file containing an overview, installation, and usage instructions for the project.\nrequirements.txt: A text file listing all necessary Python package dependencies.\n.env: A special file for storing environment-specific variables, such as API keys or configuration settings (it should always be ignored by Git).\n.gitignore: A file listing all files and folders that Git should not track (e.g., virtual environments, large data files, and sensitive info).\n\ntouch README.md requirements.txt .env .gitignore"
  },
  {
    "objectID": "howTo/pythonProject.html#create-and-activate-a-python-virtual-environment",
    "href": "howTo/pythonProject.html#create-and-activate-a-python-virtual-environment",
    "title": "How to‚Ä¶ Python Project",
    "section": "5. Create and Activate a Python Virtual Environment",
    "text": "5. Create and Activate a Python Virtual Environment\nTo prevent package dependency conflicts with other projects or the system Python installation, it‚Äôs crucial to use a new virtual environment (venv) for every project.\npython3 -m venv .venv\n\nNote: This creates a folder named .venv containing the isolated Python environment\n\nYou must activate the environment before installing packages or running your code.\n# For Mac/Linux\n. .venv/bin/activate\n\n# For Windowns (PowerShell)\n.venv\\Scripts\\Activate.ps1\n\n# For Windowns (CMD)\n.\\.venv\\Scripts\\activate.bat\n\nNote: Check your venv setup with pip list: there should be no installations listed except pip."
  },
  {
    "objectID": "howTo/pythonProject.html#configure-the-.gitignore-file",
    "href": "howTo/pythonProject.html#configure-the-.gitignore-file",
    "title": "How to‚Ä¶ Python Project",
    "section": "6. Configure the .gitignore File",
    "text": "6. Configure the .gitignore File\nThe .gitignore file tells Git which files and folders to ignore. Git isn‚Äôt designed to track large binary files (like datasets or images) or sensitive data (like passwords).\n\nNote: Also ignore the .env and .venv files.\n\necho \".venv\" &gt;&gt; .gitignore\necho \".env\" &gt;&gt; .gitignore\necho \"data/\" &gt;&gt; .gitignore\necho \"img/\" &gt;&gt; .gitignore"
  },
  {
    "objectID": "howTo/pythonProject.html#add-the-initial-commit-to-git",
    "href": "howTo/pythonProject.html#add-the-initial-commit-to-git",
    "title": "How to‚Ä¶ Python Project",
    "section": "7. Add the Initial Commit to Git",
    "text": "7. Add the Initial Commit to Git\nFinally, we stage all the newly created structural files and make the project‚Äôs first official commit.\ngit add -A\ngit commit -m \"Initial project setup\"\nYou are now ready to start coding your Python project!"
  },
  {
    "objectID": "howTo/terminal.html",
    "href": "howTo/terminal.html",
    "title": "How to‚Ä¶ Terminal",
    "section": "",
    "text": "The Terminal (also called Shell, Console, PowerShell, or Command Line) is a text-based interface to your computer. Back in time, when there were no fancy graphical user interfaces (UIs), you had to use the terminal to interact with your computer. Nowadays, we often use the mouse. Nevertheless, the terminal offers some significant advantages and is indispensable in many fields."
  },
  {
    "objectID": "howTo/terminal.html#navigating-the-terminal",
    "href": "howTo/terminal.html#navigating-the-terminal",
    "title": "How to‚Ä¶ Terminal",
    "section": "Navigating the Terminal",
    "text": "Navigating the Terminal\nWhen you open your terminal, it usually shows your username, your device name, and the Current Working Directory ‚Äî your current ‚Äúposition‚Äù in the file system. Sometimes, there is just the $-symbol, which often means you are in your Home Directory (the starting point).\nUse pwd (Print Working Directory) to show your current ‚Äúposition‚Äù:\npwd\nBy using cd (Change Directory) followed by a path, you can move to that position:\ncd path/to/my/notes\n\nNote: cd is used to go to a folder (directory), not a file.\n\nTo move back to the parent directory (one level up), use ..:\ncd .."
  },
  {
    "objectID": "howTo/terminal.html#getting-an-overview",
    "href": "howTo/terminal.html#getting-an-overview",
    "title": "How to‚Ä¶ Terminal",
    "section": "Getting an Overview",
    "text": "Getting an Overview\nWhen you arrive at a folder, you may want to know what‚Äôs inside. Use ls (List) to list the contents of the folder:\nls"
  },
  {
    "objectID": "howTo/terminal.html#parameters-and-options",
    "href": "howTo/terminal.html#parameters-and-options",
    "title": "How to‚Ä¶ Terminal",
    "section": "Parameters and Options",
    "text": "Parameters and Options\nSometimes, you can add a parameter or option to the command to get a special output. For instance, ls does not show hidden files by default. Running ls -a (all) lists all files in a folder, including the hidden ones:\nls -a\n\nNote: Any file can be made hidden by adding a period (.) to the beginning of the file name: .hidden_notes.txt."
  },
  {
    "objectID": "howTo/terminal.html#most-used-commands",
    "href": "howTo/terminal.html#most-used-commands",
    "title": "How to‚Ä¶ Terminal",
    "section": "Most Used Commands",
    "text": "Most Used Commands\nHere is a quick list of the most frequently used commands:\n\npwd: Print Working Directory (Shows the current directory).\nls: List (Lists all files in a directory).\ncd: Change Directory (Changes the current directory).\ntouch: Creates a new, empty file.\nmv: Move (Moves a file or renames it).\nrm: Remove (Deletes a file or directory)."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "mscids-notes",
    "section": "",
    "text": "Hey there, fellow students! üëã\nHere you‚Äôll find a collection of my personal notes and solutions from our courses. I‚Äôve decided to put them online in the hopes that they might help some of you out.\n\nQuick Heads-Up! üìù\nJust a friendly reminder: everything you see here is based on my own understanding and approach. That means my solutions might be different from the official ones provided by our professors.\nThink of this as a secondary resource to complement your own work, not as an official answer key.\n\n\nDisclaimer üö®\nWhile I do my best, I can‚Äôt guarantee that everything is 100% correct or complete. I‚Äôm just a student trying to figure things out, same as you. Therefore, I‚Äôm not taking any responsibility for the accuracy of the content. Always double-check with official course materials!\n\n\nSpotted a Mistake? üëÄ\nIf you happen to find an error, I‚Äôd be super grateful if you could let me know. Just shoot me a quick email!\nüìß nils.rechberger@stud.hslu.ch\nHappy studying! üöÄ"
  },
  {
    "objectID": "hs25/csc/csc_exercises.html",
    "href": "hs25/csc/csc_exercises.html",
    "title": "Computer Science Concepts for Data Scientists - Exercises",
    "section": "",
    "text": "Format: IIIIIIII.FFFF (8 bits integer, 4 bits fraction)\nExample: 45.375\n\n\n\nMethod: Repeatedly divide by 2 & note the remainder.\nCalculation:\n\n45 / 2 = 22 Remainder 1\n22 / 2 = 11 Remainder 0\n11 / 2 = 5 Remainder 1\n5 / 2  = 2 Remainder 1\n2 / 2  = 1 Remainder 0\n1 / 2  = 0 Remainder 1\n\nResult (read remainders from bottom to top): 101101\nPad to 8 bits (on the left): 00101101\n\n\n\n\n\nMethod: Repeatedly multiply by 2 & note the integer part.\nCalculation:\n\n0.375 * 2 = 0.75 -&gt; 0\n0.75  * 2 = 1.5 -&gt; 1\n0.5   * 2 = 1.0 -&gt; 1\n\nResult (read digits from top to bottom): 011\nPad to 4 bits (on the right): 0110\n\n\n\n\n\nInteger: 00101101\nFraction: 0110\nFinal (12-Bit): 001011010110\n\n\n\n\nNot every fraction can be represented exactly.\nInteger 2 -&gt; 00000010\nFraction 0.3 -&gt; 0.010011... (repeating)\nTruncated to 4 bits: 0100 (which represents 0.25)\nFinal result for 2.3: 000000100100 (represents 2.25)"
  },
  {
    "objectID": "hs25/csc/csc_exercises.html#exercise-1-internet-delays-and-routes",
    "href": "hs25/csc/csc_exercises.html#exercise-1-internet-delays-and-routes",
    "title": "Computer Science Concepts for Data Scientists - Exercises",
    "section": "Exercise 1: Internet Delays and Routes",
    "text": "Exercise 1: Internet Delays and Routes\n\na\nTraceroute is a command line tool for determining the transport route of IP data packets between your own computer and a selected remote station.\ntraceroute gaia.cs.umass.edu\n\n\nb\nThe number of routers along the path depends on the network route and topology ‚Äî for example, whether a VPN or proxy is used, but not on the local access medium (WiFi vs.¬†Ethernet)."
  },
  {
    "objectID": "hs25/csc/csc_exercises.html#exercise-2-internet-delays",
    "href": "hs25/csc/csc_exercises.html#exercise-2-internet-delays",
    "title": "Computer Science Concepts for Data Scientists - Exercises",
    "section": "Exercise 2: Internet Delays",
    "text": "Exercise 2: Internet Delays\n\na\n\\[\n\\text{file} = 4\\text{MB} = 4000\\text{bytes} = 32000\\text{bites}\n\\]\n\\[\nR_s = 1\\text{Mbit/sec} = \\dfrac{32000}{1000} = 32\\text{sec}\n\\]"
  },
  {
    "objectID": "hs25/csc/csc_exercises.html#exercise-3-domains-hosts-and-urls",
    "href": "hs25/csc/csc_exercises.html#exercise-3-domains-hosts-and-urls",
    "title": "Computer Science Concepts for Data Scientists - Exercises",
    "section": "Exercise 3: Domains, Hosts and URLs",
    "text": "Exercise 3: Domains, Hosts and URLs\nflowchart TD\n    A(Root) --&gt; B(edu)\n    B --&gt; C[umass]\n    C --&gt; E(cs)\n    F[gaia]\n    D[www]\n\n    %% Subgraph trick\n    subgraph row1[ ]\n        direction LR\n        C\n        D\n    end\n\n    %% Subgraph trick\n    subgraph row2[ ]\n        direction LR\n        E\n        F\n    end"
  },
  {
    "objectID": "hs25/csc/csc_exercises.html#exercise-4-http-protocol",
    "href": "hs25/csc/csc_exercises.html#exercise-4-http-protocol",
    "title": "Computer Science Concepts for Data Scientists - Exercises",
    "section": "Exercise 4: http Protocol",
    "text": "Exercise 4: http Protocol\nWhenever a user downloads a new web page a copy is saved on the local web server (cache). If the same page is requested again later by the same or another user AND it is still valid (i.e., the expiration date has not yet been reached), the page does not have to be fetched again from the remote web server."
  },
  {
    "objectID": "hs25/csc/csc_exercises.html#exercise-2-develop-a-web-page---task-1",
    "href": "hs25/csc/csc_exercises.html#exercise-2-develop-a-web-page---task-1",
    "title": "Computer Science Concepts for Data Scientists - Exercises",
    "section": "Exercise 2: Develop a web page - Task 1",
    "text": "Exercise 2: Develop a web page - Task 1\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    Exercise 2: Develop a web page - Task 1\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;img src=\"img/siliconValley.jpg\" hight=\"1000\" width=\"500\"&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\n\n  \n    Exercise 2: Develop a web page - Task 1"
  },
  {
    "objectID": "hs25/csc/csc_exercises.html#exercise-2-develop-a-web-page---task-2",
    "href": "hs25/csc/csc_exercises.html#exercise-2-develop-a-web-page---task-2",
    "title": "Computer Science Concepts for Data Scientists - Exercises",
    "section": "Exercise 2: Develop a web page - Task 2",
    "text": "Exercise 2: Develop a web page - Task 2\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    Exercise 2: Develop a web page - Task 2\n  &lt;/head&gt;\n\n  &lt;body&gt;\n    &lt;h2&gt;Links to well-known companies in Silicon Valley&lt;/h2&gt;\n    &lt;img src=\"img/tesla.png\"&gt;\n    &lt;h2&gt;Link to overview map Silicon Valley&lt;/h2&gt;\n    &lt;a href=\"https://siliconvalleyguide.info/\"&gt;Map&lt;/a&gt;\n\n  &lt;/body&gt;\n&lt;/html&gt;\n\n\n  \n    Exercise 2: Develop a web page - Task 2\n  \n\n  \n    Links to well-known companies in Silicon Valley\n    \n    Link to overview map Silicon Valley\n    Map"
  },
  {
    "objectID": "hs25/csc/csc_exercises.html#exercise-3-develop-a-css-file",
    "href": "hs25/csc/csc_exercises.html#exercise-3-develop-a-css-file",
    "title": "Computer Science Concepts for Data Scientists - Exercises",
    "section": "Exercise 3: Develop a CSS file",
    "text": "Exercise 3: Develop a CSS file\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Exercise 3: Develop a CSS file&lt;/title&gt;\n\n    &lt;style&gt;\n      body { \n        background-color: lightgoldenrodyellow;\n        color: blue;\n      }\n      \n      img {\n        border: 2px solid blue;\n        padding: 5px;\n      }\n      \n      a {\n        color: red;\n      }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;h2&gt;Links to well-known companies in Silicon Valley&lt;/h2&gt;    \n    &lt;img src=\"img/tesla.png\" alt=\"Tesla Logo\"&gt;\n    &lt;h2&gt;Link to overview map Silicon Valley&lt;/h2&gt;\n    &lt;a href=\"https://siliconvalleyguide.info/\"&gt;Map&lt;/a&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;"
  },
  {
    "objectID": "hs25/csc/csc_exercises.html#exercise-1",
    "href": "hs25/csc/csc_exercises.html#exercise-1",
    "title": "Computer Science Concepts for Data Scientists - Exercises",
    "section": "Exercise 1",
    "text": "Exercise 1\nDevelop a recursive algorithm for the function power(x, n).\n\ndef power(x, n):\n    if n == 0:\n        return 1\n    else:\n        return x * power(x, n - 1)\n\nres = power(2, 3)\nprint(res)\n\n8"
  },
  {
    "objectID": "hs25/csc/csc_exercises.html#exercise-2",
    "href": "hs25/csc/csc_exercises.html#exercise-2",
    "title": "Computer Science Concepts for Data Scientists - Exercises",
    "section": "Exercise 2",
    "text": "Exercise 2\nDevelop a recursive algorithm for the product of the natural odd numbers from m to n: product(m, n).\n\ndef product(m: int, n: int) -&gt; int:\n  \"\"\" Returns the product of the odd numbers from m to n \"\"\"\n  # Check for only odd number inputs\n  assert m % 2 == 1 and n % 2 == 1\n\n  # Recursion\n  if m == n:\n    return m\n  else:\n    return m * product(m + 2, n)\n\n\nres = product(3, 11)\nprint(res)\n\n10395"
  },
  {
    "objectID": "hs25/csc/csc_exercises.html#exercise-3",
    "href": "hs25/csc/csc_exercises.html#exercise-3",
    "title": "Computer Science Concepts for Data Scientists - Exercises",
    "section": "Exercise 3",
    "text": "Exercise 3\n\n\n\nLinear Search\nLinear search sequentially checks each element of the list until a match is found or the whole list has been searched. For a list of length \\(n\\) results a complexity of \\(O(n)\\).\n\n\n\nBinary Search\nBinary search compares the target value to the middle element of the list. For a list of length \\(n\\) results a complexity of \\(O(\\log(n))\\)."
  },
  {
    "objectID": "hs25/pds/pds_exercises.html",
    "href": "hs25/pds/pds_exercises.html",
    "title": "Python for Data Science - Exercises",
    "section": "",
    "text": "print(f\"10 + 10 + 10 = {10 + 10 + 10}\")\nprint(f\"10 - 3       = {10 - 3}\")\nprint(f\"10 * 2       = {10 * 2}\")\nprint(f\"5 / 2        = {5 / 2}\")\nprint(f\"5.0 / 2      = {5.0 / 2}\")\nprint(f\"5 % 2        = {5 % 2}\")\nprint(f\"10 % 3       = {10 % 3}\")\nprint(f\"3 ** 3       = {3 ** 3}\")\nprint(f\"9 ** 0.5     = {9 ** 0.5}\")\nprint(f\"10 + 3 * 3   = {10 + 3 * 3}\")\nprint(f\"(10 + 3) * 3 = {(10 + 3) * 3}\")\n\n10 + 10 + 10 = 30\n10 - 3       = 7\n10 * 2       = 20\n5 / 2        = 2.5\n5.0 / 2      = 2.5\n5 % 2        = 1\n10 % 3       = 1\n3 ** 3       = 27\n9 ** 0.5     = 3.0\n10 + 3 * 3   = 19\n(10 + 3) * 3 = 39\n\n\n\n\n\n\na = 23\nb = 23\nprint(f\"a = {a}\")\nprint(f\"The ID of a is {id(a)}\") # Prints memory address of the variable a\nprint(f\"a is of type {type(a)}\") # Prints the data type of the variable a\n\na = 23\nThe ID of a is 11761384\na is of type &lt;class 'int'&gt;\n\n\n\nNote: id() corresponds to the objects memory address during its lifetime.\n\n\nprint(f\"b = {b}\")\nprint(f\"The ID of b is {id(b)}\")\nprint(f\"b is of type {type(a)}\")\n\nb = 23\nThe ID of b is 11761384\nb is of type &lt;class 'int'&gt;\n\n\n\n\n\n\na = 123 # Reassign var a to int 123\nprint(f\"a = {a}\")\nprint(f\"The ID of a is {id(a)}\")\nprint(f\"a is of type {type(a)}\")\n\na = 123\nThe ID of a is 11764584\na is of type &lt;class 'int'&gt;\n\n\n\n\n\n\nc = 23\nprint(f\"c = {c}\")\nprint(f\"The ID of a is {id(c)}\")\nprint(f\"c is of type {type(c)}\")\n\nc = 23\nThe ID of a is 11761384\nc is of type &lt;class 'int'&gt;\n\n\nWe assign the variable c to the value 23 and check its data type and memory location.\n\n\n\n\nd = 3.142\nprint(f\"d = {d}\")\nprint(f\"The ID of a is {id(d)}\")\nprint(f\"d is of type {type(d)}\")\n\nd = 3.142\nThe ID of a is 123289840884880\nd is of type &lt;class 'float'&gt;\n\n\n\n\n\n\nprint (\"HSLU's Python course is cool\")\n\nprint(\"This is Line 1\")\nprint(\"This is Line 2\")\n\nprint(\"\\nWhat does the \\\\n control character do? Are you sure?\") # \\n is a line break\n\nprint(\"\\tWhat does the \\\\t control character do? Are you sure?\") # \\t is a tabulator\n\nprint(\"I want to learn python because....\")\nprint(\"\\n\\n\\t....it's a cool data science programming language. Ok - there are also others ;-) !\")\n\nprint(\"What \" + \"is \" + \"wrong?\" + \"\\nAdd some space between the words without removing the '+' signs!\") # Add spaces after the string\n\nHSLU's Python course is cool\nThis is Line 1\nThis is Line 2\n\nWhat does the \\n control character do? Are you sure?\n    What does the \\t control character do? Are you sure?\nI want to learn python because....\n\n\n    ....it's a cool data science programming language. Ok - there are also others ;-) !\nWhat is wrong?\nAdd some space between the words without removing the '+' signs!\n\n\n\n\n\n\ng=h='hslu'      # Assign the var g and h to the string \"hslu\"\nprint(g)        # Prints hslu\nprint(h)        # Print hslu\nh=456           # Reassign h to int 456\nprint(h)        # Prints 456\nh=h+1           # Calculates 456 + 1 = 457\nprint(h)        # Prints 457\nh+=1            # Calculates 457 + 1 = 458\nprint(h)        # Prints 458\np='hslu'        # Assign the var p to the string \"hslu\"\nq=p             # Copies the var p (hlsu) to the var q\nprint(p==q)     # Compare the var p and q (Output: True)\nprint(p is q)   # Compare the var p and q (Output: True)\n\nhslu\nhslu\n456\n457\n458\nTrue\nTrue"
  },
  {
    "objectID": "hs25/pds/pds_exercises.html#exercises-1",
    "href": "hs25/pds/pds_exercises.html#exercises-1",
    "title": "Python for Data Science - Exercises",
    "section": "",
    "text": "print(f\"10 + 10 + 10 = {10 + 10 + 10}\")\nprint(f\"10 - 3       = {10 - 3}\")\nprint(f\"10 * 2       = {10 * 2}\")\nprint(f\"5 / 2        = {5 / 2}\")\nprint(f\"5.0 / 2      = {5.0 / 2}\")\nprint(f\"5 % 2        = {5 % 2}\")\nprint(f\"10 % 3       = {10 % 3}\")\nprint(f\"3 ** 3       = {3 ** 3}\")\nprint(f\"9 ** 0.5     = {9 ** 0.5}\")\nprint(f\"10 + 3 * 3   = {10 + 3 * 3}\")\nprint(f\"(10 + 3) * 3 = {(10 + 3) * 3}\")\n\n10 + 10 + 10 = 30\n10 - 3       = 7\n10 * 2       = 20\n5 / 2        = 2.5\n5.0 / 2      = 2.5\n5 % 2        = 1\n10 % 3       = 1\n3 ** 3       = 27\n9 ** 0.5     = 3.0\n10 + 3 * 3   = 19\n(10 + 3) * 3 = 39\n\n\n\n\n\n\na = 23\nb = 23\nprint(f\"a = {a}\")\nprint(f\"The ID of a is {id(a)}\") # Prints memory address of the variable a\nprint(f\"a is of type {type(a)}\") # Prints the data type of the variable a\n\na = 23\nThe ID of a is 11761384\na is of type &lt;class 'int'&gt;\n\n\n\nNote: id() corresponds to the objects memory address during its lifetime.\n\n\nprint(f\"b = {b}\")\nprint(f\"The ID of b is {id(b)}\")\nprint(f\"b is of type {type(a)}\")\n\nb = 23\nThe ID of b is 11761384\nb is of type &lt;class 'int'&gt;\n\n\n\n\n\n\na = 123 # Reassign var a to int 123\nprint(f\"a = {a}\")\nprint(f\"The ID of a is {id(a)}\")\nprint(f\"a is of type {type(a)}\")\n\na = 123\nThe ID of a is 11764584\na is of type &lt;class 'int'&gt;\n\n\n\n\n\n\nc = 23\nprint(f\"c = {c}\")\nprint(f\"The ID of a is {id(c)}\")\nprint(f\"c is of type {type(c)}\")\n\nc = 23\nThe ID of a is 11761384\nc is of type &lt;class 'int'&gt;\n\n\nWe assign the variable c to the value 23 and check its data type and memory location.\n\n\n\n\nd = 3.142\nprint(f\"d = {d}\")\nprint(f\"The ID of a is {id(d)}\")\nprint(f\"d is of type {type(d)}\")\n\nd = 3.142\nThe ID of a is 123289840884880\nd is of type &lt;class 'float'&gt;\n\n\n\n\n\n\nprint (\"HSLU's Python course is cool\")\n\nprint(\"This is Line 1\")\nprint(\"This is Line 2\")\n\nprint(\"\\nWhat does the \\\\n control character do? Are you sure?\") # \\n is a line break\n\nprint(\"\\tWhat does the \\\\t control character do? Are you sure?\") # \\t is a tabulator\n\nprint(\"I want to learn python because....\")\nprint(\"\\n\\n\\t....it's a cool data science programming language. Ok - there are also others ;-) !\")\n\nprint(\"What \" + \"is \" + \"wrong?\" + \"\\nAdd some space between the words without removing the '+' signs!\") # Add spaces after the string\n\nHSLU's Python course is cool\nThis is Line 1\nThis is Line 2\n\nWhat does the \\n control character do? Are you sure?\n    What does the \\t control character do? Are you sure?\nI want to learn python because....\n\n\n    ....it's a cool data science programming language. Ok - there are also others ;-) !\nWhat is wrong?\nAdd some space between the words without removing the '+' signs!\n\n\n\n\n\n\ng=h='hslu'      # Assign the var g and h to the string \"hslu\"\nprint(g)        # Prints hslu\nprint(h)        # Print hslu\nh=456           # Reassign h to int 456\nprint(h)        # Prints 456\nh=h+1           # Calculates 456 + 1 = 457\nprint(h)        # Prints 457\nh+=1            # Calculates 457 + 1 = 458\nprint(h)        # Prints 458\np='hslu'        # Assign the var p to the string \"hslu\"\nq=p             # Copies the var p (hlsu) to the var q\nprint(p==q)     # Compare the var p and q (Output: True)\nprint(p is q)   # Compare the var p and q (Output: True)\n\nhslu\nhslu\n456\n457\n458\nTrue\nTrue"
  },
  {
    "objectID": "hs25/pds/pds_exercises.html#task-1",
    "href": "hs25/pds/pds_exercises.html#task-1",
    "title": "Python for Data Science - Exercises",
    "section": "Task 1",
    "text": "Task 1\nCreate a simple program in which three whole numbers (potentially negative!) are read in from the keyboard and afterwards get displayed on the screen in ascending order. Use nested if-statements for order determination (i.e.¬†no built-in- ‚Äòsort‚Äô function).\n\nUsing if-else-statements\n\ninputs = [] # Set up storage\n\nprint(\"Please input 3 whole numbers of your choise.\")\n\"\"\"\ninput1 = int(input(\"Number one: \")) # Assign input to a variable\ninput2 = int(input(\"Number two: \"))\ninput3 = int(input(\"Number tree: \"))\n\"\"\"\n\n# Use fake user inputs\ninput1 = -3\ninput2 = 10\ninput3 = -6\n\n# Sort list\nif input1 &lt; input2 and input1 &lt; input3:\n    inputs.append(input1) # Append input to list\n    if input2 &lt; input3:\n        inputs.append(input2)\n        inputs.append(input3)\n    else:\n        inputs.append(input3)\n        inputs.append(input2)\nelif input2 &lt; input1 and input2 &lt; input3:\n    inputs.append(input2)\n    if input1 &lt; input3:\n        inputs.append(input1)\n        inputs.append(input3)\n    else:\n        inputs.append(input3)\n        inputs.append(input1)\nelif input3 &lt; input1 and input3 &lt; input2:\n    inputs.append(input3)\n    if input1 &lt; input2:\n        inputs.append(input1)\n        inputs.append(input2)\n    else:\n        inputs.append(input2)\n        inputs.append(input1)\n\nprint(inputs)\n\nPlease input 3 whole numbers of your choise.\n[-6, -3, 10]\n\n\n\n\nUsing build in function sorted()\n\ninputs = [] # Set up storage\n\nprint(\"Please input 3 whole numbers of your choise.\")\n\"\"\"\ninput1 = int(input(\"Number one: \")) # Assign input to a variable\ninputs.append(input1)\ninput2 = int(input(\"Number two: \"))\ninputs.append(input2)\ninput3 = int(input(\"Number tree: \"))\ninputs.append(input3)\n\"\"\"\n\n# Use fake user inputs\ninput1 = -3\ninputs.append(input1)\ninput2 = 10\ninputs.append(input2)\ninput3 = -6\ninputs.append(input3)\n\n# Sort list\ninputs = sorted(inputs)\nprint(inputs)\n\nPlease input 3 whole numbers of your choise.\n[-6, -3, 10]"
  },
  {
    "objectID": "hs25/pds/pds_exercises.html#task-2",
    "href": "hs25/pds/pds_exercises.html#task-2",
    "title": "Python for Data Science - Exercises",
    "section": "Task 2",
    "text": "Task 2\n\na\nAssumption: The int variables a, b and c are declared and initialized.\nDefine a conditional expression ‚ÄúEXPR‚Äù in such a way that the body of the expression\nif EXPR: print(‚Äúcondition fulfilled‚Äù)\nis only carried out if: a is greater than b OR a is less than half of b OR the sum of a and c is greater than b.\nCheck your result: a=1, b=2, c=2 -&gt; True a=1, b=2, c=1 -&gt; False\n\n# Test case one\na = 1\nb = 2\nc = 2\n\nif a &gt; b or a &lt; b/2 or sum([a, c]) &gt; b:\n    print(\"condition fulfilled\")\nelse:\n    print(\"condition not fulfilled\")\n\ncondition fulfilled\n\n\n\n# Test case two\na = 1\nb = 2\nc = 1\n\nif a &gt; b or a &lt; b/2 or sum([a, c]) &gt; b:\n    print(\"condition fulfilled\")\nelse:\n    print(\"condition not fulfilled\")\n\ncondition not fulfilled\n\n\n\n\nb\nAssumption: The int variables a, b and c are declared and initialized.\nDefine a conditional expression ‚ÄúEXPR‚Äù in such a way that the body of the expression\nif EXPR: print(‚Äúcondition fulfilled‚Äù)\nis only carried out if: half of the number a is an odd number OR the subtraction of the numbers b and c results in an even number OR both a and b and also b and c have different values.\nCheck your result: a=6, b=2, c=0 =&gt; True a=5, b=2, c=1 =&gt; True a=5, b=5, c=2 =&gt; False\n\n# Test case one\na = 6\nb = 2\nc = 0\n\nif a/2 % 2 == 1 or b - c % 2 == 0 or a != b and b != c:\n        print(\"condition fulfilled\")\nelse:\n    print(\"condition not fulfilled\")\n\ncondition fulfilled\n\n\n\n# Test case two\n# Test case one\na = 5\nb = 2\nc = 1\n\nif a/2 % 2 == 1 or b - c % 2 == 0 or a != b and b != c:\n        print(\"condition fulfilled\")\nelse:\n    print(\"condition not fulfilled\")\n\ncondition fulfilled\n\n\n\n# Test case three\n# Test case one\na = 5\nb = 5\nc = 2\n\nif a/2 % 2 == 1 or b - c % 2 == 0 or a != b and b != c:\n        print(\"condition fulfilled\")\nelse:\n    print(\"condition not fulfilled\")\n\ncondition not fulfilled"
  },
  {
    "objectID": "hs25/pds/pds_exercises.html#exercise-1",
    "href": "hs25/pds/pds_exercises.html#exercise-1",
    "title": "Python for Data Science - Exercises",
    "section": "Exercise 1",
    "text": "Exercise 1\nWrite a python program that constructs the following pattern using a nested for loop:\n*\n**\n***\n****\n*****\n****\n***\n**\n*\n\nupper  = range(0, 6, 1) # Define upper pattern\nlower = range(6, 0, -1) # Define lower pattern\n\n\nfor i in upper:\n    print(\"*\" * i) # Print upper part of pattern\nelse: # After done\n    for j in lower:\n        print(\"*\" * j) # Print lower part of pattern\n\n\n*\n**\n***\n****\n*****\n******\n*****\n****\n***\n**\n*"
  },
  {
    "objectID": "hs25/pds/pds_exercises.html#exercise-2",
    "href": "hs25/pds/pds_exercises.html#exercise-2",
    "title": "Python for Data Science - Exercises",
    "section": "Exercise 2",
    "text": "Exercise 2\nWrite a python program to count the number of even and odd numbers contained in a sequence of numbers.\n\neven_numbers = []\nodd_numbers = []\nnumbers = (1,2,3,4,5,6,7,8,9,10)\n\nfor i in range(len(numbers)):\n    if i % 2 == 0: # Check if current number is even\n        even_numbers.append(i)\n    else:\n        odd_numbers.append(i)\n\nprint(f\"Total number of even numbers: {len(even_numbers)}\") # Use len() to count\nprint(f\"Total number of even numbers: {len(odd_numbers)}\")\n\nTotal number of even numbers: 5\nTotal number of even numbers: 5"
  },
  {
    "objectID": "hs25/pds/pds_exercises.html#exercise-3",
    "href": "hs25/pds/pds_exercises.html#exercise-3",
    "title": "Python for Data Science - Exercises",
    "section": "Exercise 3",
    "text": "Exercise 3\nWrite a Python program which takes two digits m (row) and n (column) as input and generates a two-dimensional structure (e.g.¬†nested list). The value in the i-th row and j-th column should be i*j.\n\nrows = 3\ncolumns = 4\nresult = [] # Define master list\n\nfor row in range(rows):\n    sub_list = [] # Define sub-list\n    for column in range(columns):\n        sub_list.append(row * column) # Calc value\n    result.append(sub_list) # Append sub-list to master list\n\nprint(result)\n\n[[0, 0, 0, 0], [0, 1, 2, 3], [0, 2, 4, 6]]"
  },
  {
    "objectID": "hs25/pds/pds_exercises.html#exercise-4",
    "href": "hs25/pds/pds_exercises.html#exercise-4",
    "title": "Python for Data Science - Exercises",
    "section": "Exercise 4",
    "text": "Exercise 4\nWrite a Python program to find all numbers between 200 and 500 (limits included) only containing even digits. Correct solution:\n\nmy_range = range(200, 501) # Include boarders\neven_digit_numbers = [] # Final result\n\nfor number in my_range: \n    test_result = []\n    for digit in str(number):\n        if int(digit) % 2 == 1:\n            test_result.append(True) # Add true for odd digit\n        else:\n            test_result.append(False) # Add false for even digit\n    if any(test_result):\n        pass # Pass if any odd digit (false) is in test_result\n    else:\n        even_digit_numbers.append(number) # Append to final result\n\nprint(even_digit_numbers)\n\n[200, 202, 204, 206, 208, 220, 222, 224, 226, 228, 240, 242, 244, 246, 248, 260, 262, 264, 266, 268, 280, 282, 284, 286, 288, 400, 402, 404, 406, 408, 420, 422, 424, 426, 428, 440, 442, 444, 446, 448, 460, 462, 464, 466, 468, 480, 482, 484, 486, 488]"
  },
  {
    "objectID": "hs25/pds/pds_exercises.html#exercise-5",
    "href": "hs25/pds/pds_exercises.html#exercise-5",
    "title": "Python for Data Science - Exercises",
    "section": "Exercise 5",
    "text": "Exercise 5\nWrite a Python program to guess a number between 1 to 10. First: Use the predefined code block to create a random number Second: The user is prompted to enter a guess. If the guess is wrong a message ‚Äúto big‚Äù or ‚Äúto small‚Äù is printed to the console and the prompt (user input) appears again until the guess is correct. If the guess is correct, ‚ÄúWell guessed!‚Äù will be printed and the program ends. Extension: The number of trials should be prompted as well: ‚ÄúWell done - you have tried it 4 times!‚Äù\n\n# Code block to create a random number\nfrom random import randint\nrandom_number = randint(1,10)\n# End code block to create a random number\n\ntrials = 0\n\nwhile True: # Infinitive loop till break\n    # Unsing fake user input\n    user_input = randint(1,10) # Also random\n    trials += 1 # Count trials\n    if user_input == random_number:\n        print(f\"Well done - you have tried it {trials} times!\")\n        break\n    elif user_input &lt; random_number:\n        print(\"Guess to low...\")\n    else:\n        print(\"Guess to high...\")\n\nGuess to low...\nGuess to high...\nWell done - you have tried it 3 times!"
  },
  {
    "objectID": "hs25/pds/pds_exercises.html#exercise-6",
    "href": "hs25/pds/pds_exercises.html#exercise-6",
    "title": "Python for Data Science - Exercises",
    "section": "Exercise 6",
    "text": "Exercise 6\nSuppose we wish to draw a Christmas tree. Example tree - desired height: 8 The result looks like:\n     x\n    xxx\n   xxxxx\n  xxxxxxx\n xxxxxxxxx\nxxxxxxxxxxx\n    xxx\n    xxx\nCreate a program that asks the user for the height of the Christmas tree (trunk included) and then draws the tree. The height of the trunk is always 2 and the width is 3 in case the entire height is &gt; 5 and 1 in case the tree is smaller.\n\ntotal_height = 8\ntrunk_height = 2\ncrown_height = total_height - trunk_height\nmax_crown_width = 2 * (crown_height - 1) + 1\n\nif total_height &gt; 5:\n    trunk_width = 3\nelse:\n    trunk_width = 1\n\ni = 0\nwhile i &lt; crown_height:\n    current_crown_width = 2 * i + 1\n    spaces = (max_crown_width - current_crown_width) // 2\n    print(\" \" * spaces + \"x\" * current_crown_width)\n    i += 1\n\ntrunk_padding = (max_crown_width - trunk_width) // 2\n\nj = 0\nwhile j &lt; trunk_height:\n    print(\" \" * trunk_padding + \"x\" * trunk_width)\n    j += 1\n\n     x\n    xxx\n   xxxxx\n  xxxxxxx\n xxxxxxxxx\nxxxxxxxxxxx\n    xxx\n    xxx"
  },
  {
    "objectID": "hs25/pds/pds_exercises.html#exercise-1-1",
    "href": "hs25/pds/pds_exercises.html#exercise-1-1",
    "title": "Python for Data Science - Exercises",
    "section": "Exercise 1",
    "text": "Exercise 1\nWrite a Python program to guess a number between 1 to 10. First: Use the predefined code block to create a random number Second: The user is prompted to enter a guess. If the guess is wrong a message ‚Äúto big‚Äù or ‚Äúto small‚Äù is printed to the console and the prompt (user input) appears again until the guess is correct. If the guess is correct, ‚ÄúWell guessed!‚Äù will be printed and the program ends. Extension: The number of trials should be prompted as well: ‚ÄúWell done - you have tried it 4 times!‚Äù\n\n# Code block to create a random number\nfrom random import randint\nrandom_number = randint(1,10)\n# End code block to create a random number\n\ntrials = 0\n\nwhile True: # Infinitive loop till break\n    # Unsing fake user input\n    user_input = randint(1,10) # Also random\n    trials += 1 # Count trials\n    if user_input == random_number:\n        print(f\"Well done - you have tried it {trials} times!\")\n        break\n    elif user_input &lt; random_number:\n        print(\"Guess to low...\")\n    else:\n        print(\"Guess to high...\")\n\nGuess to low...\nGuess to high...\nGuess to high...\nGuess to low...\nGuess to high...\nGuess to low...\nGuess to low...\nGuess to low...\nGuess to low...\nWell done - you have tried it 10 times!"
  },
  {
    "objectID": "hs25/pds/pds_exercises.html#exercise-1-2",
    "href": "hs25/pds/pds_exercises.html#exercise-1-2",
    "title": "Python for Data Science - Exercises",
    "section": "Exercise 1",
    "text": "Exercise 1\nWrite a function that accepts a list of integers as input and returns a list containing all even numbers of the input list.\n\ndef extract_even_num(num_list: list[int]) -&gt; list:\n    \"\"\"\n    Returns all even numbers of within a given list\n\n    Args:\n        num_list: A list with integers.\n\n    Returns:\n        list: A list with all even numbers from num_list\n    \"\"\"\n    even_num_list = [] # Result storage\n    for num in num_list:\n        if num % 2 == 0: # Check for even or odd\n            even_num_list.append(num)\n    \n    return even_num_list # Return result\n\neven_num = extract_even_num((1, 2, 3 ,4, 5, 6, 7, 8, 9))\nprint(even_num)\n\n[2, 4, 6, 8]"
  },
  {
    "objectID": "hs25/pds/pds_exercises.html#exercice-2",
    "href": "hs25/pds/pds_exercises.html#exercice-2",
    "title": "Python for Data Science - Exercises",
    "section": "Exercice 2",
    "text": "Exercice 2\nWrite a function accepts a list as input and returns the unique values contained in that list as a list. Hint: you can use the ‚Äúset‚Äù method to check your solution.\n\ndef get_unique_values(value_list: list) -&gt; set:\n    \"\"\"\n    Return a set (unique values) from a given list\n\n    Args:\n        value_list: List with different values\n    \n    Returns:\n        set: Unique values from value_list\n    \"\"\"\n    return set(value_list)\n\nuniques = get_unique_values((1, 2, 2, 3, \"Hello\", \"Hello\", \"Bye\"))\nprint(uniques)\n\n{1, 2, 3, 'Bye', 'Hello'}"
  },
  {
    "objectID": "hs25/pds/pds_exercises.html#exercise-3-1",
    "href": "hs25/pds/pds_exercises.html#exercise-3-1",
    "title": "Python for Data Science - Exercises",
    "section": "Exercise 3",
    "text": "Exercise 3\nCrate a simple calculator that provides functions to add, subtract, multiply and divide two numbers. Implement the missing parts to execute the main() function below without an error.\n\ndef add(num1: int, num2: int) -&gt; int:\n    \"\"\" Add two numbers \"\"\"\n    return num1 + num2\n\ndef subtract(num1: int, num2: int) -&gt; int:\n    \"\"\" Subtract two numbers \"\"\"\n    return num1 - num2\n\ndef multiply(num1: int, num2: int) -&gt; int:\n    \"\"\" Multiply two numbers \"\"\"\n    return num1 * num2\n\ndef divide(num1: int, num2: int) -&gt; int:\n    \"\"\" Divide two numbers \"\"\"\n    return num1 / num2\n\ndef main():\n    print(\"Select operation.\")\n    print(\"1.Add\")\n    print(\"2.Subtract\")\n    print(\"3.Multiply\")\n    print(\"4.Divide\")\n\n    # Take input from the user\n    # choice = input(\"Enter choice(1/2/3/4):\")\n    # Using fake user inputs\n    choice = str(1)\n\n    # num1 = int(input(\"Enter first number: \"))\n    # num2 = int(input(\"Enter second number: \"))\n    # Using fake user inputs\n\n    num1 = 4\n    num2 = 5\n\n    if choice == '1':\n       print(num1,\"+\",num2,\"=\", add(num1,num2))\n\n    elif choice == '2':\n       print(num1,\"-\",num2,\"=\", subtract(num1,num2))\n\n    elif choice == '3':\n       print(num1,\"*\",num2,\"=\", multiply(num1,num2))\n\n    elif choice == '4':\n       print(num1,\"/\",num2,\"=\", divide(num1,num2))\n    else:\n       print(\"Invalid input\")\n\nmain()\n\nSelect operation.\n1.Add\n2.Subtract\n3.Multiply\n4.Divide\n4 + 5 = 9"
  },
  {
    "objectID": "hs25/pds/pds_exercises.html#extercise-4",
    "href": "hs25/pds/pds_exercises.html#extercise-4",
    "title": "Python for Data Science - Exercises",
    "section": "Extercise 4",
    "text": "Extercise 4\nKeyword parameters If we want call the function circumference(2) with the ‚Äòwidth‚Äô 2 we have a problem: The number ‚Äò2‚Äô is by default assigned to the first Parameter and that is ‚Äòlength‚Äô ‚Ä¶ Task: Change the calls so that the function circumference(2) is called with ‚Äòwidth‚Äô 2!\n\ndef circumference(length = 2, width = 1):\n     return 2 * (length + width)\n\nc1 = circumference(width=2)         # 2 should be the width !!!\nprint(c1)\n\n# or with length 5 and width 3:\nc2 = circumference(5, 3)\nprint(c2)\n\n# how could the function also have been called\n# with length 5 and width 3\nc3 = circumference(length=5, width=3)\nprint(c3)\n\n# you can even change the order of keyword parameters\n# try it: Change the order of  parameters!\nc4 = circumference (width=3, length=5)     # order swapped!\nprint(c4)\n\n8\n16\n16\n16"
  },
  {
    "objectID": "hs25/pds/pds_exercises.html#exercise-5-1",
    "href": "hs25/pds/pds_exercises.html#exercise-5-1",
    "title": "Python for Data Science - Exercises",
    "section": "Exercise 5",
    "text": "Exercise 5\nFunctions may have parameters which may have default values.\nTask: Change the two examples (1 and 2) such that the two function calls hello(‚Ä¶) and the three function calls circumference(‚Ä¶) run without any error.\n\n# Example 1:\ndef hello (name = \"Mr. Unknown\"):\n     print (\"Hello \" + name + \"!\")\n\nhello(\"Peter\")\n\n# without parameters (default value used)\nhello()\n\n\n# Example 2:\ndef circumference (length=1, width=1):\n     return 2 * (length + width)\n\nc1 = circumference(5, 3)\nprint(c1)\n\n# for the width, the default value \"1\" is used.\nc2 = circumference(5)\nprint(c2)\n\n# both default values are used.\nc3 = circumference()\nprint(c3)\n\nHello Peter!\nHello Mr. Unknown!\n16\n12\n4"
  },
  {
    "objectID": "hs25/pds/pds_exercises.html#exercise-01",
    "href": "hs25/pds/pds_exercises.html#exercise-01",
    "title": "Python for Data Science - Exercises",
    "section": "Exercise 01",
    "text": "Exercise 01\nWrite a program that combines three lines from the file ‚Äòmusicians.txt‚Äô into one line and writes them as standard output using print(). That means: An output line should contain: first name, last name and artist name (‚ÄúK√ºnstername‚Äù) or band of the artist. The band or artist name should be printed in round brackets and in captial letters. Example: ‚ÄúMarshall Bruce Mathers III (EMINEM)‚Äù\n\nwith open('data/musicians.txt', mode='r') as file: # Read file\n        musicians = [line.rstrip() for line in file]\n\nfirst_name = 0\nartist_name = 1\nband = 2\n\nwhile band &lt; len(musicians):\n    print(f\"{musicians[first_name]} {musicians[artist_name]} ({str.upper(musicians[band])})\")\n\n    first_name += 3\n    artist_name += 3\n    band += 3\n\nBrian Molko (PLACEBO)\nJim Morrison (THE DOORS)\nRay Davies (THE KINKS)\nMarshall Bruce Mathers III (EMINEM)\nAndre Romelle Young (DR. DRE)\nBeth Gibbons (PORTISHEAD)"
  },
  {
    "objectID": "hs25/pds/pds_exercises.html#exercise-02",
    "href": "hs25/pds/pds_exercises.html#exercise-02",
    "title": "Python for Data Science - Exercises",
    "section": "Exercise 02",
    "text": "Exercise 02\nChange the solution of Exercise 02 so that the program writes the output to the file ‚Äòmusicians2.txt‚Äô.\n\nwith open('data/musicians.txt', mode='r') as file: # Read file\n        musicians = [line.rstrip() for line in file]\n\nfirst_name = 0\nartist_name = 1\nband = 2\n\nwhile band &lt; len(musicians):\n    with open('data/musicians2.txt', mode='a') as file2: # Mode = Append\n        file2.write(f\"{musicians[first_name]} {musicians[artist_name]} ({str.upper(musicians[band])})\\n\")\n\n    first_name += 3\n    artist_name += 3\n    band += 3"
  },
  {
    "objectID": "hs25/pds/pds_exercises.html#exercise-01-1",
    "href": "hs25/pds/pds_exercises.html#exercise-01-1",
    "title": "Python for Data Science - Exercises",
    "section": "Exercise 01",
    "text": "Exercise 01\nUse the f‚ÄùXXX‚Äù syntax to produce the following print out ‚ÄúHello Andreas and Ramon!‚Äù based on the given varibles.\n\nvar1 = \"and\"\nvar2 = \"Andreas\"\nvar3 = \"!\"\nvar4 = \"Hello\"\nvar5 = \"Ramon\"\n\nprint(f\"{var4} {var2} {var1} {var5}{var3}\")\n\nHello Andreas and Ramon!"
  },
  {
    "objectID": "hs25/pds/pds_exercises.html#exercise-02-1",
    "href": "hs25/pds/pds_exercises.html#exercise-02-1",
    "title": "Python for Data Science - Exercises",
    "section": "Exercise 02",
    "text": "Exercise 02\nUse the ‚ÄúXXX‚Äù.format() syntax to produce the following print out: ‚ÄúMy name is Giacomo, I am 10 years old, and I live in Padova.‚Äù based on the given dictionary. In the formatting call use: 1 order based 2 numbering based 3 key word based 4 dictionary key based versions to insert the variables.\n\ninsert_dict = {'name': 'Giacomo', 'age': 10, 'city': 'Padova'}\n\n# Order based\nprint(\"My name is {}, I am {} years old, and I live in {}.\".format(\n    insert_dict['name'], insert_dict['age'], insert_dict['city']\n))\n\n# Numbering based\nprint(\"My name is {0}, I am {1} years old, and I live in {2}.\".format(\n    insert_dict['name'], insert_dict['age'], insert_dict['city']\n))\n\n# Key word based\nprint(\"My name is {n}, I am {a} years old, and I live in {c}.\".format(\n    n=insert_dict['name'], a=insert_dict['age'], c=insert_dict['city']\n))\n\n# Dictionary key based\nprint(\"My name is {name}, I am {age} years old, and I live in {city}.\".format(\n    **insert_dict\n))\n\nMy name is Giacomo, I am 10 years old, and I live in Padova.\nMy name is Giacomo, I am 10 years old, and I live in Padova.\nMy name is Giacomo, I am 10 years old, and I live in Padova.\nMy name is Giacomo, I am 10 years old, and I live in Padova."
  },
  {
    "objectID": "hs25/pds/pds_exercises.html#exercise-03",
    "href": "hs25/pds/pds_exercises.html#exercise-03",
    "title": "Python for Data Science - Exercises",
    "section": "Exercise 03",
    "text": "Exercise 03\nYou are given list of n (even) numbers. Write a program that prints for each pair [(first, last), (second, second last ), etc‚Ä¶] X and Y the following string: X times Y is: X*Y. Use in place calculations to calculate the product directly in the string within the print statement.\n\nnums = [1, 2, 3, 4, 5, 6]\n\nfor i in range(len(nums)):\n    print(f\"{nums[i] * nums[len(nums) - 1 - i]}\")\n\n6\n10\n12\n12\n10\n6"
  },
  {
    "objectID": "hs25/pds/pds_exercises.html#part-a",
    "href": "hs25/pds/pds_exercises.html#part-a",
    "title": "Python for Data Science - Exercises",
    "section": "Part a",
    "text": "Part a\nFor each animal, print ‚ÄúHi, I‚Äôm a {animal_type} and my name is {name}!‚Äù Solve the exercise by writing a class ‚ÄòAnimal‚Äô and adding a method allowing to print the requested string. Note that it is not necessary for this task, to differentiate between animal types!\n\nprint(\"Part a): \\n\\n\")\n\nclass Animal:\n\n    def __init__(self, animal_type, name, age, weight, legs):\n        self.animal_type = animal_type\n        self.name = name\n        self.age = age\n        self.weight = weight\n        self.legs = legs\n\n    def __str__(self):\n        return(f\"Hi, I'm a {self.animal_type} and my name is {self.name}!\")\n\nwith open('data/animals.csv') as f:\n    for line in f.readlines()[1:]:\n        animal_type = line.split(\", \")[0]\n        name = line.split(\", \")[1]\n        age = int(line.split(\", \")[2])\n        weight = int(line.split(\", \")[3])\n        legs = int(line.split(\", \")[4])\n        #create objects\n        obj = Animal(animal_type, name, age, weight, legs)\n        print(obj)\n\nPart a): \n\n\nHi, I'm a dog and my name is bello!\nHi, I'm a snake and my name is masha!\nHi, I'm a dog and my name is wuffi!\nHi, I'm a cat and my name is leslie!\nHi, I'm a cat and my name is dummy!\nHi, I'm a cat and my name is puffy!\nHi, I'm a snake and my name is snizzy!\nHi, I'm a snake and my name is sazzles!\nHi, I'm a dog and my name is buddy!\nHi, I'm a cat and my name is wooly!\nHi, I'm a cat and my name is beast!"
  },
  {
    "objectID": "hs25/pds/pds_exercises.html#part-b",
    "href": "hs25/pds/pds_exercises.html#part-b",
    "title": "Python for Data Science - Exercises",
    "section": "Part b",
    "text": "Part b\nNow we are interested in the various sounds the animal types make. Write a separate class for each animal type. Provide a method ‚Äúspeak‚Äù, which depending on the animal type prints different sounds.\n\nprint(\"\\n\\nPart b): \\n\\n\")\n\nclass Dog():\n\n    def __init__(self, name, age, weight, legs):\n        self.name = name\n        self.age = age\n        self.weight = weight\n        self.legs = legs\n\n    def speak(self):\n        return \"Whuff whuff!\"\n\nclass Cat():\n\n    def __init__(self, name, age, weight, legs):\n        self.name = name\n        self.age = age\n        self.weight = weight\n        self.legs = legs\n\n    def speak(self):\n        return \"Mew mew!\"\n\nclass Snake():\n\n    def __init__(self, name, age, weight, legs):\n        self.name = name\n        self.age = age\n        self.weight = weight\n        self.legs = legs\n\n    def speak(self):\n        return \"Sssssss!\"\n\n\n# solution with file loop\nobj_list = []\nwith open('data/animals.csv') as f:\n    for line in f.readlines()[1:]:\n        animal_type = line.split(\", \")[0]\n        name = line.split(\", \")[1]\n        age = int(line.split(\", \")[2])\n        weight = int(line.split(\", \")[3])\n        legs = int(line.split(\", \")[4])\n        #create objects\n        if animal_type == 'dog':\n            obj = Dog(name, age, weight, legs)\n            obj_list.append(obj)\n        if animal_type == 'cat':\n            obj = Cat(name, age, weight, legs)\n            obj_list.append(obj)\n        if animal_type == 'snake':\n            obj = Snake(name, age, weight, legs)\n            obj_list.append(obj)\n\nfor elem in obj_list:\n    print(elem.speak())\n\n\n\nPart b): \n\n\nWhuff whuff!\nSssssss!\nWhuff whuff!\nMew mew!\nMew mew!\nMew mew!\nSssssss!\nSssssss!\nWhuff whuff!\nMew mew!\nMew mew!"
  },
  {
    "objectID": "hs25/pds/pds_exercises.html#part-a-1",
    "href": "hs25/pds/pds_exercises.html#part-a-1",
    "title": "Python for Data Science - Exercises",
    "section": "Part a",
    "text": "Part a\nProduce a class structure where Dog, Cat and Snake are implemented as child classes of a base class Animal. Create the object variables in the base class, along with a method ‚Äòprint_basic_information‚Äô, which prints ‚Äòtype‚Äô and ‚Äòname‚Äô to the console. In each child class, use the base class constructor with ‚Äòsuper‚Äô and add an additional method ‚Äòspeak‚Äô, specific to that child class. In each child class, add an additional method where you return the sum of the object variables ‚Äòage‚Äô and ‚Äòlegs‚Äô.\nFor each element in the animals.csv, create an object of the corresponding subclass, let it print basic information (method from ‚ÄòAnimal‚Äô), let it speak (method from child class) and get the sum of ‚Äòage‚Äô and ‚Äòlegs‚Äô as a return value.\n\nclass Animal:\n    def __init__(self, animal_type: str, name: str, age: int, weight: int, legs: int):\n        self.animal_type = animal_type\n        self.name = name\n        self.age = age\n        self.weight = weight\n        self.legs = legs\n\n    def print_basic_information(self):\n        print(f\"Type = {self.animal_type} and name = {self.name}\")\n\nclass Dog(Animal):\n\n    def __init__(self, animal_type: str, name: str, age: int, weight: int, legs: int):\n        super().__init__(animal_type, name, age, weight, legs)\n\n    def speak(self):\n        return \"Wuff\"\n\n    def sum_of_age_and_legs(self):\n        return sum([self.age, self.legs])\n\nclass Cat(Animal):\n\n    def __init__(self, animal_type: str, name: str, age: int, weight: int, legs: int):\n        super().__init__(animal_type, name, age, weight, legs)\n\n    def speak(self):\n        return \"Meww\"\n\n    def sum_of_age_and_legs(self):\n        return sum([self.age, self.legs])\n\nclass Snake(Animal):\n\n    def __init__(self, animal_type: str, name: str, age: int, weight: int, legs: int):\n        super().__init__(animal_type, name, age, weight, legs)\n\n    def speak(self):\n        return \"Ssss\"\n\n    def sum_of_age_and_legs(self):\n        return sum([self.age, self.legs])\n\nobj_list = []\nwith open('./data/animals.csv') as f:\n    for line in f.readlines()[1:]:\n        animal_type = line.split(\", \")[0]\n        name = line.split(\", \")[1]\n        age = int(line.split(\", \")[2])\n        weight = int(line.split(\", \")[3])\n        legs = int(line.split(\", \")[4])\n        # create objects based on animal_type\n        if animal_type == \"dog\":\n            obj = Dog(animal_type=animal_type, name=name, age=age, weight=weight, legs=legs)\n        elif animal_type == \"cat\":\n            obj = Cat(animal_type=animal_type, name=name, age=age, weight=weight, legs=legs)\n        else:\n            obj = Snake(animal_type=animal_type, name=name, age=age, weight=weight, legs=legs)\n        # add objects to obj_list\n        obj_list.append(obj)\n\nfor elem in obj_list:\n    print(\"--\\n\")\n    elem.print_basic_information()\n    elem.speak()\n    c_sum = elem.sum_of_age_and_legs()\n    print(c_sum)\n\n--\n\nType = dog and name = bello\n14\n--\n\nType = snake and name = masha\n12\n--\n\nType = dog and name = wuffi\n12\n--\n\nType = cat and name = leslie\n9\n--\n\nType = cat and name = dummy\n9\n--\n\nType = cat and name = puffy\n9\n--\n\nType = snake and name = snizzy\n5\n--\n\nType = snake and name = sazzles\n2\n--\n\nType = dog and name = buddy\n6\n--\n\nType = cat and name = wooly\n9\n--\n\nType = cat and name = beast\n9"
  },
  {
    "objectID": "hs25/pds/pds_exercises.html#part-b-1",
    "href": "hs25/pds/pds_exercises.html#part-b-1",
    "title": "Python for Data Science - Exercises",
    "section": "Part b",
    "text": "Part b\n\nclass Animal:\n    def __init__(self, animal_type: str, name: str, age: int, weight: int, legs: int, sound: str):\n        self.animal_type = animal_type\n        self.name = name\n        self.age = age\n        self.weight = weight\n        self.legs = legs\n        self.sound = sound\n\n    def print_basic_information(self):\n        print(f\"Type = {self.animal_type} and name = {self.name}\")\n    \n    def sum_of_age_and_legs(self):\n        return sum([self.age, self.legs])\n\n    def speak(self):\n        print(self.sound)\n\nclass Dog(Animal):\n\n    def __init__(self, animal_type: str, name: str, age: int, weight: int, legs: int, sound: str):\n        super().__init__(animal_type, name, age, weight, legs, sound)\n\nclass Cat(Animal):\n\n    def __init__(self, animal_type: str, name: str, age: int, weight: int, legs: int, sound: str):\n        super().__init__(animal_type, name, age, weight, legs, sound)\n\nclass Snake(Animal):\n\n    def __init__(self, animal_type: str, name: str, age: int, weight: int, legs: int, sound: str):\n        super().__init__(animal_type, name, age, weight, legs, sound)\n\nobj_list = []\nwith open('./data/animals.csv') as f:\n    for line in f.readlines()[1:]:\n        animal_type = line.split(\", \")[0]\n        name = line.split(\", \")[1]\n        age = int(line.split(\", \")[2])\n        weight = int(line.split(\", \")[3])\n        legs = int(line.split(\", \")[4])\n        # create objects based on animal_type\n        if animal_type == \"dog\":\n            obj = Dog(animal_type=animal_type, name=name, age=age, weight=weight, legs=legs, sound= \"Wuff\")\n        elif animal_type == \"cat\":\n            obj = Cat(animal_type=animal_type, name=name, age=age, weight=weight, legs=legs, sound=\"Meww\")\n        else:\n            obj = Snake(animal_type=animal_type, name=name, age=age, weight=weight, legs=legs, sound=\"Ssss\")\n        # add objects to obj_list\n        obj_list.append(obj)\n\nfor elem in obj_list:\n    print(\"--\\n\")\n    elem.print_basic_information()\n    elem.speak()\n    c_sum = elem.sum_of_age_and_legs()\n    print(c_sum)\n\n--\n\nType = dog and name = bello\nWuff\n14\n--\n\nType = snake and name = masha\nSsss\n12\n--\n\nType = dog and name = wuffi\nWuff\n12\n--\n\nType = cat and name = leslie\nMeww\n9\n--\n\nType = cat and name = dummy\nMeww\n9\n--\n\nType = cat and name = puffy\nMeww\n9\n--\n\nType = snake and name = snizzy\nSsss\n5\n--\n\nType = snake and name = sazzles\nSsss\n2\n--\n\nType = dog and name = buddy\nWuff\n6\n--\n\nType = cat and name = wooly\nMeww\n9\n--\n\nType = cat and name = beast\nMeww\n9"
  },
  {
    "objectID": "hs25/pds/pds_exercises.html#part-c",
    "href": "hs25/pds/pds_exercises.html#part-c",
    "title": "Python for Data Science - Exercises",
    "section": "Part c",
    "text": "Part c\n\nclass Animal:\n    def __init__(self, animal_type: str, name: str, age: int, weight: int, legs: int, sound: str):\n        self.animal_type = animal_type\n        self.name = name\n        self.age = age\n        self.weight = weight\n        self.legs = legs\n        self.sound = sound\n\n    def print_basic_information(self):\n        print(f\"Type = {self.animal_type} and name = {self.name}\")\n    \n    def sum_of_age_and_legs(self):\n        return sum([self.age, self.legs])\n\n    def speak(self):\n        print(self.sound)\n\nclass Dog(Animal):\n\n    def __init__(self, animal_type: str, name: str, age: int, weight: int, legs: int, sound: str):\n        super().__init__(animal_type, name, age, weight, legs, sound)\n\n    def print_basic_information(self):\n        print(self.__class__.__name__)\n\nclass Cat(Animal):\n\n    def __init__(self, animal_type: str, name: str, age: int, weight: int, legs: int, sound: str):\n        super().__init__(animal_type, name, age, weight, legs, sound)\n\nclass Snake(Animal):\n\n    def __init__(self, animal_type: str, name: str, age: int, weight: int, legs: int, sound: str):\n        super().__init__(animal_type, name, age, weight, legs, sound)\n\nobj_list = []\nwith open('./data/animals.csv') as f:\n    for line in f.readlines()[1:]:\n        animal_type = line.split(\", \")[0]\n        name = line.split(\", \")[1]\n        age = int(line.split(\", \")[2])\n        weight = int(line.split(\", \")[3])\n        legs = int(line.split(\", \")[4])\n        # create objects based on animal_type\n        if animal_type == \"dog\":\n            obj = Dog(animal_type=animal_type, name=name, age=age, weight=weight, legs=legs, sound= \"Wuff\")\n        elif animal_type == \"cat\":\n            obj = Cat(animal_type=animal_type, name=name, age=age, weight=weight, legs=legs, sound=\"Meww\")\n        else:\n            obj = Snake(animal_type=animal_type, name=name, age=age, weight=weight, legs=legs, sound=\"Ssss\")\n        # add objects to obj_list\n        obj_list.append(obj)\n\nfor elem in obj_list:\n    print(\"--\\n\")\n    elem.print_basic_information()\n    elem.speak()\n    c_sum = elem.sum_of_age_and_legs()\n    print(c_sum)\n\n--\n\nDog\nWuff\n14\n--\n\nType = snake and name = masha\nSsss\n12\n--\n\nDog\nWuff\n12\n--\n\nType = cat and name = leslie\nMeww\n9\n--\n\nType = cat and name = dummy\nMeww\n9\n--\n\nType = cat and name = puffy\nMeww\n9\n--\n\nType = snake and name = snizzy\nSsss\n5\n--\n\nType = snake and name = sazzles\nSsss\n2\n--\n\nDog\nWuff\n6\n--\n\nType = cat and name = wooly\nMeww\n9\n--\n\nType = cat and name = beast\nMeww\n9"
  },
  {
    "objectID": "hs25/pds/pds_exercises.html#import",
    "href": "hs25/pds/pds_exercises.html#import",
    "title": "Python for Data Science - Exercises",
    "section": "2. Import",
    "text": "2. Import\npip install numpy pandas matplotlib\n\n# Use of convention aliases\nimport numpy as np\nimport pandas as pd\n\n# df means Data Frame\ndf = pd.read_csv('/home/nils/dev/mscids-notes/hs25/pds/data/airquality.csv')\n\n# Preview\ndf.head(n=10)\n\n\n\n\n\n\n\n\nrownames\nOzone\nSolar.R\nWind\nTemp\nMonth\nDay\n\n\n\n\n0\n1.0\n41.0\n190.0\n7.4\n67.0\n5.0\n1.0\n\n\n1\n2.0\n36.0\n118.0\n8.0\n72.0\n5.0\n2.0\n\n\n2\n3.0\n12.0\n149.0\n12.6\n74.0\n5.0\n3.0\n\n\n3\n4.0\n18.0\n313.0\n11.5\n62.0\n5.0\n4.0\n\n\n4\n5.0\nNaN\nNaN\n14.3\n56.0\n5.0\n5.0\n\n\n5\n6.0\n28.0\nNaN\n14.9\n66.0\n5.0\n6.0\n\n\n6\n7.0\n23.0\n299.0\n8.6\n65.0\n5.0\n7.0\n\n\n7\n8.0\n19.0\n99.0\n13.8\n59.0\n5.0\n8.0\n\n\n8\n9.0\n8.0\n19.0\n20.1\n61.0\n5.0\n9.0\n\n\n9\n10.0\nNaN\n194.0\n8.6\n69.0\n5.0\n10.0"
  },
  {
    "objectID": "hs25/pds/pds_exercises.html#stats",
    "href": "hs25/pds/pds_exercises.html#stats",
    "title": "Python for Data Science - Exercises",
    "section": "3. Stats",
    "text": "3. Stats\n\n# Select column \"Temp\" from df\ndf['Temp'].describe()\n\ncount    153.000000\nmean      76.124183\nstd       25.227992\nmin     -212.000000\n25%       72.000000\n50%       79.000000\n75%       85.000000\nmax       97.000000\nName: Temp, dtype: float64"
  },
  {
    "objectID": "hs25/pds/pds_exercises.html#outlier",
    "href": "hs25/pds/pds_exercises.html#outlier",
    "title": "Python for Data Science - Exercises",
    "section": "4. Outlier",
    "text": "4. Outlier\n\n# Get overview\ndf['Temp'].hist() # -200 is a outlier\n\nvalid_mean = df[df['Temp'] &gt;= 0]['Temp'].mean() # Mean without outlier\nold_temp_mean = np.mean(df['Temp'])\n\n# Correction\ndf['Temp'] = np.where( (df['Temp'] &lt; 0 ), valid_mean, df['Temp'])\n\nnew_temp_mean = np.mean(df['Temp'])\n\nprint(f'Old mean {old_temp_mean} vs. new mean {new_temp_mean}')\n\nOld mean 76.12418300653594 vs. new mean 78.01973684210526"
  },
  {
    "objectID": "hs25/pds/pds_exercises.html#plotting",
    "href": "hs25/pds/pds_exercises.html#plotting",
    "title": "Python for Data Science - Exercises",
    "section": "5. Plotting",
    "text": "5. Plotting\n\nfrom matplotlib import pyplot as plt\n\nfig, ax = plt.subplots() # Main construction\n\nax.hist(df['Temp'], bins=20) # Main Plot\n\nax.set_title(\"Temperature Distribution\")\nax.set_xlabel(\"Temp [*F]\")\nax.set_ylabel(\"Value Count\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\nNote: Since we corrected the outlier, the plot looks pretty good."
  },
  {
    "objectID": "hs25/pds/pds_exercises.html#define-temp-converter",
    "href": "hs25/pds/pds_exercises.html#define-temp-converter",
    "title": "Python for Data Science - Exercises",
    "section": "6. Define Temp Converter",
    "text": "6. Define Temp Converter\n\ndef fahrenheit_to_celsius(temp: int) -&gt; int:\n    \"\"\" Converts Fahrenheit to Celsius \"\"\"\n    result = np.round((temp-32)*5/9, 1)\n    return result"
  },
  {
    "objectID": "hs25/pds/pds_exercises.html#fahrenheit-to-cerlsius",
    "href": "hs25/pds/pds_exercises.html#fahrenheit-to-cerlsius",
    "title": "Python for Data Science - Exercises",
    "section": "7. Fahrenheit to Cerlsius",
    "text": "7. Fahrenheit to Cerlsius\n\n# We can directly define a new column\ndf['Temp_C'] = df['Temp'].map(fahrenheit_to_celsius)\ndf.head(n=10)\n\n\n\n\n\n\n\n\nrownames\nOzone\nSolar.R\nWind\nTemp\nMonth\nDay\nTemp_C\n\n\n\n\n0\n1.0\n41.0\n190.0\n7.4\n67.0\n5.0\n1.0\n19.4\n\n\n1\n2.0\n36.0\n118.0\n8.0\n72.0\n5.0\n2.0\n22.2\n\n\n2\n3.0\n12.0\n149.0\n12.6\n74.0\n5.0\n3.0\n23.3\n\n\n3\n4.0\n18.0\n313.0\n11.5\n62.0\n5.0\n4.0\n16.7\n\n\n4\n5.0\nNaN\nNaN\n14.3\n56.0\n5.0\n5.0\n13.3\n\n\n5\n6.0\n28.0\nNaN\n14.9\n66.0\n5.0\n6.0\n18.9\n\n\n6\n7.0\n23.0\n299.0\n8.6\n65.0\n5.0\n7.0\n18.3\n\n\n7\n8.0\n19.0\n99.0\n13.8\n59.0\n5.0\n8.0\n15.0\n\n\n8\n9.0\n8.0\n19.0\n20.1\n61.0\n5.0\n9.0\n16.1\n\n\n9\n10.0\nNaN\n194.0\n8.6\n69.0\n5.0\n10.0\n20.6"
  },
  {
    "objectID": "hs25/pds/pds_exercises.html#double-plot",
    "href": "hs25/pds/pds_exercises.html#double-plot",
    "title": "Python for Data Science - Exercises",
    "section": "8. Double-Plot",
    "text": "8. Double-Plot\n\nfig, ax = plt.subplots(ncols=2) # Define two cols\n\n# First plot (ax[0])\nax[0].hist(df['Temp'], bins=20)\nax[0].set_title(\"Temperature Distribution F\")\nax[0].set_xlabel(\"Temp [*F]\")\nax[0].set_ylabel(\"Value Count\")\n\n# Second plot (ax[1])\nax[1].hist(df['Temp_C'], bins=20)\nax[1].set_title(\"Temperature Distribution C\")\nax[1].set_xlabel(\"Temp [*C]\")\nax[1].set_ylabel(\"Value Count\")\n\nplt.show()"
  },
  {
    "objectID": "hs25/pds/pds_exercises.html#class-airqualityreport",
    "href": "hs25/pds/pds_exercises.html#class-airqualityreport",
    "title": "Python for Data Science - Exercises",
    "section": "9. & 10. Class ‚ÄúAirQualityReport‚Äù",
    "text": "9. & 10. Class ‚ÄúAirQualityReport‚Äù\n\nclass AirQualityReport:\n    def __init__(self, df: pd.DataFrame):\n        for col_name, data in df.items():\n            if pd.api.types.is_numeric_dtype(data):\n                mean_value = data.mean()\n                setattr(self, f\"_{col_name}\", mean_value)\n\n    def calculate_max_value(self):\n        max_so_far = -float('inf')\n        max_column_name = None\n\n        for attr_name, attr_value in self.__dict__.items():\n            if attr_name.startswith('_') and isinstance(attr_value, (int, float)):\n                if attr_value &gt; max_so_far:\n                    max_so_far = attr_value\n                    max_column_name = attr_name[1:] \n\n        return {\n            \"column_name\": max_column_name,\n            \"max_value\": max_so_far\n        }\n\nreport = AirQualityReport(df)\nprint(report.__dict__)\n\n{'_rownames': np.float64(77.0), '_Ozone': np.float64(42.12931034482759), '_Solar.R': np.float64(185.93150684931507), '_Wind': np.float64(9.957516339869281), '_Temp': np.float64(78.01973684210526), '_Month': np.float64(6.993464052287582), '_Day': np.float64(15.803921568627452), '_Temp_C': np.float64(25.5640522875817)}"
  },
  {
    "objectID": "hs25/pds/pds_exercises.html#task-1.",
    "href": "hs25/pds/pds_exercises.html#task-1.",
    "title": "Python for Data Science - Exercises",
    "section": "Task 1.",
    "text": "Task 1.\n\nnums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n\n# Task 1: copy all even elements from 'nums' into a new list.\nprint(\"\\n---- Task 1 ----\")\nmy_list = []\nfor n in nums:\n    if not n%2:\n        my_list.append(n)\nprint(f\"for loop: {my_list=}\")\n\n# solution with list comprehension:\nmy_list = [num for num in nums if num % 2 == 0]\nprint(f\"comprehension: {my_list=}\")\n\n\n---- Task 1 ----\nfor loop: my_list=[2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\ncomprehension: my_list=[2, 4, 6, 8, 10, 12, 14, 16, 18, 20]"
  },
  {
    "objectID": "hs25/pds/pds_exercises.html#task-2.",
    "href": "hs25/pds/pds_exercises.html#task-2.",
    "title": "Python for Data Science - Exercises",
    "section": "Task 2.",
    "text": "Task 2.\n\n# Task 2: calculate the square of each element in the list 'nums'.\nnums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n\nprint(\"\\n---- Task 2 ----\")\nmy_list = []\nfor n in nums:\n  my_list.append(n*n)\nprint(f\"for loop: {my_list=}\")\n\n# solution with list comprehension:\nmy_list = [num*num for num in nums]\nprint(f\"comprehension: {my_list=}\")\n\n\n---- Task 2 ----\nfor loop: my_list=[1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225, 256, 289, 324, 361, 400]\ncomprehension: my_list=[1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225, 256, 289, 324, 361, 400]"
  },
  {
    "objectID": "hs25/pds/pds_exercises.html#task-3.",
    "href": "hs25/pds/pds_exercises.html#task-3.",
    "title": "Python for Data Science - Exercises",
    "section": "Task 3.",
    "text": "Task 3.\n\n# Task 3: calculate the square of each element in the list 'nums' by applying\n# a lambda function on the list (using map function).\nnums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n\nprint(\"\\n---- Task 3 ----\")\nmy_list = []\nfor n in nums:\n  my_list.append(n*n)\nprint(f\"for loop: {my_list=}\")\n\n# solution with list comprehension:\nmy_list = list(map(lambda x: x*x, nums))\nprint(f\"lambda: {my_list=}\")\n\n\n---- Task 3 ----\nfor loop: my_list=[1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225, 256, 289, 324, 361, 400]\nlambda: my_list=[1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225, 256, 289, 324, 361, 400]"
  },
  {
    "objectID": "hs25/pds/pds_exercises.html#task-4.",
    "href": "hs25/pds/pds_exercises.html#task-4.",
    "title": "Python for Data Science - Exercises",
    "section": "Task 4.",
    "text": "Task 4.\n\n# Task 4: create nested lists comprising all lower prime numbers up to the \n# given number in 'nums'.\nnums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\nprimes = [1, 2, 3, 5, 7, 11, 13, 17, 19, 23]\n\nprint(\"\\n---- Task 4 ----\")\nmy_list = []\nfor n in nums:\n  p_list = []\n  for p in primes:\n    if p &lt;= n:\n      p_list.append(p)\n  my_list.append(p_list)\nprint(f\"for loop: {my_list=}\")\n\n# solution with list comprehension:\nmy_list = [[p for p in primes if p &lt;= n] for n in nums]\nprint(f\"comprehension: {my_list=}\")\n\n\n---- Task 4 ----\nfor loop: my_list=[[1], [1, 2], [1, 2, 3], [1, 2, 3], [1, 2, 3, 5], [1, 2, 3, 5], [1, 2, 3, 5, 7], [1, 2, 3, 5, 7], [1, 2, 3, 5, 7], [1, 2, 3, 5, 7], [1, 2, 3, 5, 7, 11], [1, 2, 3, 5, 7, 11], [1, 2, 3, 5, 7, 11, 13], [1, 2, 3, 5, 7, 11, 13], [1, 2, 3, 5, 7, 11, 13], [1, 2, 3, 5, 7, 11, 13], [1, 2, 3, 5, 7, 11, 13, 17], [1, 2, 3, 5, 7, 11, 13, 17], [1, 2, 3, 5, 7, 11, 13, 17, 19], [1, 2, 3, 5, 7, 11, 13, 17, 19]]\ncomprehension: my_list=[[1], [1, 2], [1, 2, 3], [1, 2, 3], [1, 2, 3, 5], [1, 2, 3, 5], [1, 2, 3, 5, 7], [1, 2, 3, 5, 7], [1, 2, 3, 5, 7], [1, 2, 3, 5, 7], [1, 2, 3, 5, 7, 11], [1, 2, 3, 5, 7, 11], [1, 2, 3, 5, 7, 11, 13], [1, 2, 3, 5, 7, 11, 13], [1, 2, 3, 5, 7, 11, 13], [1, 2, 3, 5, 7, 11, 13], [1, 2, 3, 5, 7, 11, 13, 17], [1, 2, 3, 5, 7, 11, 13, 17], [1, 2, 3, 5, 7, 11, 13, 17, 19], [1, 2, 3, 5, 7, 11, 13, 17, 19]]"
  },
  {
    "objectID": "hs25/pds/pds_exercises.html#task-1.-1",
    "href": "hs25/pds/pds_exercises.html#task-1.-1",
    "title": "Python for Data Science - Exercises",
    "section": "Task 1.",
    "text": "Task 1.\n\n# The variable 'chars' provides a list of all possible lower case characters.\n# And the method count of a str object counts the number of occurrence for a \n# particular object.\n\nimport string\nchars = string.ascii_lowercase\n\nlorem = \"\"\"Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed\ndiam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat,\nsed diam voluptua. At vero eos et accusam et justo duo dolores et ea\nrebum. Stet clita gubergren, no sea takimata sanctus est Lorem ipsum dolor\nsit amet.\"\"\"\n\n# Task 1: use the map function to apply a lambda function for counting all\n# characters in the text.\ncount1 = {}\ncount1 = dict(map(lambda char: (char, lorem.count(char)), chars))\n\nprint(count1)\nprint(count1[\"e\"])\n\n{'a': 21, 'b': 3, 'c': 6, 'd': 12, 'e': 28, 'f': 0, 'g': 4, 'h': 0, 'i': 15, 'j': 1, 'k': 1, 'l': 9, 'm': 16, 'n': 10, 'o': 21, 'p': 5, 'q': 1, 'r': 16, 's': 17, 't': 25, 'u': 15, 'v': 3, 'w': 0, 'x': 0, 'y': 2, 'z': 0}\n28"
  },
  {
    "objectID": "hs25/pds/pds_exercises.html#task-2.-1",
    "href": "hs25/pds/pds_exercises.html#task-2.-1",
    "title": "Python for Data Science - Exercises",
    "section": "Task 2.",
    "text": "Task 2.\n\n# Task 2: solve the same problem by means of a dictionary comprehension.\ncount2 = {}\ncount2 = {char: lorem.count(char) for char in chars}\n\nprint(count2)\nprint(count2[\"e\"])\n\n{'a': 21, 'b': 3, 'c': 6, 'd': 12, 'e': 28, 'f': 0, 'g': 4, 'h': 0, 'i': 15, 'j': 1, 'k': 1, 'l': 9, 'm': 16, 'n': 10, 'o': 21, 'p': 5, 'q': 1, 'r': 16, 's': 17, 't': 25, 'u': 15, 'v': 3, 'w': 0, 'x': 0, 'y': 2, 'z': 0}\n28"
  },
  {
    "objectID": "hs25/pds/pds_mock_exam.html",
    "href": "hs25/pds/pds_mock_exam.html",
    "title": "Python for Data Science - Mock Exam",
    "section": "",
    "text": "The following script is given:\nvar1 = (42, 0.34)\nvar2 = 0.34\nvar3 = {elem:1 for elem in var1}\nvar4 = set(list(range(3)))\n\nWhat data type is var1: tuple\nWhat data type is var2: float\nWhat data type is var3: dict\nWhat data type is var4: set\n\n\n\n\nvar1 = (42, 0.34)\nprint(type(var1))\n\nvar2 = 0.34\nprint(type(var2))\n\nvar3 = {elem:1 for elem in var1}\nprint(type(var3))\n\nvar4 = set(list(range(3)))\nprint(type(var4))\n\n&lt;class 'tuple'&gt;\n&lt;class 'float'&gt;\n&lt;class 'dict'&gt;\n&lt;class 'set'&gt;\n\n\n\n\n\n\nWhat does the script below print to the console?\na = 14\nb = \"this variable\"\nc = \"formatting\"\nmylist = [a,b,c]\nmystring = \"Hello, {} used {} syntax '.format'.\" .format(mylist[1], mylist[2])\nprint(mystring)\nOutput:\nHello, this variable used formatting syntax '.format'.\n\n\n\na = 14\nb = \"this variable\"\nc = \"formatting\"\nmylist = [a,b,c]\nmystring = \"Hello, {} used {} syntax '.format'.\" .format(mylist[1], mylist[2])\nprint(mystring)\n\nHello, this variable used formatting syntax '.format'.\n\n\n\n\n\n\nGiven the following script:\na = \"a\"\nmystring = \"I'm just {} normal sentence {}\".format(__FILL_ONE__, __FILL_TWO__)\nprint(mystring)\nPlease provide suitable replacements for __FILL_ONE__ and __FILL_TWO__ such that the script prints: I‚Äôm just a normal sentence !\n\n__FILL_ONE__: a\n__FILL_TWO__: ‚Äú!‚Äù\n\n\n\n\na = \"a\"\nmystring = \"I'm just {} normal sentence {}\".format(a, \"!\")\nprint(mystring)\n\nI'm just a normal sentence !\n\n\n\n\n\n\n\n\n\nWhat does the script below print to the console?\na = 2\nb = 5\n\ndef mathematical_fun(a, b):\n    return a+b\n\nprint(a, mathematical_fun(a, b))\nOutput:\n2 7\n\n\n\na = 2\nb = 5\n\ndef mathematical_fun(a, b):\n    return a+b\n\nprint(a, mathematical_fun(a, b))\n\n2 7\n\n\n\n\n\n\nWhat does the script below print to the console?\na = 3\n\ndef mathematical_fun(a, b=2):\n    return a+b\n\nresult = mathematical_fun(a)\nprint(result)\nOutput:\n5\n\n\n\na = 3\n\ndef mathematical_fun(a, b=2):\n    return a+b\n\nresult = mathematical_fun(a)\nprint(result)\n\n5\n\n\n\n\n\n\nWhat does the script below print to the console?\nvar = 2\n\ndef change_value(var):\n    print(var)\n    var = 3\n    return var\n\nprint(var)\nOutput:\n2\n\n\n\nvar = 2\n\ndef change_value(var):\n    print(var)\n    var = 3\n    return var\n\nprint(var)\n\n2\n\n\n\n\n\n\nWhat does the script below print to the console?\nMODULE_VAR = 2\n\ndef module_function(a):\n    global MODULE_VAR\n    print(MODULE_VAR)\n    MODULE_VAR = a\n\nmodule_function(3)\nprint(MODULE_VAR)\nOutput:\n2\n3\n\n\n\nMODULE_VAR = 2\n\ndef module_function(a):\n    global MODULE_VAR\n    print(MODULE_VAR)\n    MODULE_VAR = a\n\nmodule_function(3)\nprint(MODULE_VAR)\n\n2\n3\n\n\n\n\n\n\n\n\n\nWhat does the script below print to the console?\nfor elem in range(2):\n    print(elem)\nOutput:\n0\n1\n\n\n\nfor elem in range(2):\n    print(elem)\n\n0\n1\n\n\n\n\n\n\nWhat does the script below print to the console?\nmylist = [1,2,3]\nfor ind, elem in enumerate(mylist):\n    print(ind)\nprint(elem)\nOutput:\n0\n1\n2\n3\n\n\n\nmylist = [1,2,3]\nfor ind, elem in enumerate(mylist):\n    print(ind)\nprint(elem)\n\n0\n1\n2\n3\n\n\n\n\n\n\nWhat does the script below print to the console?\na = 21\nb = 2\nif len(\"155kl\") &gt; 4:\n    while a &lt; 24:\n        print(a)\n        if b &lt;= 2:\n            break\n        a += 1\nelse:\n    while a &lt; 23:\n        print(a + 1)\n        if b &lt;= 2:\n            break\n        a += 1\nOutput:\n21\n\n\n\na = 21\nb = 2\nif len(\"155kl\") &gt; 4:\n    while a &lt; 24:\n        print(a)\n        if b &lt;= 2:\n            break\n        a += 1\nelse:\n    while a &lt; 23:\n        print(a + 1)\n        if b &lt;= 2:\n            break\n        a += 1\n\n21\n\n\n\n\n\n\n\n\n\nWhat does the script below print to the console?\nclass MyClass ():\n    number = 3\n\n    def __init__(self, number):\n        self.number = number\n\nobj = MyClass(4)\nprint(MyClass.number)\nOutput:\n3\n\n\n\nclass MyClass ():\n    number = 3\n\n    def __init__(self, number):\n        self.number = number\n\nobj = MyClass(4)\nprint(MyClass.number)\n\n3\n\n\n\n\n\n\nWhat does the script below print to the console?\nclass MyNumber():\n    def __init__(self, number):\n        self.number = number\n\n    def my_method(self):\n        self.number = self.number + 1\n        return self.number\n\ni = 0\nobj = MyNumber(i)\nwhile i &lt;= 3:\n    i = obj.my_method()\n    print(i)\nelse:\n    print(\"?\")\nOutput:\n1\n2\n3\n4\n?\n\n\n\nclass MyNumber():\n    def __init__(self, number):\n        self.number = number\n\n    def my_method(self):\n        self.number = self.number + 1\n        return self.number\n\ni = 0\nobj = MyNumber(i)\nwhile i &lt;= 3:\n    i = obj.my_method()\n    print(i)\nelse:\n    print(\"?\")\n\n1\n2\n3\n4\n?\n\n\n\n\n\n\nWhat does the script below print to the console?\nclass MyBaseClass():\n    def __init__(self, number):\n        self.number = number\n\n    def my_method(self):\n        self.number = self.number + 10\n        return self.number\n\nclass MyClass(MyBaseClass):\n    def __init__(self, number):\n        super().__init__(number)\n\n    def my_method(self):\n        self.number = self.number + 1\n        return self.number\n\nobj = MyClass(3)\nprint(obj.number)\nprint(obj.my_method())\nprint(obj.number)\nOutput:\n3\n4\n4\n\n\n\nclass MyBaseClass():\n    def __init__(self, number):\n        self.number = number\n\n    def my_method(self):\n        self.number = self.number + 10\n        return self.number\n\nclass MyClass(MyBaseClass):\n    def __init__(self, number):\n        super().__init__(number)\n\n    def my_method(self):\n        self.number = self.number + 1\n        return self.number\n\nobj = MyClass(3)\nprint(obj.number)\nprint(obj.my_method())\nprint(obj.number)\n\n3\n4\n4\n\n\n\n\n\n\n\n\n\nWhich of the following statements about Python dictionaries are correct?\n\nNote: At least one statement must be marked, otherwise you will get 0 points.\n\n\n[‚úì] You can modify the value associated with a key in a dictionary after it has been created.\n[o] Keys in a dictionary must be strings.\n[o] Values in a dictionary must be of the same data type.\n[o] A dictionary can contain duplicate keys.\n[‚úì] Dictionaries can form nested structures.\n\n\n\n\nWhich of the following statements about Python classes/objects are correct?\n\nNote: At least one statement must be marked, otherwise you will get 0 points.\n\n\n[‚úì] A class is a blueprint for creating objects.\n[‚úì] An object can have attributes and methods.\n[‚úì] A class can be instantiated multiple times to create different objects.\n[o] All objects in Python are instances of built-in classes only.\n[‚úì] Inheritance allows a class to inherit attributes and methods from another class."
  },
  {
    "objectID": "hs25/pds/pds_mock_exam.html#assignment-1-basics",
    "href": "hs25/pds/pds_mock_exam.html#assignment-1-basics",
    "title": "Python for Data Science - Mock Exam",
    "section": "",
    "text": "The following script is given:\nvar1 = (42, 0.34)\nvar2 = 0.34\nvar3 = {elem:1 for elem in var1}\nvar4 = set(list(range(3)))\n\nWhat data type is var1: tuple\nWhat data type is var2: float\nWhat data type is var3: dict\nWhat data type is var4: set\n\n\n\n\nvar1 = (42, 0.34)\nprint(type(var1))\n\nvar2 = 0.34\nprint(type(var2))\n\nvar3 = {elem:1 for elem in var1}\nprint(type(var3))\n\nvar4 = set(list(range(3)))\nprint(type(var4))\n\n&lt;class 'tuple'&gt;\n&lt;class 'float'&gt;\n&lt;class 'dict'&gt;\n&lt;class 'set'&gt;\n\n\n\n\n\n\nWhat does the script below print to the console?\na = 14\nb = \"this variable\"\nc = \"formatting\"\nmylist = [a,b,c]\nmystring = \"Hello, {} used {} syntax '.format'.\" .format(mylist[1], mylist[2])\nprint(mystring)\nOutput:\nHello, this variable used formatting syntax '.format'.\n\n\n\na = 14\nb = \"this variable\"\nc = \"formatting\"\nmylist = [a,b,c]\nmystring = \"Hello, {} used {} syntax '.format'.\" .format(mylist[1], mylist[2])\nprint(mystring)\n\nHello, this variable used formatting syntax '.format'.\n\n\n\n\n\n\nGiven the following script:\na = \"a\"\nmystring = \"I'm just {} normal sentence {}\".format(__FILL_ONE__, __FILL_TWO__)\nprint(mystring)\nPlease provide suitable replacements for __FILL_ONE__ and __FILL_TWO__ such that the script prints: I‚Äôm just a normal sentence !\n\n__FILL_ONE__: a\n__FILL_TWO__: ‚Äú!‚Äù\n\n\n\n\na = \"a\"\nmystring = \"I'm just {} normal sentence {}\".format(a, \"!\")\nprint(mystring)\n\nI'm just a normal sentence !"
  },
  {
    "objectID": "hs25/pds/pds_mock_exam.html#assignment-2-functions",
    "href": "hs25/pds/pds_mock_exam.html#assignment-2-functions",
    "title": "Python for Data Science - Mock Exam",
    "section": "",
    "text": "What does the script below print to the console?\na = 2\nb = 5\n\ndef mathematical_fun(a, b):\n    return a+b\n\nprint(a, mathematical_fun(a, b))\nOutput:\n2 7\n\n\n\na = 2\nb = 5\n\ndef mathematical_fun(a, b):\n    return a+b\n\nprint(a, mathematical_fun(a, b))\n\n2 7\n\n\n\n\n\n\nWhat does the script below print to the console?\na = 3\n\ndef mathematical_fun(a, b=2):\n    return a+b\n\nresult = mathematical_fun(a)\nprint(result)\nOutput:\n5\n\n\n\na = 3\n\ndef mathematical_fun(a, b=2):\n    return a+b\n\nresult = mathematical_fun(a)\nprint(result)\n\n5\n\n\n\n\n\n\nWhat does the script below print to the console?\nvar = 2\n\ndef change_value(var):\n    print(var)\n    var = 3\n    return var\n\nprint(var)\nOutput:\n2\n\n\n\nvar = 2\n\ndef change_value(var):\n    print(var)\n    var = 3\n    return var\n\nprint(var)\n\n2\n\n\n\n\n\n\nWhat does the script below print to the console?\nMODULE_VAR = 2\n\ndef module_function(a):\n    global MODULE_VAR\n    print(MODULE_VAR)\n    MODULE_VAR = a\n\nmodule_function(3)\nprint(MODULE_VAR)\nOutput:\n2\n3\n\n\n\nMODULE_VAR = 2\n\ndef module_function(a):\n    global MODULE_VAR\n    print(MODULE_VAR)\n    MODULE_VAR = a\n\nmodule_function(3)\nprint(MODULE_VAR)\n\n2\n3"
  },
  {
    "objectID": "hs25/pds/pds_mock_exam.html#assignment-3-control-structures",
    "href": "hs25/pds/pds_mock_exam.html#assignment-3-control-structures",
    "title": "Python for Data Science - Mock Exam",
    "section": "",
    "text": "What does the script below print to the console?\nfor elem in range(2):\n    print(elem)\nOutput:\n0\n1\n\n\n\nfor elem in range(2):\n    print(elem)\n\n0\n1\n\n\n\n\n\n\nWhat does the script below print to the console?\nmylist = [1,2,3]\nfor ind, elem in enumerate(mylist):\n    print(ind)\nprint(elem)\nOutput:\n0\n1\n2\n3\n\n\n\nmylist = [1,2,3]\nfor ind, elem in enumerate(mylist):\n    print(ind)\nprint(elem)\n\n0\n1\n2\n3\n\n\n\n\n\n\nWhat does the script below print to the console?\na = 21\nb = 2\nif len(\"155kl\") &gt; 4:\n    while a &lt; 24:\n        print(a)\n        if b &lt;= 2:\n            break\n        a += 1\nelse:\n    while a &lt; 23:\n        print(a + 1)\n        if b &lt;= 2:\n            break\n        a += 1\nOutput:\n21\n\n\n\na = 21\nb = 2\nif len(\"155kl\") &gt; 4:\n    while a &lt; 24:\n        print(a)\n        if b &lt;= 2:\n            break\n        a += 1\nelse:\n    while a &lt; 23:\n        print(a + 1)\n        if b &lt;= 2:\n            break\n        a += 1\n\n21"
  },
  {
    "objectID": "hs25/pds/pds_mock_exam.html#assignment-4-complex-scripts-oop",
    "href": "hs25/pds/pds_mock_exam.html#assignment-4-complex-scripts-oop",
    "title": "Python for Data Science - Mock Exam",
    "section": "",
    "text": "What does the script below print to the console?\nclass MyClass ():\n    number = 3\n\n    def __init__(self, number):\n        self.number = number\n\nobj = MyClass(4)\nprint(MyClass.number)\nOutput:\n3\n\n\n\nclass MyClass ():\n    number = 3\n\n    def __init__(self, number):\n        self.number = number\n\nobj = MyClass(4)\nprint(MyClass.number)\n\n3\n\n\n\n\n\n\nWhat does the script below print to the console?\nclass MyNumber():\n    def __init__(self, number):\n        self.number = number\n\n    def my_method(self):\n        self.number = self.number + 1\n        return self.number\n\ni = 0\nobj = MyNumber(i)\nwhile i &lt;= 3:\n    i = obj.my_method()\n    print(i)\nelse:\n    print(\"?\")\nOutput:\n1\n2\n3\n4\n?\n\n\n\nclass MyNumber():\n    def __init__(self, number):\n        self.number = number\n\n    def my_method(self):\n        self.number = self.number + 1\n        return self.number\n\ni = 0\nobj = MyNumber(i)\nwhile i &lt;= 3:\n    i = obj.my_method()\n    print(i)\nelse:\n    print(\"?\")\n\n1\n2\n3\n4\n?\n\n\n\n\n\n\nWhat does the script below print to the console?\nclass MyBaseClass():\n    def __init__(self, number):\n        self.number = number\n\n    def my_method(self):\n        self.number = self.number + 10\n        return self.number\n\nclass MyClass(MyBaseClass):\n    def __init__(self, number):\n        super().__init__(number)\n\n    def my_method(self):\n        self.number = self.number + 1\n        return self.number\n\nobj = MyClass(3)\nprint(obj.number)\nprint(obj.my_method())\nprint(obj.number)\nOutput:\n3\n4\n4\n\n\n\nclass MyBaseClass():\n    def __init__(self, number):\n        self.number = number\n\n    def my_method(self):\n        self.number = self.number + 10\n        return self.number\n\nclass MyClass(MyBaseClass):\n    def __init__(self, number):\n        super().__init__(number)\n\n    def my_method(self):\n        self.number = self.number + 1\n        return self.number\n\nobj = MyClass(3)\nprint(obj.number)\nprint(obj.my_method())\nprint(obj.number)\n\n3\n4\n4"
  },
  {
    "objectID": "hs25/pds/pds_mock_exam.html#assignment-5-multiple-choice",
    "href": "hs25/pds/pds_mock_exam.html#assignment-5-multiple-choice",
    "title": "Python for Data Science - Mock Exam",
    "section": "",
    "text": "Which of the following statements about Python dictionaries are correct?\n\nNote: At least one statement must be marked, otherwise you will get 0 points.\n\n\n[‚úì] You can modify the value associated with a key in a dictionary after it has been created.\n[o] Keys in a dictionary must be strings.\n[o] Values in a dictionary must be of the same data type.\n[o] A dictionary can contain duplicate keys.\n[‚úì] Dictionaries can form nested structures.\n\n\n\n\nWhich of the following statements about Python classes/objects are correct?\n\nNote: At least one statement must be marked, otherwise you will get 0 points.\n\n\n[‚úì] A class is a blueprint for creating objects.\n[‚úì] An object can have attributes and methods.\n[‚úì] A class can be instantiated multiple times to create different objects.\n[o] All objects in Python are instances of built-in classes only.\n[‚úì] Inheritance allows a class to inherit attributes and methods from another class."
  },
  {
    "objectID": "hs25/pds/pds_mock_exam.html#assignment-1-quick-questions",
    "href": "hs25/pds/pds_mock_exam.html#assignment-1-quick-questions",
    "title": "Python for Data Science - Mock Exam",
    "section": "Assignment 1: Quick Questions",
    "text": "Assignment 1: Quick Questions\n\nQuestion 1\n\nQ: Is the data_processor.py module depending on any other custom modules?\nA: No, there is no explicit dependency on any other custom modules.\n\n\n\nQuestion 2\n\nQ: How many and which classes inherit from DataProcessor class?\nA: There is one class that inherits from the DataProcessor class in the provided module: DataAnalyzer.\n\n\n\nQuestion 3\n\nQ: Would the methods from DataLoader class still work if the first import statement (first line) of the module data_loader.py was missing? Justify your answer in one statement.\nA: No, the load_data method would fail because it explicitly relies on the csv module."
  },
  {
    "objectID": "hs25/pds/pds_mock_exam.html#assignment-2-code-completions",
    "href": "hs25/pds/pds_mock_exam.html#assignment-2-code-completions",
    "title": "Python for Data Science - Mock Exam",
    "section": "Assignment 2: Code Completions",
    "text": "Assignment 2: Code Completions\n\nToDo 1\nImport the classes DataProcessor and DataAnalyzer.\nfrom data_processor import DataProcessor, DataAnalyzer\n\n\nToDo 2\nCall the method load_data from loader object.\nloader.load_data()\n\n\nToDo 3\nWhat is the data type of the resulting data variable?\ndict\n\n\nToDo 4\nIs it possible to print an object of type ExcelDataLoader? Justify your answer with one statement.\nShort Answer: Yes, the __str__ method (and also __repr__) is defined by default for every class in Python, because all classes implicitly inherit from the base class object.\nLong Answer and Justification: If you do not define your own__str__ method in a class like ExcelDataLoader, the implementation from the base class object is used. However, this default implementation is very general and usually only provides a technical description of the object, such as:\n&lt;__main__.ExcelDataLoader object at 0x105a30e80&gt;\nThis output is rarely helpful to the user, as it provides no meaningful information about the content or state of the object (e.g., the loaded data or the file_path).\n\n\nToDo 5\nHow do you print the object analyzer and what output do you expect (sketch it down)?\nprint(analyzer)\nOutput:\nsepal_length        sepal_width         petal_length        petal_width         species\n4.4                 3.0                 1.3                 0.2                 setosa\n7.2                 3.2                 6.0                 1.8                 virginica\n6.4                 3.1                 5.5                 1.8                 virginica\n4.9                 NA                  1.4                 0.2                 setosa\n5.7                 3.8                 1.7                 0.3                 setosa\n\n\nToDo 6\nWrite a function double_fun, that doubles a value (parameter input) and returns it.\ndef double_func(value):\n    return value*2\n\n\nToDo 7\nApply the function double_fun together with the analyzer object to double all values of petal_length.\nanalyzer.apply_function(\"petal_length\", double_func)\n\n\nToDo 8\nCount the number of versicolor entries in the list species: 4 Points\n\n\n\n\n\n\nNote\n\n\n\nOnly one of the following alternatives is evaluated: * If you solve TODO 8 using list comprehension -&gt; (4 points) * If you solve TODO 8 without list comprehension -&gt; (3 points) * If you have problems with the previous definitions or dependencies, solve the independent task: TODO 8 B: Count the number of zeros in zeros -&gt; (2 points)\n\n\nres = sum(1 for i in species if i == \"versicolor\")"
  },
  {
    "objectID": "hs25/doe/doe_notes.html",
    "href": "hs25/doe/doe_notes.html",
    "title": "Design of Experiments",
    "section": "",
    "text": "The fundamental difference between observational studies and experimental research designs is that in the former, researchers simply observe and measure variables without actively intervening. In the latter, variables are purposefully manipulated to determine a cause-and-effect relationship.\n\n\n\nThe effect and aim of randomisation is to eliminate selection bias and confounding factors, and to ensure comparability between groups at the start of the study (baseline data).\n\n\n\nConfounding occurs when a factor (confounder) that has not been investigated is associated with both the independent and dependent variables, causing a spurious correlation between them.\n\n\n\nThe problem is distortion due to knowledge about the treatment. Blinding is a suitable technique for avoiding such distortions. It eliminates conscious and unconscious influences on the treatment result.\n\n\n\nOpen: No blining\nSingle-blind: Participants don‚Äôt know their group assignment (e.g., whether they‚Äôre receiving the real treatment or a placebo).\nDouble-blind: Neither the participants nor the researchers administering the treatment know the group assignments.\nTriple-blind: Participants, researchers, and the data analysts are all unaware of the group assignments."
  },
  {
    "objectID": "hs25/doe/doe_notes.html#observational-vs.-experimental",
    "href": "hs25/doe/doe_notes.html#observational-vs.-experimental",
    "title": "Design of Experiments",
    "section": "",
    "text": "The fundamental difference between observational studies and experimental research designs is that in the former, researchers simply observe and measure variables without actively intervening. In the latter, variables are purposefully manipulated to determine a cause-and-effect relationship."
  },
  {
    "objectID": "hs25/doe/doe_notes.html#randomization",
    "href": "hs25/doe/doe_notes.html#randomization",
    "title": "Design of Experiments",
    "section": "",
    "text": "The effect and aim of randomisation is to eliminate selection bias and confounding factors, and to ensure comparability between groups at the start of the study (baseline data)."
  },
  {
    "objectID": "hs25/doe/doe_notes.html#confounder",
    "href": "hs25/doe/doe_notes.html#confounder",
    "title": "Design of Experiments",
    "section": "",
    "text": "Confounding occurs when a factor (confounder) that has not been investigated is associated with both the independent and dependent variables, causing a spurious correlation between them."
  },
  {
    "objectID": "hs25/doe/doe_notes.html#blinding",
    "href": "hs25/doe/doe_notes.html#blinding",
    "title": "Design of Experiments",
    "section": "",
    "text": "The problem is distortion due to knowledge about the treatment. Blinding is a suitable technique for avoiding such distortions. It eliminates conscious and unconscious influences on the treatment result.\n\n\n\nOpen: No blining\nSingle-blind: Participants don‚Äôt know their group assignment (e.g., whether they‚Äôre receiving the real treatment or a placebo).\nDouble-blind: Neither the participants nor the researchers administering the treatment know the group assignments.\nTriple-blind: Participants, researchers, and the data analysts are all unaware of the group assignments."
  },
  {
    "objectID": "hs25/doe/doe_notes.html#introduction-to-scientific-theory",
    "href": "hs25/doe/doe_notes.html#introduction-to-scientific-theory",
    "title": "Design of Experiments",
    "section": "Introduction to scientific theory",
    "text": "Introduction to scientific theory\n\nScientific Theory\nExamines whether and how scientific knowledge can be obtained. It is a branch of philosophy that deals with the theory of scientific knowledge and scientific methods, as well as with research. It also analyzes the practices that generate scientific knowledge and examines the institutional and social contexts in which these take place.\n\n\nMethodology\nIt focuses on the underlying considerations, decisions, and justifications of the approach used in scientific research projects. It provides the instructional framework on how to proceed in order to gain scientific knowledge. It does not comprise a strictly formal set of rules but offers a diverse and pragmatic set of choices that are linked to human action.\n\n\nResearch Methodes\nSystematized procedures and approaches for obtaining knowledge.\n\n\nSelection of positions held in scientific theory\n\nClassical rationalism: Reason precedes experience and there are so-called ‚Äúinnate‚Äù concepts of reason.\nInductive empiricism: Findings are derived inductively based on observations and experiences.\nLogical positivism: The use of logic makes it possible to separate science from metaphysics.\nCritical rationalism: Findings are derived deductively based on observations.\n(Social) constructivism: Individuals construct their reality by relating their thinking and actions.\n\n\nNote: Inductive empiricism and critical rationalism belong to empirical research.\n\n\n\nWhat is empirical research?\nKnowledge can be gained only through observation, experiment, and experience. Empirical research examines the environment by means of observation and experiment. There are many research methods for conducting observations and experiments:\n\nInterview\nCase study\nSurvey study\nExperiment\n\n\n\nLandscape of empirical research\n\n\n\nLandscape of empirical research\n\n\n\n\nQuantitative Methodes\nResearch that uses quantitative methods is designed around the principles of critical rationalism. The approach assumes that a theory can never be finally verified, it can only be falsified.\n\n\nDescriptive statistics\n\nDescribes the data to be analyzed.\nIs limited to a sample as a subset of the population.\nDoes not allow for conclusions to be drawn about the population.\n\n\n\nInferential statistics\n\nFor drawing conclusions about the population based on information obtained from a sample.\nUse statistical hypothesis tests, especially, as the main component.\n\n\n\nHypothesis Testing\nHypothesis testing is a statistical method used to determine if there is enough evidence in a sample of data to support a specific hypothesis about a population. It involves formulating a null hypothesis and an alternative hypothesis, analyzing sample data, and making a decision based on the results, often using a p-value to assess significance.\n\nAlternative hypothesis (\\(H_A\\)): Research hypothesis to be tested that postulates the presence of a certain effect (e.g.¬†a difference) in the population.\nNull hypothesis (\\(H_0\\)): Postulates the opposite, namely the absence of an effect."
  },
  {
    "objectID": "hs25/doe/doe_notes.html#research-process",
    "href": "hs25/doe/doe_notes.html#research-process",
    "title": "Design of Experiments",
    "section": "Research process",
    "text": "Research process\n\nPhases\n\nFormulation of the research problem & study design\nPlanning and preparation of the study\nData collection\nData Analysis\nReporting\n\n\n\nMeasuring Instrument\nA process that uses a given set of circumstances to define and specify subsequent research steps with a view to better understanding these circumstances.\n\n\nSampling procedure\nA selection of cases derived from the population and compiled for research purposes results in statements as part of an empirical study. Sampling often involves people, but objects of all kinds (e.g., websites, newspaper articles, companies, countries) can also form a population. Sample surveys are typical of empirical social research. Only rarely are censuses used that examine all cases associated with the population."
  },
  {
    "objectID": "hs25/doe/doe_notes.html#definition-properties-of-study-design",
    "href": "hs25/doe/doe_notes.html#definition-properties-of-study-design",
    "title": "Design of Experiments",
    "section": "Definition & properties of study design",
    "text": "Definition & properties of study design\nThe choice of a suitable research design determines the scientific quality of a study. The planning of the analysis depends on the research design.\n\nStudy types\n\nDescriptive study: Descriptive character. Suitable for forming hypotheses (Surveys).\nAnalytical study: Identification and quantification of effects / verification of relationships. Not fully suitable for hypothesis testing (Cohot).\nRandomized controlled: Suitable for hypothesis testing (RCT)."
  },
  {
    "objectID": "hs25/doe/doe_notes.html#cause-and-effect",
    "href": "hs25/doe/doe_notes.html#cause-and-effect",
    "title": "Design of Experiments",
    "section": "Cause and Effect",
    "text": "Cause and Effect\nA trial / experiment is carried out to discover a cause-and-effect relationship in a process.\n\nTerms\n\nInput: Trial objects, test objects, test persons, ect.\nProcess: Process in which controllable and non-controllable factors influence the input.\nOutput (aka. Dependet variable: DV): Input changed by the process, result of the test/experiment.\nControllable factors (aka Independet variables: IV): Influencing factors whose strength can be adjusted within defined limits.\nNon-controllable factors: Influencing factors whose strength cannot be determined but that can be measured / cannot be determined and that cannot be measured."
  },
  {
    "objectID": "hs25/doe/doe_notes.html#non-controllable-factors",
    "href": "hs25/doe/doe_notes.html#non-controllable-factors",
    "title": "Design of Experiments",
    "section": "Non-controllable factors",
    "text": "Non-controllable factors\nNon-controllable factors are also referred to as nuisance variables in a general context or nuisance factors in the context of blocking\n\nNote: Blocking = arranging of experimental units in groups (blocks)"
  },
  {
    "objectID": "hs25/doe/doe_notes.html#causality-in-observational-and-experimental-study-designs",
    "href": "hs25/doe/doe_notes.html#causality-in-observational-and-experimental-study-designs",
    "title": "Design of Experiments",
    "section": "Causality in observational and experimental study designs",
    "text": "Causality in observational and experimental study designs\nObservational studies cannot directly prove causality, but only show correlations or associations. Since the assignment is not random, there is always a risk that the results are distorted by unknown confounding factors.\nExperimental studies (e.g.¬†RCTs) can prove causality because they control for confounding factors through randomisation, thereby isolating the effect of the cause. They are the gold standard."
  },
  {
    "objectID": "hs25/doe/doe_notes.html#variance",
    "href": "hs25/doe/doe_notes.html#variance",
    "title": "Design of Experiments",
    "section": "Variance",
    "text": "Variance\nThe variance describes the mean square deviation of the individual measured values from the empirical mean.\n\nPrimary variance: Impact of (experimental) factors in an experiment on the change / variation of the output to be examined.\nSecondary variance: Variation of the output to be examined, caused by nuisance variables. Not in the focus of the study.\nError variance: Variation caused by measurement errors and random processes.\n\n\nNote: Secondary and error variances are grouped to the residual variance.\n\n\nVariantion of Variance\nThe variance of the dependent variable (DV) (primary variance) should be attributed to the systematic variation of the independent variable (IV). The secondary variance should be controlled and the error variance minimized.\n\n\n\nSummary Variance\n\n\n\nMaximizing the primary variance\n\nRelationship is linear: Selecting of extreme values in the IV.\nRelationship were curvilinear: Selecting optimal increments of IV.\nRelationship were unknown: Selecting as many increments of IV in the smallest steps as possible.\n\n\n\nControl of the secondary variance\n\nKeeping constant: Keeping the experimental setup constant.\nRepetition: Several measurements are repeated on the same trial objects.\nRandomization: Trial objects are assigned randomly to Treatment and Control groups to eliminate systematic bias\nBlocking: Trial objects are grouped into homogeneous blocks based on one or more influential variables to reduce variability.\nCovariate adjustment: Nuisance variables are included as covariates in the statistical model to account for their effects.\n\n\n\nMinimizing the error variance\n\nReliable measurement setup: Standardization of the experimental conditions\nSample size: Larger sample sizes reduce the impact of individual measurement errors\nSuitable analytical methods: Use of robust estimators to account for heterogeneous error variance\n\n\n\n\nProperties of measurement instruments\n\nObjectivity: Objectivity of an instrument is given when the results are independent of personnel and calculation methods.\nReliability: Reliability is the degree to which an instrument produces the same result each time under comparable conditions.\nValidity: Validity is the extent to which an instrument measures what was intended."
  },
  {
    "objectID": "hs25/doe/doe_notes.html#design-of-experiments-types",
    "href": "hs25/doe/doe_notes.html#design-of-experiments-types",
    "title": "Design of Experiments",
    "section": "Design of Experiments Types",
    "text": "Design of Experiments Types\n\nTrial and error\nCombination of parameters have no structure and are mixed randomly. No idea what factors influence how.\n\n\nOne-factor-at-a-time\nVary the first factor and then measure fuel consumption. Keep the setting with the lowest consumption and then vary the next factor. Easy to implement, but interaction between factors are not recognized. Research question is answered neither systematically nor exhaustively.\n\n\nFull factorial design\nTwo levels (+/-) are defined per factor. All possible combinations of factor levels are varied. All main effects and all interactions can be determined. Can be used as a screening experiment to identify potentially important variables. The effort involved increases rapidly as the number of factors increases. Each additional factor doubles the number of combinations.\n\nProfile Plot\nImpact of the factors on the dependent variable \\(x\\). Based model:\n\\[\ny = \\beta_0 + \\beta_1 x_1 + \\beta_2 x_2 \\dots + \\beta_n x_n\n\\]"
  },
  {
    "objectID": "hs25/doe/doe_notes.html#factorial-design-with-interactions",
    "href": "hs25/doe/doe_notes.html#factorial-design-with-interactions",
    "title": "Design of Experiments",
    "section": "Factorial design with interactions",
    "text": "Factorial design with interactions\nInteractions can occur in experiments with two or more independent variables. An interaction of two factors means that the two factors interact in a complex way. If there is an interaction, the effect of one factor depends on the levels of the other factor. Interaction terms are written as multiplication.\n\nTwo way interaction: \\(x_1 \\times x_2\\)\nThree way interaction: \\(x_1 \\times x_2 \\times x_3\\)\n\n\\[\ny = \\beta_0 + \\beta_1 x_1 + \\beta_2 x_2 + \\beta_3 x_1 \\times x_2\n\\]\n\nFull factorial designs\nGeneralization of two-level full factorial design with \\(k\\) factors and \\(n\\) levels. All possible factor combinations are varied.\n\\[\n\\text{combinations} = n^k\n\\]\n\n\nFractional factorial designs\nOnly a (balanced) part of the possible combinations of factors are varied.\n\\[\n\\text{combinations} = n^{k-1}\n\\]\n\nDesign\n\nProcedure: The factor levels are determined before the experiment\nFactor combinations: Only a part of the possible combinations of factors are selected\nRestrictions: In fractional factorial designs, interactions can only be partially measured because not all possible combinations of factor levels are tested.\nAdvantages: The effort involved is significantly lower compared to full factorial designs\nStatistical analysis: As in the case of full factorial design, but without interactions"
  },
  {
    "objectID": "hs25/doe/doe_notes.html#quality-criteria-of-experiments",
    "href": "hs25/doe/doe_notes.html#quality-criteria-of-experiments",
    "title": "Design of Experiments",
    "section": "Quality criteria of experiments",
    "text": "Quality criteria of experiments\n\nInternal Validity\nExists when changes in dependent variables (DV) are attributed to independent variables (IV). Increases with decreasing impact of nuisance variables.\n\nPopulation Validity\nDegree to which the results of a study can be generalized from the sample to the whole population.\n\n\nSituation Validity\nDegree to which the findings of a study can be applied to different situations.\n\n\n\nExternal Validity\nExists when experimental results from a sample can be generalized to the entire population. Increases with increasing naturalness.\n\n\nConstruct Validity\nEffectiveness of the measurement methods in precisely capturing the intended construct\n\n\nRelationship between Internal vs.¬†External Validity\n\n\n\nRelationship between Internal vs.¬†External Validity\n\n\nThe lowest general level of validity is at the bottom left for the quasi-experimental laboratory study, and the highest is at the top right for the experimental field study. A well-controlled lab experiment may maximize internal validity by eliminating confounding variables."
  },
  {
    "objectID": "hs25/doe/doe_notes.html#population",
    "href": "hs25/doe/doe_notes.html#population",
    "title": "Design of Experiments",
    "section": "Population",
    "text": "Population\nSet of all (potentially explorable) elements that have a common characteristic or a common combination of characteristics. The observation units (individuals, households, etc.) must be defined before the research start. In order to define the population, clear differentiation criteria must be formulated, so that for each observation unit it can be determined whether it is part of the population.\n\nDifferentiation in geographical aspects\nDifferentiation of temporal aspects (point in time or period)\nDifferentiation in factual / content-related aspects"
  },
  {
    "objectID": "hs25/doe/doe_notes.html#generalizing-from-a-sample-to-the-population",
    "href": "hs25/doe/doe_notes.html#generalizing-from-a-sample-to-the-population",
    "title": "Design of Experiments",
    "section": "Generalizing from a sample to the population",
    "text": "Generalizing from a sample to the population\nThe population is often very large or not fully accessible. The population can be defined but not identified.\n\nCharacteristics of a sample\nA sample is a subset of all observation units and should reflect the relevant aspects of the population as accurately as possible. Three elements contribute to creating or describing representativeness:\n\nThe sample is drawn randomly.\nEstimation procedure for generalizing from the sample to the population is reported.\nAccuracy is reported, which is influenced by the sample size, among other things\n\n\n\nPoint estimate of the mean\nAn ‚Äúestimator‚Äù is a function that calculates a value.\n\n\\(\\bar{x}\\): Mean of the sample\n\\(\\mu_0\\): True mean in the population (generally unknown)\n\n\n\n\n\n\n\nImportant\n\n\n\nThe mean value x of a sample is an unbiased, efficient and consistent estimator of the true mean value in the population: \\(\\mu_0 = E(\\bar{x})\\)"
  },
  {
    "objectID": "hs25/doe/doe_notes.html#sampling-methods",
    "href": "hs25/doe/doe_notes.html#sampling-methods",
    "title": "Design of Experiments",
    "section": "Sampling methods",
    "text": "Sampling methods\n\nProbabilistic (random) sampling procedures: Selecting elements based on a random mechanism\nNon-probabilistic (non-random, purposive, arbitrary) sampling procedures: Selection of the elements is not based on a random mechanism, but is made by certain decisions (purposive or arbitrary selection of elements)\n\n\nSampling Map\n\n\n\nSampling procedure Overview\n\n\n\n\nSimple random sampling (SRS)\nRandom selection of n elements from the N elements of the population. Each element has the same probability of being included in the sample.\n\ndata &lt;- rnorm(100) # 100 random numbers\nView(data)\n\ndata_sample &lt;- sample(data, 10, replace=FALSE) # Take 10 random sample from data\nView(data_sample)\n\n\n\nStratified random sampling\nStructure of the population regarding certain characteristics is known in advance. The population is stratified in accordance with these characteristics.\n\nProportional: Selection set in each Disproportional: Selection rate per stratum stratum is the same (self-weighting)\nDisproportional: Selection rate per stratum stratum is the same (self-weighting) is different (samples will be weighted)\n\n\n\nCluster sampling\nThe elements are selected at a higher level. Variability within clusters is small (cluster elements are very similar) while variability between clusters is large (clusters differ greatly).\n\n\nArbitrary sampling\nArbitrary sampling occurs when a sample is selected based on the researcher‚Äôs discretion, convenience or ease of availability, without applying a specific, structured or random procedure.\n\n\nTargeted sampling\nFor populations that are difficult to reach and whose members are not closely networked. Preferred locations or places of residence of the members are identified and then systematically recruited on site.\n\n\nRespondent Driven Sampling\nMultiple waves of peer-to-peer recruitment with statistical adjustments are conducted to approximate a random sample. Recruited individuals are only allowed to recruit a limited number of other individuals and are only rewarded for each person actually recruited."
  },
  {
    "objectID": "hs25/doe/doe_notes.html#representativeness",
    "href": "hs25/doe/doe_notes.html#representativeness",
    "title": "Design of Experiments",
    "section": "Representativeness",
    "text": "Representativeness\nThe degree of representativeness is not measurable. The sample should be representative with regard to key characteristics of the study."
  },
  {
    "objectID": "hs25/doe/doe_notes.html#sampling-errors",
    "href": "hs25/doe/doe_notes.html#sampling-errors",
    "title": "Design of Experiments",
    "section": "Sampling errors",
    "text": "Sampling errors\n\nNon-sampling error\nDifference in the mean value between the defined ideal population and the real population that cannot be attributed to deficiencies in the random selection of the sample.\n\nCoverage error*: Part of the population cannot be identified.\nSystematic non-response: Lack of information on certain individual elements.\n\n\n\nSampling Error\nDifference between the estimated mean value from a randomly drawn sample and the real mean value of the population.\n\nSelection error: Not all elements of the population have the same selection probability.\nUse of an unsuitable estimator."
  },
  {
    "objectID": "hs25/doe/doe_notes.html#variability-of-sample-means",
    "href": "hs25/doe/doe_notes.html#variability-of-sample-means",
    "title": "Design of Experiments",
    "section": "Variability of Sample Means",
    "text": "Variability of Sample Means\nIn randomly drawn equal samples, the sample means vary depending on:\n\nAttribute: The more heterogeneously an attribute is distributed in the population, the greater the variability of the sample means among many samples.\nSample size: The smaller the sample size, the greater the variability of sample means among many samples."
  },
  {
    "objectID": "hs25/doe/doe_notes.html#standard-error",
    "href": "hs25/doe/doe_notes.html#standard-error",
    "title": "Design of Experiments",
    "section": "Standard Error",
    "text": "Standard Error\nThe standard error is a measure of the variability of the sample means among many samples. It quantifies the spread of sample means from repeated random samples of the same size around the population mean \\(\\mu_0\\)\n\\[\n\\hat{\\sigma}_{\\bar{X}} = \\sqrt{\\dfrac{s^2}{n}} = \\dfrac{s}{\\sqrt{n}}\n\\]\nThe larger the sample size, the smaller the standard error, and therefore, the larger the sample size, the more precise the sample mean is as an estimator of the population mean."
  },
  {
    "objectID": "hs25/doe/doe_notes.html#statistical-significance-and-importance-of-an-effect",
    "href": "hs25/doe/doe_notes.html#statistical-significance-and-importance-of-an-effect",
    "title": "Design of Experiments",
    "section": "Statistical significance and importance of an effect",
    "text": "Statistical significance and importance of an effect\nThe chance of having a significant result in a hypothesis test is:\n\nlarger if sample size \\(n\\) increases.\nsmaller if standard deviation \\(s\\) increases.\n\nAn effect in the population can be specified by an effect measurement. This measurement results in what is referred to as effect size.\n\nNote: The name effect size (ES) comes from Cohen (1992)"
  },
  {
    "objectID": "hs25/doe/doe_notes.html#effect-size",
    "href": "hs25/doe/doe_notes.html#effect-size",
    "title": "Design of Experiments",
    "section": "Effect size",
    "text": "Effect size\nEffect size is a statistical measure that quantifies the magnitude (or strength) of a phenomenon. A tiny p-value in a very large study might show a difference that is statistically significant, but practically meaningless. Effect size helps to evaluate exactly this. It expresses this difference in terms of standard deviations.\n\nA Cohen‚Äôs d of 1.0 means the means of the two groups are separated by exactly one standard deviation.\nA Cohen‚Äôs d of 0.0 means there is no difference between the means."
  },
  {
    "objectID": "hs25/doe/doe_notes.html#power-analysis",
    "href": "hs25/doe/doe_notes.html#power-analysis",
    "title": "Design of Experiments",
    "section": "Power analysis",
    "text": "Power analysis\nPower analysis is the crucial step in research design that connects your expected effect size with your desired power (80%) and significance (5%) to determine the minimum sample size you need to run a valid study.\n\nDetermining the sample size with R\n\n# install.packages(\"pwr\")\nlibrary(pwr)\npwr.t.test(d = 0.5, power = 0.80, sig.level = 0.05)\n\n\n     Two-sample t test power calculation \n\n              n = 63.76561\n              d = 0.5\n      sig.level = 0.05\n          power = 0.8\n    alternative = two.sided\n\nNOTE: n is number in *each* group"
  },
  {
    "objectID": "hs25/doe/doe_notes.html#the-fourth-paradigm",
    "href": "hs25/doe/doe_notes.html#the-fourth-paradigm",
    "title": "Design of Experiments",
    "section": "The Fourth Paradigm",
    "text": "The Fourth Paradigm\n\nEmpirical Science: Description of natural phenomena.\nTheoretical Science: Modelling and generalization.\nComputational Science: Simulation of complex phenomena.\nData-Intensive Science (eScience): Synthesis of information technology and science."
  },
  {
    "objectID": "hs25/doe/doe_notes.html#quantitative-empirical-research",
    "href": "hs25/doe/doe_notes.html#quantitative-empirical-research",
    "title": "Design of Experiments",
    "section": "Quantitative empirical research",
    "text": "Quantitative empirical research\n\nFormulation of teh research of the study\nPlanning and preparation of the study\nData collection\nData Analysis\nReporting\n\n\n\n\n\n\n\nNote\n\n\n\nDeductive approach ‚Üí Conclusion from the general to the specific.\n\n\n\nLimitations of quantitative empirical research\n\nMeaning of significant hypotheses vs.¬†meaning of effect size.\np-hacking (looking for data subsets and configurations until the p-value is less than 5%).\nAssumptions about the distribution of variables are violated.\nAssumption of homogeneity of variance is violated."
  },
  {
    "objectID": "hs25/doe/doe_notes.html#data-driven-research",
    "href": "hs25/doe/doe_notes.html#data-driven-research",
    "title": "Design of Experiments",
    "section": "Data-driven research",
    "text": "Data-driven research\n\nVisual Analytics: Exploratory Data Analysis & Descriptive Statistics.\nMachine Learning and Predictive Modelling: Regression / Classification / Decision Trees.\nAdvanced Analytics for Unstructured Data.\n\n\n\n\n\n\n\nNote\n\n\n\nInductive approach ‚Üí Conclusion from the specific to the general\n\n\n\nLimitations of data-driven research\n\nBig Data Hubris: Correlation is understood as causality.\nSparse data: Although the data basis is ‚Äúbig,‚Äù it contains little information.\nData analysis: A whole range of methodical errors."
  },
  {
    "objectID": "hs25/doe/doe_notes.html#abductive-approach-and-combination-of-approaches",
    "href": "hs25/doe/doe_notes.html#abductive-approach-and-combination-of-approaches",
    "title": "Design of Experiments",
    "section": "Abductive approach and combination of approaches",
    "text": "Abductive approach and combination of approaches\nInduction: Search and generation of theories that fit the research context. Induction shows that something actually is operative. Deduction: Verification or falsification of existing theories. Deduction proves that something must be. Abduction: Search and generation of new, also speculative theories. Abduction merely suggests that something may be.\n\nNote: Ideally, all three methods are used cyclically."
  },
  {
    "objectID": "hs25/doe/doe_notes.html#anova",
    "href": "hs25/doe/doe_notes.html#anova",
    "title": "Design of Experiments",
    "section": "ANOVA",
    "text": "ANOVA\nThe Analysis of Variance (ANOVA) is a statistical test used to determine whether there are any statistically significant differences between the means of three or more independent (unrelated) groups.\n\nOne-Way ANOVA: Used when comparing means across groups based on one single categorical independent variable (factor).\nTwo-Way ANOVA: Used when comparing means based on two or more independent variables (factors), allowing for the testing of interaction effects between the factors."
  },
  {
    "objectID": "hs25/doe/doe_notes.html#key-steps-in-analysis-of-variance",
    "href": "hs25/doe/doe_notes.html#key-steps-in-analysis-of-variance",
    "title": "Design of Experiments",
    "section": "Key Steps in Analysis of Variance",
    "text": "Key Steps in Analysis of Variance\n\nDesign of experiment\nCalculating differences and sum of squares\nVerification of the model\nConsidering other aspects (post hoc tests)\nTesting of assumptions (homogeneity of variance, etc.)\nInterpretation of the model and reporting (profile plots)\n\n\nNote: Step 2 is done by the ANOVA model"
  },
  {
    "objectID": "hs25/doe/doe_notes.html#one-way-anova-in-r",
    "href": "hs25/doe/doe_notes.html#one-way-anova-in-r",
    "title": "Design of Experiments",
    "section": "One-way ANOVA in R",
    "text": "One-way ANOVA in R\noneway.test(salary ~ factor(experience), var.equal=TRUE, data=data)\nfit &lt;- aov(salary ~ factor(experience), data=data)\nsummary(fit, intercept=TRUE)"
  },
  {
    "objectID": "hs25/doe/doe_notes.html#two-way-anova-in-r",
    "href": "hs25/doe/doe_notes.html#two-way-anova-in-r",
    "title": "Design of Experiments",
    "section": "Two-Way ANOVA in R",
    "text": "Two-Way ANOVA in R\n# Only main effects, no interaction\nfit &lt;- avo(salary ~ factor(experience) + factor(position), data=data)\nsummary(fit, intercept=TRUE)\n\n# With Interaction\nfit &lt;- avo(salary ~ factor(experience) * factor(position), data=data)\nsummary(fit, intercept=TRUE)"
  },
  {
    "objectID": "hs25/doe/doe_notes.html#main-effects",
    "href": "hs25/doe/doe_notes.html#main-effects",
    "title": "Design of Experiments",
    "section": "Main Effects",
    "text": "Main Effects\nThe direct effect of an independent variable on the dependent variable is called main effect. Profile plots are used as visualization.\n\n\n\nProfile Plots of Main Effect\n\n\n\n\n\n\n\n\nNote\n\n\n\nIf the profile plot shows a (nearly) horizontal line, the main effect in question is probably not significant."
  },
  {
    "objectID": "hs25/doe/doe_notes.html#interaction-effect",
    "href": "hs25/doe/doe_notes.html#interaction-effect",
    "title": "Design of Experiments",
    "section": "Interaction Effect",
    "text": "Interaction Effect\nAn interaction between experience and position means there is dependency between the two variables. The independent variables have a complex influence on the dependent variable. The factors do not just function additively but act together in a different manner.\n\n\n\nProfile Plot of Interaction Effect\n\n\n\n\n\n\n\n\nNote\n\n\n\nIf there is no interaction, the lines are parallel. If there is an interaction, the lines are not parallel."
  },
  {
    "objectID": "hs25/doe/doe_notes.html#prerequisites-of-anova",
    "href": "hs25/doe/doe_notes.html#prerequisites-of-anova",
    "title": "Design of Experiments",
    "section": "Prerequisites of ANOVA",
    "text": "Prerequisites of ANOVA\n\nSampling: Randomly assigning participants to the treatment or control groups.\nDistribution of residuals: Residuals (= error) are normally distributed.\nHomogeneity of variances: Residuals (= error) have constant variance\nBalanced design: Same sample size in all groups.\n\n\nNote: ANOVA is relatively robust against violations of prerequisites."
  },
  {
    "objectID": "hs25/doe/doe_notes.html#post-hoc-tests",
    "href": "hs25/doe/doe_notes.html#post-hoc-tests",
    "title": "Design of Experiments",
    "section": "Post Hoc Tests",
    "text": "Post Hoc Tests\nThere are different methods to compare groups in pairs. All methods are similar, however, in that they solve the problem of multiple testing.\npairwise.t.test(x, y, p.adj=\"bonf\")"
  },
  {
    "objectID": "hs25/doe/doe_notes.html#effect-size-1",
    "href": "hs25/doe/doe_notes.html#effect-size-1",
    "title": "Design of Experiments",
    "section": "Effect size",
    "text": "Effect size\nPartial eta squared \\({\\eta_p}^2\\) relates the variance explained by one factor to the variance not explained by other factors in the model.\nlibrary(effectsize)\neta_squared(fit)$Eta2 # Use your ANOVA fit"
  },
  {
    "objectID": "hs25/doe/doe_notes.html#overview-over-statistical-hypothesis-tests",
    "href": "hs25/doe/doe_notes.html#overview-over-statistical-hypothesis-tests",
    "title": "Design of Experiments",
    "section": "Overview over Statistical Hypothesis Tests",
    "text": "Overview over Statistical Hypothesis Tests\nChoosing the type of analysis depending on level of measurement\n\n\n\nOverview over Statistical Hypothesis Tests"
  },
  {
    "objectID": "hs25/doe/doe_notes.html#what-is-ab-testing",
    "href": "hs25/doe/doe_notes.html#what-is-ab-testing",
    "title": "Design of Experiments",
    "section": "What is A/B testing?",
    "text": "What is A/B testing?\nA/B testing (also bucket testing or split-run testing) is an experiment. The research questions are applied to two (A/B) or more randomized groups. The statistical analysis is done by t-test, ANOVA and more advanced methods."
  },
  {
    "objectID": "hs25/doe/doe_notes.html#carrying-out-ab-testing",
    "href": "hs25/doe/doe_notes.html#carrying-out-ab-testing",
    "title": "Design of Experiments",
    "section": "Carrying out A/B testing",
    "text": "Carrying out A/B testing\nThe aim is to determine which version achieves a better result, in terms of click-through rate etc. Two versions A and B are tested in parallel in a live environment. The generated data becomes the basis for decisions. Depending on the experiment, the test can be applyed to all users of a website or only a subset."
  },
  {
    "objectID": "hs25/doe/doe_notes.html#bandit-algorithm",
    "href": "hs25/doe/doe_notes.html#bandit-algorithm",
    "title": "Design of Experiments",
    "section": "Bandit algorithm",
    "text": "Bandit algorithm\nSeveral variants (treatments A, B, C, ‚Ä¶) are run in parallel. The variant with the highest ‚Äúsuccess‚Äù (according to metrics) get more data traffic. Other variants are refined and tested with proportionally less traffic. Traffic allocation is continuously adjusted based on the observed success. As the test progresses, more and more information about the performance of the variants becomes available, so that the most successful variant can be identified dynamically.\n\n\n\n\n\n\nNote\n\n\n\nA key advantage of bandit algorithms is that they can achieve higher overall profit while still collecting data on the other variants."
  },
  {
    "objectID": "hs25/doe/doe_notes.html#measurement-metrics-kpi",
    "href": "hs25/doe/doe_notes.html#measurement-metrics-kpi",
    "title": "Design of Experiments",
    "section": "Measurement / Metrics / KPI",
    "text": "Measurement / Metrics / KPI\n\nMeasurement: Method for obtaining one or more measured values that can be assigned to a quantity\nMetrics: Calculation from measured values\nKPI: Quantifiable metric that shows how effectively the most important company goals are achieved"
  },
  {
    "objectID": "hs25/doe/doe_notes.html#error-sources-and-pitfalls",
    "href": "hs25/doe/doe_notes.html#error-sources-and-pitfalls",
    "title": "Design of Experiments",
    "section": "Error sources and pitfalls",
    "text": "Error sources and pitfalls\nA/B testing cannot be used in all research questions ‚Üí Example: For a complete website redesign (further elements have to be included). Population is unknown, sampling procedure is not suitable, sampling bias, ect.\n\nDark Pattern / Deceptive Pattern\nDark / deceptive patterns are patterns of persuasion and influence. They may increase short-term gains for the provider but can harm brand image, user experience, and customer satisfaction. A/B testers must ensure that the variants they test are ethically acceptable and aim to create genuine added value for the user.\n\n\n\n\n\n\nCaution\n\n\n\nThe problem with testing dark patterns is that A/B tests typically measure short-term metrics (such as clicks or conversions). They are not good at capturing long-term damage."
  },
  {
    "objectID": "hs25/doe/doe_notes.html#full-factorial-designs-1",
    "href": "hs25/doe/doe_notes.html#full-factorial-designs-1",
    "title": "Design of Experiments",
    "section": "Full factorial designs",
    "text": "Full factorial designs\n\nSingle factorial (One)\nOne independent variable IV (factor) acts on the dependent variable DV. Two groups are compared:\n\n1 IV: one IV with two levels (dichotomous)\n1 DV: metric scaled\nExamples: A/B test, RCT with treatment and control or two treatments\nAnalysis: One-way ANOVA\n\nOne independent variable IV (factor) acts on the dependent variable DV. Several groups are compared:\n\n1 IV: one IV with several levels\n1 DV: metric scaled\nExamples: RCT with combinations of more than two treatments and control\nAnalysis: One-way ANOVA\n\n\n\nMultifactorial (Several)\nSeveral factors act on the dependent variable DV. Several groups are compared:\n\nX IV ‚Üí several IV with two or more levels each\n1 DV ‚Üí metric scaled\nExamples: Dwell time with two IV\nAnalysis: Multi-factorial ANOVA (two-way ANOVA, three-way ANOVA, ‚Ä¶)"
  },
  {
    "objectID": "hs25/doe/doe_notes.html#fractional-factorial-designs-1",
    "href": "hs25/doe/doe_notes.html#fractional-factorial-designs-1",
    "title": "Design of Experiments",
    "section": "Fractional factorial designs",
    "text": "Fractional factorial designs\nThe more factors and the more characteristics, the larger the number of groups. Provided that there are no interactions, the experiment can also be conducted successfully with a reduced number of groups. By using Latin squares or related designs, the number of groups required can be significantly reduced compared to full factorial designs.\n\nIn principle multifactorial (Several)\nSeveral factors act on the dependent variable DV. Several groups are compared: - X IV ‚Üí several IV with two or more levels each - 1 DV ‚Üí metric scaled - BUT Not all possible combinations are considered"
  },
  {
    "objectID": "hs25/doe/doe_notes.html#latin-square",
    "href": "hs25/doe/doe_notes.html#latin-square",
    "title": "Design of Experiments",
    "section": "Latin square",
    "text": "Latin square\nA Latin squares design makes it possible to study the main effects of factors without having to observe all combinations of treatment levels.\n\n\n\nCombination Table\n\n\nAll combinations lead to a total of 27 (full factorial).\n\n\n\nLatin Square\n\n\nHere we only use 9 combinations (fractional factorial).\n\n\n\n\n\n\nCaution\n\n\n\nA Latin squares design can only be used if it follows from theory or empirical evidence that the joint effect of the factors does not produce interactions."
  },
  {
    "objectID": "hs25/doe/doe_notes.html#what-are-large-data-quantities",
    "href": "hs25/doe/doe_notes.html#what-are-large-data-quantities",
    "title": "Design of Experiments",
    "section": "What are large data quantities?",
    "text": "What are large data quantities?\n\nSamples are taken as part of a study. Primary goal: To answer research questions\nAdministrative data are collected for various reasons. Primary goal: To serve documentary and administrative purposes\nGrey area Data from full surveys (census), from social media and from ‚Äúrepresentative‚Äù surveys lie somewhat between data from a sample and administrative data.\n\nThis terminology has become established in many fields of research: - Made data ‚Üí Data is generated by researchers (‚Äúmade‚Äù). - Found data ‚Üí Data are obtained administratively and technically (‚Äúfound‚Äù)"
  },
  {
    "objectID": "hs25/doe/doe_notes.html#what-is-bias",
    "href": "hs25/doe/doe_notes.html#what-is-bias",
    "title": "Design of Experiments",
    "section": "What is bias?",
    "text": "What is bias?\nDeviation between mean \\(\\mu_0\\) in the population and sample mean \\(\\bar{x}\\). Three elements determine the bias:\n\nData quality measure\nData quantity measure\nProblem difficulty measure\n\n\nHow can bias be quantified?\n\\[\n\\text{Bias} = \\bar{x} - \\mu_0 = \\rho_{R,G} \\times \\sqrt{\\frac{1-f}{f}} \\times \\sigma_G\n\\]\n\n\\(\\rho_{R,G}\\): Data Quality\n\\(\\sqrt{\\frac{1-f}{f}}\\): Data Quantity\n\\(\\sigma_G\\): Problem Difficulty\n\n\n\nData defect correlation \\(\\rho_{R,G}\\)\nIn \\(\\rho_{R,G}\\) the \\(R\\) is a function that shows how data is obtained from the population. In simple random sampling, the \\(R\\) function generates a randomly generated sequence of elements drawn from the population. Because of the random process, the selection of an element is independent of \\(G\\).\n\n\nStatistical paradises and paradoxes in relation to administrative data sets\nMeasure for the size of the bias ‚Üí Mean-squared error (MSE). The MSE measures the deviation (bias) of the estimator \\(\\bar{x}\\) from the mean \\(\\mu_0\\) in the population. The bias goes to \\(0\\) only, if the size \\(n\\) of the administrative dataset goes against \\(N\\) (\\(n\\) ‚Üí \\(N\\)).\n\n\n\n\n\n\nImportant\n\n\n\nThe absolute size \\(n\\) of the administrative dataset is meaningless without specifying \\(N\\)."
  },
  {
    "objectID": "hs25/doe/doe_notes.html#spurious-correlation",
    "href": "hs25/doe/doe_notes.html#spurious-correlation",
    "title": "Design of Experiments",
    "section": "Spurious Correlation",
    "text": "Spurious Correlation\nA spurious correlation is a relationship between two variables that appears to be statistically significant and related, but is not actually caused by one another. The relationship is deceptive or coincidental, and often results from either a hidden factor or simply random chance. The primary risk of spurious correlation is that people might mistakenly conclude that a causal relationship exists based solely on the correlation, leading to incorrect policies or decisions."
  },
  {
    "objectID": "hs25/pds/pds_notes.html",
    "href": "hs25/pds/pds_notes.html",
    "title": "Python for Data Science - Notes",
    "section": "",
    "text": "An interpreter translates code and sends it to the CPU. The code is sent to the interpreter line by line. The interpreter provides a console for ad-hoc commands. It‚Äôs usually slower than a compiler and not good for optimization.\nA compiler processes source code and returns an executable file. Compiler languages are usually fast and made for optimization (speed, storage use). Executable code is almost impossible to reverse-engineer."
  },
  {
    "objectID": "hs25/pds/pds_notes.html#interpreter-vs.-compiler-languages",
    "href": "hs25/pds/pds_notes.html#interpreter-vs.-compiler-languages",
    "title": "Python for Data Science - Notes",
    "section": "",
    "text": "An interpreter translates code and sends it to the CPU. The code is sent to the interpreter line by line. The interpreter provides a console for ad-hoc commands. It‚Äôs usually slower than a compiler and not good for optimization.\nA compiler processes source code and returns an executable file. Compiler languages are usually fast and made for optimization (speed, storage use). Executable code is almost impossible to reverse-engineer."
  },
  {
    "objectID": "hs25/pds/pds_notes.html#python-console-vs.-script",
    "href": "hs25/pds/pds_notes.html#python-console-vs.-script",
    "title": "Python for Data Science - Notes",
    "section": "Python console vs.¬†script",
    "text": "Python console vs.¬†script\nThe Python console is a direct interface to the interpreter. Every instruction is sent sequentially to the interpreter. Commands sent in the console are sent directly to the interpreter.\nA Python script is a collection of commands. Executing a Python script means sending all the commands it contains consecutively to the interpreter."
  },
  {
    "objectID": "hs25/pds/pds_notes.html#virtual-enviroments-venv",
    "href": "hs25/pds/pds_notes.html#virtual-enviroments-venv",
    "title": "Python for Data Science - Notes",
    "section": "Virtual enviroments (venv)",
    "text": "Virtual enviroments (venv)\nTo avoid dependency issues of packages and keep the development environment clean, developers programme applications in virtual environments.\nPython3 -m venv .venv # Standard name\n\nNote: It is best practice to name the virtual environment .venv to hide it in the file system.\n\nYou need to activate the virtual environment.\n. .venv/bin/activate # For Linux\nYou can install packages into the venv with python3-pip."
  },
  {
    "objectID": "hs25/pds/pds_notes.html#variabels-and-basic-data-types",
    "href": "hs25/pds/pds_notes.html#variabels-and-basic-data-types",
    "title": "Python for Data Science - Notes",
    "section": "Variabels and Basic data types",
    "text": "Variabels and Basic data types\nA variable is a name that refers to a particular or undefined value. In programming languages, we use them as a reference to a particular storage location. A variable always consists of a name, a data type, a storage location and a value. Python does not require any type for variable definitions. It assumes the type from the value.\n\nNote: Variable names are usually written in lowercase.\n\nBasic data types:\n\nInteger (int)\nString (str)\nBoolean (bool).\nList\nDictionary"
  },
  {
    "objectID": "hs25/pds/pds_notes.html#mathematical-operations",
    "href": "hs25/pds/pds_notes.html#mathematical-operations",
    "title": "Python for Data Science - Notes",
    "section": "Mathematical Operations",
    "text": "Mathematical Operations\nDepending on the context, two particular mathematical operators can have different meanings. The sum operator (\\(+\\)), except for numerical values, means appending one element to another. This usually requires two elements of the same data type. The multiplication operation (\\(*\\)) always has to be applied with an integer.\n\nNote: Sum and multiplication can be used with strings."
  },
  {
    "objectID": "hs25/pds/pds_notes.html#boolean-operations",
    "href": "hs25/pds/pds_notes.html#boolean-operations",
    "title": "Python for Data Science - Notes",
    "section": "Boolean operations",
    "text": "Boolean operations\nTwo Boolean values can be combined in different ways using the keywords and, or and xor. Any Boolean operation can be inverted using the keyword not."
  },
  {
    "objectID": "hs25/pds/pds_notes.html#bitwise-operations",
    "href": "hs25/pds/pds_notes.html#bitwise-operations",
    "title": "Python for Data Science - Notes",
    "section": "Bitwise operations",
    "text": "Bitwise operations\nBitwise operations in Python are used to manipulate individual bits of integer values.\n\nx | y bitwise or of x and y\nx ^ y bitwise exclusive or of x and y\nx & y bitwise and of x and y\nx &lt;&lt; n x shifted left by n bits\nx &gt;&gt; n x shifted right by n bits\n~x the bits of x inverted"
  },
  {
    "objectID": "hs25/pds/pds_notes.html#comparison-operations",
    "href": "hs25/pds/pds_notes.html#comparison-operations",
    "title": "Python for Data Science - Notes",
    "section": "Comparison operations",
    "text": "Comparison operations\n\n&lt; strictly less than\n&lt;= less than or equal\n&gt; strictly greater than\n&gt;= greater than or equal\n== equal\n!= not equal\nis object identity\nis not negated object identity\n\n\nNote: Comparisons can be chained arbitrarily."
  },
  {
    "objectID": "hs25/pds/pds_notes.html#single-block",
    "href": "hs25/pds/pds_notes.html#single-block",
    "title": "Python for Data Science - Notes",
    "section": "Single block",
    "text": "Single block\ninstruction\ninstruction\nblock header:\n‚Ä¢‚Ä¢‚Ä¢‚Ä¢block instruction\n‚Ä¢‚Ä¢‚Ä¢‚Ä¢block instruction\n‚Ä¢‚Ä¢‚Ä¢‚Ä¢block instruction\ninstruction\ninstruction"
  },
  {
    "objectID": "hs25/pds/pds_notes.html#nested-blocks",
    "href": "hs25/pds/pds_notes.html#nested-blocks",
    "title": "Python for Data Science - Notes",
    "section": "Nested blocks",
    "text": "Nested blocks\ninstruction\ninstruction\nblock 1 header:\n‚Ä¢‚Ä¢‚Ä¢‚Ä¢block 1 instruction\n‚Ä¢‚Ä¢‚Ä¢‚Ä¢block 2 header:\n‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢block 2 instruction\n‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢block 2 instruction\n‚Ä¢‚Ä¢‚Ä¢‚Ä¢block 1 instruction\n‚Ä¢‚Ä¢‚Ä¢‚Ä¢block 1 instruction\ninstruction"
  },
  {
    "objectID": "hs25/pds/pds_notes.html#elif-concatenation",
    "href": "hs25/pds/pds_notes.html#elif-concatenation",
    "title": "Python for Data Science - Notes",
    "section": "Elif concatenation",
    "text": "Elif concatenation\nelif allows for concatenating multiple conditions.\n\nx = 6\n\nif x == 10:\n    print(\"x has the value 10\")\nelif x % 2 == 0:\n    print(\"x is an even number\")\n\nx is an even number"
  },
  {
    "objectID": "hs25/pds/pds_notes.html#shorthand-statement",
    "href": "hs25/pds/pds_notes.html#shorthand-statement",
    "title": "Python for Data Science - Notes",
    "section": "Shorthand statement",
    "text": "Shorthand statement\nShorthand if statements allow for less code and better readability.\n\nx = 10\n\n# Block\nif x == 10:\n    x += 1\n    print(x)\nelse:\n    None\n\n## Is the same as\n\nx = 10\n# One Line\nx = x + 1 if x == 10 else None\nprint(x)\n\n11\n11"
  },
  {
    "objectID": "hs25/pds/pds_notes.html#range",
    "href": "hs25/pds/pds_notes.html#range",
    "title": "Python for Data Science - Notes",
    "section": "range ()",
    "text": "range ()\nThe class range() allows creating sequence objects with constant step sizes. Ranges implement all of the common sequence operations except concatenation and repetition.\n\nNotes: The stop element is not included.\n\n\nmy_range = list(range(2, 11, 2)) # Start = 2, End = 11, Steps = 2\nprint(my_range)\n\n[2, 4, 6, 8, 10]"
  },
  {
    "objectID": "hs25/pds/pds_notes.html#len",
    "href": "hs25/pds/pds_notes.html#len",
    "title": "Python for Data Science - Notes",
    "section": "len()",
    "text": "len()\nlen() returns the number of elements in a sequence. Returns positive integer: 0 indicates an empty sequence.\n\nmy_lenght = len(range(1, 11, 1))\nprint(my_lenght)\n\n10"
  },
  {
    "objectID": "hs25/pds/pds_notes.html#sequence-slicing",
    "href": "hs25/pds/pds_notes.html#sequence-slicing",
    "title": "Python for Data Science - Notes",
    "section": "Sequence Slicing",
    "text": "Sequence Slicing\nExtracting sub-sequences of larger data containers is an important and often used operation. Slicing options are:\n\nBy integer (particular element)\nBy range or slice object\n\n\nmy_list = list(range(1, 11, 1))\nprint(f\"My list: {my_list}\")\n\n# Extract only even numbers\neven_numbers = my_list[1:11:2] # Start = Index 1 (second entry), Steps = 2\nprint(f\"All even numbers in my list: {even_numbers}\")\n\n# Extract only odd numbers\nodd_numbers = my_list[0:11:2] # Start = Index 0 (first entry), Steps = 2\nprint(f\"All odd numbers in my list: {odd_numbers}\")\n\nMy list: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nAll even numbers in my list: [2, 4, 6, 8, 10]\nAll odd numbers in my list: [1, 3, 5, 7, 9]\n\n\n\nNote: Same as slice()"
  },
  {
    "objectID": "hs25/pds/pds_notes.html#for-loop",
    "href": "hs25/pds/pds_notes.html#for-loop",
    "title": "Python for Data Science - Notes",
    "section": "for-loop",
    "text": "for-loop\nLoops are used to iterate over sequence objects by providing each element one after the other through a loop variable. Assign each element of the sequence one after another to the loop variable.\n\n# Single loop\nmy_list = list(range(1, 11, 1))\nprint(f\"My list: {my_list}\")\n\nfor element in my_list:\n    print(f\"Element is {element}\")\nelse:\n    print(\"No more elements in my list\")\n\nMy list: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nElement is 1\nElement is 2\nElement is 3\nElement is 4\nElement is 5\nElement is 6\nElement is 7\nElement is 8\nElement is 9\nElement is 10\nNo more elements in my list\n\n\n\nNote: The loop variable is often called i: for i in my_list:."
  },
  {
    "objectID": "hs25/pds/pds_notes.html#while-loop",
    "href": "hs25/pds/pds_notes.html#while-loop",
    "title": "Python for Data Science - Notes",
    "section": "while-loop",
    "text": "while-loop\nA while loop executes the loop body as long as the condition equals True. The while loop checks the condition each time before re-executing the loop body and terminates as soon as the condition is False.\n\naim = 5\ncounter = 0\n\nwhile counter != aim: # != means not equal\n    print(f\"Counter at value {counter}\")\n    counter += 1 # Add 1 to the counter\nelse:\n    print(\"Aim reached\")\n\nCounter at value 0\nCounter at value 1\nCounter at value 2\nCounter at value 3\nCounter at value 4\nAim reached\n\n\n\nNote: Check whether the condition can be reached! Otherwise, you will end up in an infinite loop."
  },
  {
    "objectID": "hs25/pds/pds_notes.html#break-continue-and-pass",
    "href": "hs25/pds/pds_notes.html#break-continue-and-pass",
    "title": "Python for Data Science - Notes",
    "section": "break, continue and pass",
    "text": "break, continue and pass\nPython has three keywords to control the loop (and function) process flow:\n\nbreak\nImmediately break the current loop.\n\naim = 5\ncounter = 0\n\nwhile counter != aim:\n    print(f\"Counter at value {counter}\")\n    counter += 1\n    break # Force a loop break\nelse:\n    print(\"Aim reached\")\n\nCounter at value 0\n\n\n\n\ncontinue\nIgnoring the rest of the loop body and jumping back to the header.\n\naim = 5\ncounter = 0\n\nwhile counter != aim:\n    print(f\"Counter at value {counter}\")\n    counter += 1\n    continue\n    print(\"This msg will not be printed\")\nelse:\n    print(\"Aim reached\")\n\nCounter at value 0\nCounter at value 1\nCounter at value 2\nCounter at value 3\nCounter at value 4\nAim reached\n\n\n\n\npass\nNo operation. Regular iteration with no execution.\n\naim = 5\ncounter = 0\n\nwhile counter != aim:\n    print(f\"Counter at value {counter}\")\n    counter += 1\n    pass\nelse:\n    print(\"Aim reached\")\n\nCounter at value 0\nCounter at value 1\nCounter at value 2\nCounter at value 3\nCounter at value 4\nAim reached"
  },
  {
    "objectID": "hs25/pds/pds_notes.html#enumerate",
    "href": "hs25/pds/pds_notes.html#enumerate",
    "title": "Python for Data Science - Notes",
    "section": "Enumerate",
    "text": "Enumerate\nThe enumerate returns an iterator that returns a tuple with an incrementing number for each element of the sequence.\n\nx = list(range(0, 11, 2))\n\nfor idx, i in enumerate(x):\n    print(f\"Value {i} at Index {idx}\")\n\nValue 0 at Index 0\nValue 2 at Index 1\nValue 4 at Index 2\nValue 6 at Index 3\nValue 8 at Index 4\nValue 10 at Index 5"
  },
  {
    "objectID": "hs25/pds/pds_notes.html#remote-app-development",
    "href": "hs25/pds/pds_notes.html#remote-app-development",
    "title": "Python for Data Science - Notes",
    "section": "Remote App Development",
    "text": "Remote App Development\nModern data analysis methods (e.g.¬†deep learning, optimisation) require large computational resources such as memory or gpu. Remote resources can be provided by individual institutions like HSLU, or rent from web service providers like Amazone Web Services (AWS) or Google Cloud Platform (GCP). Data scientists use two popular Python development environments for data analysis and reporting: Desktop IDE (PyCharm) and Notebooks (Jupyter)."
  },
  {
    "objectID": "hs25/pds/pds_notes.html#jupyter-nootebooks",
    "href": "hs25/pds/pds_notes.html#jupyter-nootebooks",
    "title": "Python for Data Science - Notes",
    "section": "Jupyter Nootebooks",
    "text": "Jupyter Nootebooks\nA Jupyter Notebook is a web-based, open-source tool that combines live code (like Python), equations, output, and narrative text (Markdown) into a single, interactive document. It is organized into cells and is a cornerstone of data science for combining execution and documentation, making analysis transparent and reproducible."
  },
  {
    "objectID": "hs25/pds/pds_notes.html#debugging",
    "href": "hs25/pds/pds_notes.html#debugging",
    "title": "Python for Data Science - Notes",
    "section": "Debugging",
    "text": "Debugging\n\nSemantic errors: violating rules of coding language.\nSyntax errors: missing code elements (e.g.¬†parathesis).\nLogical errors: correct syntax but incorrect directions causing undesired output.\nRuntime errors: error happens when application is running or starting up.\nect.\n\n\nBreakpoints\nBreakpoints define code locations where the execution shall stop. The execution is stopped before the selected line of code.\n\n\nDebugger\nA debugger is a tool that allows developers to meticulously examine and control the execution of their code. It enables the setting of breakpoints, allowing the developer to inspect the current state of variables, the call stack (the sequence of function calls that led to the current point), and memory. This step-by-step execution, often called stepping (e.g., step over, step into, step out), is fundamental for isolating and understanding the root cause of bugs or unexpected behavior."
  },
  {
    "objectID": "hs25/pds/pds_notes.html#enum-data-type",
    "href": "hs25/pds/pds_notes.html#enum-data-type",
    "title": "Python for Data Science - Notes",
    "section": "Enum data type",
    "text": "Enum data type\nAn Enum is a set of symbolic names bound to unique values. Enumeration requires the package Enum.\n\nfrom enum import Enum\n\nEnum allows handle a set of values:\n\ndays of the week\nColors\nect."
  },
  {
    "objectID": "hs25/pds/pds_notes.html#functions",
    "href": "hs25/pds/pds_notes.html#functions",
    "title": "Python for Data Science - Notes",
    "section": "Functions",
    "text": "Functions\nFunctions allow to combine multiple instruction into a function block that can be executed multiple times. Main advantages of functions are modularity (mitigates code duplication) and readability. Functions tackle only one particular issue at once. Ideally operate on its input only and produce some output.\n\nNote: Functions are named by convention in snake case (i.e.¬†lower case separated with ‚Äô_‚Äô): my_function().\n\nThe function header is made up of the function name and any optional parameters.\n\nNote: Functions in Python are defined by the term def.\n\n\n# Name = my_function\n# Parameters: parameter1\ndef my_function(parameter1):\n    pass # Do nothing, just pass.\n\nThe body of a function contains a sequence of operations and should always have an output value. The number of operations within a function is unlimited, and they can call other functions.\n\ndef my_function(parameter1):\n    print(parameter1) # Call the print function\n    return True\n\nmy_function(\"Test run\") # Call my_function\n\nTest run\n\n\nTrue\n\n\n\nReturn Values\nAll functions (including purely functional) have one return value; at least None. Return value is a pointer to a storage location.\n\n\nDocumentation\nPython offers a centralized documentation with docstrings; a built-in attribute assigned to each function named __doc__. If the __doc__ attribute is set with a documentation string, it is callable by means of the help() function. You can place a string block (triple-quotes ‚Äú‚Äù‚Äùdoc text‚Äù‚Äù‚Äù) immediately next to the function definition to define the docstring.\n\ndef my_function(parameter1):\n    \"\"\" Prints a given parameter to the console \"\"\" # Docstring of my_function\n    print(parameter1) # Call the print function\n    return True"
  },
  {
    "objectID": "hs25/pds/pds_notes.html#string-formatting",
    "href": "hs25/pds/pds_notes.html#string-formatting",
    "title": "Python for Data Science - Notes",
    "section": "String Formatting",
    "text": "String Formatting\nPython treats a string as a sequence (list) of characters (single letters, symbols or escape characters). Strings can be sliced, concatenated, allows index based access and formatting based on character position.\n\n\n\nString as a sequence of characters\n\n\nFormatting strings means defining the representation and treatment of particular sequences.\n\nf-Strings\nAn f-string can be used to add variables to a string. Rather than writing the string again every time the variable changes, we can use the f-string to add multiple variables to the string.\n\nfor i in range(1, 5):\n    # Using f-String\n    print(f\"i is {i}\") # i changes over time\n\ni is 1\ni is 2\ni is 3\ni is 4"
  },
  {
    "objectID": "hs25/pds/pds_notes.html#file-handling",
    "href": "hs25/pds/pds_notes.html#file-handling",
    "title": "Python for Data Science - Notes",
    "section": "File Handling",
    "text": "File Handling\nFiles enable storing data outside of the application and hence to keep the information for next execution or share data between different application. Python accesses files through a file object.\nfile_object = open(file_name, mode)\n\n\n\n\n\n\nImportant\n\n\n\nThe buffer results in unfinished writing process as long as the file stream (file_object) is not flushed by ‚Äòfile_object.flush() or file_object.close()‚Äô."
  },
  {
    "objectID": "hs25/pds/pds_notes.html#namespace",
    "href": "hs25/pds/pds_notes.html#namespace",
    "title": "Python for Data Science - Notes",
    "section": "Namespace",
    "text": "Namespace\nNamespace is the definition of the visibility of a unique name for every single object (variables or methods). Object names must only be unique within a given namespace. Hence, the global namespace can have multiple local namespaces having objects with the same naming. The scope of an object refers to the code section from which an object is accessible.\n\nbuilt-in: encompasses no programmer defined objects. Ends when the application ends.\nglobal: programmer defined objects available across the whole script. Ends when the module (i.e.¬†script) is unloaded or the application ends.\nlocal: programmer defined objects in function blocks. Ends when the function (i.e.¬†block) has been finished."
  },
  {
    "objectID": "hs25/pds/pds_notes.html#local-and-global-variables",
    "href": "hs25/pds/pds_notes.html#local-and-global-variables",
    "title": "Python for Data Science - Notes",
    "section": "Local and Global Variables",
    "text": "Local and Global Variables\nPython allows creating variables without any restricted visibility. This variables in the global scope are accessible in the whole script and are called global variables. Local variables being restricted to a specific function block.\n\nglobal_var = 123 # Free/Global variable\n\ndef my_function():\n    local_var = \"Hello\" # Local variable\n    print(local_var, global_var)\n\n# The function can use both variables\nmy_function()\n\n# This is not possible!\n# print(local_var)\n\nHello 123\n\n\n\nKeyword global\nIn some problem solutions it is meaningful to have a global variable which gets updated from within a local scope of a function.\n\ncounter = 10\nprint(counter)\n\ndef reset():\n    global counter\n    counter = 0\n    print(f\"Counter reseted: {counter}\")\n\nreset()\n\n10\nCounter reseted: 0\n\n\n\nNote: It‚Äôs best practice to avoid global variables.\n\n\n\nKeyword nonelocal\nThe Python keywords global and nonlocal target different scope levels when modifying a variable from within a function.\n\ndef outer():\n    enclosing_var = 20\n\n    def inner():\n        nonlocal enclosing_var\n        enclosing_var = 200\n\n        global global_var\n        global_var = 100\n\n        print(f\"Inner: global_var={global_var}, enclosing_var={enclosing_var}\")\n\n    inner()\n    print(f\"Outer: global_var={global_var}, enclosing_var={enclosing_var}\")\n\nprint(f\"Start Global: {global_var}\")\nouter()\nprint(f\"End Global: {global_var}\")\n\nStart Global: 123\nInner: global_var=100, enclosing_var=200\nOuter: global_var=100, enclosing_var=200\nEnd Global: 100"
  },
  {
    "objectID": "hs25/pds/pds_notes.html#parameter-value",
    "href": "hs25/pds/pds_notes.html#parameter-value",
    "title": "Python for Data Science - Notes",
    "section": "Parameter Value",
    "text": "Parameter Value\nParameters are always refernces to arguments. An argument can be of a mutable (like lists) or immutable data type. The content of mutable data types can be ‚Äúglobally altered in functions.\n\ndef my_add(p):\n    result = p\n    result [-1] = 99 # Change last value to 99\n    return result\n\nvar = [9,8,7,6,5,4,3,2,0] # Last value is 0\nprint(my_add(var))\nprint(var) # List was changed by the function\n\n[9, 8, 7, 6, 5, 4, 3, 2, 99]\n[9, 8, 7, 6, 5, 4, 3, 2, 99]"
  },
  {
    "objectID": "hs25/pds/pds_notes.html#unpacking-arguments-args-and-kwargs",
    "href": "hs25/pds/pds_notes.html#unpacking-arguments-args-and-kwargs",
    "title": "Python for Data Science - Notes",
    "section": "Unpacking Arguments (*args and **kwargs)",
    "text": "Unpacking Arguments (*args and **kwargs)\nPython assigns one object to the first and the last variable and packs all the remaining objects into a tuple that is assigned to the variable with the packing operator\n\nvar1 = 1\nvar2 = [\"hello\", \"-\", \"world\"]\nvar3 = 22\nprint(var1, var2, var3)\n\n# Using the packing operator\nvar1, *var2, var3 = 1, \"hello\", \"-\", \"world\", 22\nprint(var1, var2, var3)\n\n1 ['hello', '-', 'world'] 22\n1 ['hello', '-', 'world'] 22\n\n\n\n*args: packing operator (*) packs all non-keyword arguments into a tuple.\n**kwargs: double packing operator(**) packs all keyword arguments into a dictionary\n\n\ndef my_fun(*args, **kwargs):\n    print(args); print(kwargs)\n    \nmy_fun('hello', 'world', arg1=33, arg2=55)\n\n('hello', 'world')\n{'arg1': 33, 'arg2': 55}\n\n\nIn contrast, lists and tuples can be unpacked using the packing operator (*) and (**) for dictionaries, respectively."
  },
  {
    "objectID": "hs25/pds/pds_notes.html#recursion",
    "href": "hs25/pds/pds_notes.html#recursion",
    "title": "Python for Data Science - Notes",
    "section": "Recursion",
    "text": "Recursion\nA recursive function is simply a function that calls itself during its execution. It is especially useful to loop through a data set with undefined dimension and undefined iteration count. Despite increased complexity and risks, recursion allows to solve complex problems in a short way.\n\ndef factorial(n):\n    if n == 1:\n        return 1\n    else:\n        return n * factorial(n-1)\n\nfactorial(5)\n\n120"
  },
  {
    "objectID": "hs25/pds/pds_notes.html#definition",
    "href": "hs25/pds/pds_notes.html#definition",
    "title": "Python for Data Science - Notes",
    "section": "Definition",
    "text": "Definition\nObject-Oriented Programming (OOP) is a programming paradigm that structures code around objects rather than functions and logic. It‚Äôs a powerful way to model real-world entities and relationships in your code, leading to more modular, reusable, and scalable applications."
  },
  {
    "objectID": "hs25/pds/pds_notes.html#classes",
    "href": "hs25/pds/pds_notes.html#classes",
    "title": "Python for Data Science - Notes",
    "section": "Classes",
    "text": "Classes\nAssembly instructions for box construction are represented by the class. The produced boxes, all with the same set of tools but different property values, are called objects. In Python everything is an object and variables hold references to these objects. This means, when you assign an object to a variable, you actually create a reference to that object in memory.\nA class in python consist of several elements: - header with class name indicates the beginning of a class description. - init() method: The constructor constructs a new object of the class. - variables: class: Variables belonging to the class description. Object: variables belonging to a particular object. - methods (functions): Class: methods provided by the class description. Object: methods provided by the object. - self attribute: Reference to the object: required to access object attributes.\n\nclass MyClass(): # The class\n    def __init__(self): # Initial function\n        pass\n\n    def my_function(): # Methode of the class object\n        pass\n\n\nNote: For class names, we use CamelCase instead of underscores, as in function names.\n\n\n__init__\nGenerating a new object, requires calling the class name and defining the specific properties by attributes passed to the constructor. Each time when generating a new object, python calls the constructor and passes the ‚Äúproperties‚Äù (attributes) to the init() method.\n\n\nMethodes and variables\nThe class definition fully describes the class (i.e.¬†the object). It comprises a mix of all variables and methods provided for the whole class and particular objects. Methods and variables are called with the object or by reference (self-keyword), respectively. Similarly to variables, methods can belong to an object or a class itself. The declaration and call is the same as for regular functions, yet always requires a reference\n\nclass MyClass(): # The class\n    def __init__(self): # Initial function\n        pass\n\n    def my_function(self): # Methode of the class object\n        pass\n    \n    @classmethod\n    def class_function(cls): # Methode only of of the class\n        pass\n\n\nNote: The keyword cls is a convention but not necessary.\n\n\n\nself\nThe self keyword points to the object it belongs to (namely itself). It allows to call or apply a variable and method, respectively, of (on) a particular object."
  },
  {
    "objectID": "hs25/pds/pds_notes.html#method-types",
    "href": "hs25/pds/pds_notes.html#method-types",
    "title": "Python for Data Science - Notes",
    "section": "Method types",
    "text": "Method types\n\nObject Methods\nBelong to a particular object. Modifying object‚Äôs state.\ndef change_obj_state(self):\n        self.state = \"New State\"\n        return True\n\n\nClass Methods\nBelong to a particular class. Modifying class‚Äô state.\n@classmethod\ndef change_cls_state(cls):\n    cls.state = \"New State\"\n    return True\n\n\nStatic Methods\nDon‚Äôt belong to object nor class. Provide operations independent of any object or class state.\n@staticmethod\ndef utility_func():\n    print(\"Done\")\n    return True\n\n\nDunder Methodes\nDunder Methods (or Magic methods), are special methods in Python classes marked by double leading and trailing underscores (e.g., __init__, __str__).\n\n\n__str__()\nBy implementing a str() method, the programmer can define what is printed when an object of an own class is passed to the print function.\ndef __str__(self):\n    return self.cls_name"
  },
  {
    "objectID": "hs25/pds/pds_notes.html#inheritance",
    "href": "hs25/pds/pds_notes.html#inheritance",
    "title": "Python for Data Science - Notes",
    "section": "Inheritance",
    "text": "Inheritance\nInheritance creates a hierarchy of classes. This avoids code redundance and increase maintainability. Use the function sinstance(object, classinfo) or issubclass(class, classinfo) to check if an instance is a subclass of a other class. Child classes get all properties (attributes) from parent class. This means, class or object variables or methods defined in the parent class also hold in the child classes. Typically, child classes extend parent classes. In some cases, a child class can override variables or methods from parent class.\nclass Animal:\n    def __init__(self, weight):\n        self.weight = weight\n\nclass Bird(Animal):\n    def __init__(self, weight):\n        super().__init__(weight) # Inheritance from the parent class\nWhen extending functionality of parent class by overriding a method (or in general to use parent‚Äôs methods), they can be referred to using super() or parent‚Äôs class name.\nclass Animal:\n    def __init__(self, weight):\n        self.weight = weight\n\n    def get_weight(self):\n        return self.weight\n\nclass Bird(Animal):\n    def __init__(self, weight):\n        super().__init__(weight)\n\n    def get_weight(self):\n        return super().get_weight()/10\n\nThe Class ‚Äúobject‚Äù\nThis is the ultimate base class of all other classes. It has methods that are common to all instances of Python classes. When the constructor is called, it returns a new featureless object. The constructor does not accept any arguments."
  },
  {
    "objectID": "hs25/pds/pds_notes.html#multiple-inheritance",
    "href": "hs25/pds/pds_notes.html#multiple-inheritance",
    "title": "Python for Data Science - Notes",
    "section": "Multiple Inheritance",
    "text": "Multiple Inheritance\n\nSingle inheritance: one child class inherits from one parent class.\nMultiple single inheritance: multiple child classes inherit from one parent (the same) class.\nMultiple inheritance: one child class inherits from multiple parent classes."
  },
  {
    "objectID": "hs25/pds/pds_notes.html#method-resolution-order-mro",
    "href": "hs25/pds/pds_notes.html#method-resolution-order-mro",
    "title": "Python for Data Science - Notes",
    "section": "Method Resolution Order (MRO)",
    "text": "Method Resolution Order (MRO)\nThe Method Resolution Order (MRO) is the order in which Python searches for methods and attributes in a class hierarchy. It dictates the sequence of base classes that are checked when a method is called on an object of a derived class, especially in cases of multiple inheritance (where a class inherits from more than one parent). The MRO is essential for making multiple inheritance reliable and predictable.\n\n\n\n\n\n\nNote\n\n\n\nThe super() function relies entirely on the MRO. When you call super().method(), Python uses the MRO list to find the next class in the hierarchy after the current class that implements method(), ensuring that base class methods are called in the correct, standardized order."
  },
  {
    "objectID": "hs25/pds/pds_notes.html#access-modifiers",
    "href": "hs25/pds/pds_notes.html#access-modifiers",
    "title": "Python for Data Science - Notes",
    "section": "Access Modifiers",
    "text": "Access Modifiers\nSince Python is a script language and does not compile code in advance to execution, it lacks of keywords defining attribute‚Äôs accessibility. Yet, there is a convention in the naming of attributes using _ for protected and for __ private attributes for treating access restrictions.\n\nNote: This is only a convention. Python has no hard restrictions and allows to access all attributes on object level."
  },
  {
    "objectID": "hs25/pds/pds_notes.html#modules",
    "href": "hs25/pds/pds_notes.html#modules",
    "title": "Python for Data Science - Notes",
    "section": "Modules",
    "text": "Modules\nA module is a file containing Python definitions and statements. We can use modules for better structuring the source code of the whole application.\n\nImport\nIn order to access content of other modules, they can be imported to a module as whole or parts of it.\nimport numpy                # Declares reference to module \nimport numpy as np          # Renames reference to\nfrom numpy import array     # Declares reference to specific attribute\nfrom numpy import *         # Declares references to ‚Äúall‚Äù attributes\nWhen imported, attributes of external modules are accessed differently, depending on the import.\n\n\n\n\n\n\nNote\n\n\n\nWhen it comes to aliases for frequently used modules, there are conventions.\nimport numpy as np\nimport pandas as pd\nfrom matplotplib import pyplot as plt\n\n\nReferring to external modules and files require either absolute or relative references. By default, root is set to the main executed script. The main executed script only allows absolute path. By default, imported modules are searched relative to the script path. For this case, the module sys allows to extend the search space for imported modules.\nsys.path.append('C:\\\\Users\\\\additional\\\\location')      # Windows\nsys.path.append('/home/username/additional/location')   # Linux"
  },
  {
    "objectID": "hs25/pds/pds_notes.html#if-__name__-__main__",
    "href": "hs25/pds/pds_notes.html#if-__name__-__main__",
    "title": "Python for Data Science - Notes",
    "section": "If __name__ == ‚Äú__main__‚Äù:",
    "text": "If __name__ == ‚Äú__main__‚Äù:\nThe If __name__ == ‚Äú__main__‚Äù: block determines how a Python file is being executed.\n\nIf the file is run directly (as the main script), the variable __name__ is set to \"__main__\", and the code inside the block runs. This is where you put your application‚Äôs main execution logic (e.g., calling your primary function).\nIf the file is imported as a module into another script, __name__ is set to the module‚Äôs name, and the code inside the block is skipped. This allows the file to be used as a reusable library without triggering unwanted side effects.\n\nThis structure allows a single Python file to be both runnable and importable."
  },
  {
    "objectID": "hs25/pds/pds_notes.html#packaging",
    "href": "hs25/pds/pds_notes.html#packaging",
    "title": "Python for Data Science - Notes",
    "section": "Packaging",
    "text": "Packaging\nPython enables to structure project resources using packages. a folder becomes a package as soon as it comprises a script named __init__.py\n\nNote: Since Python 3.3, there has been no need to declare an __init__.py file for packages, but it is still good practice.\n\n\nThe __init__.py Script\nObjects defined in the init.py are bound to names in the package‚Äôs namespace."
  },
  {
    "objectID": "hs25/pds/pds_notes.html#external-packages",
    "href": "hs25/pds/pds_notes.html#external-packages",
    "title": "Python for Data Science - Notes",
    "section": "External Packages",
    "text": "External Packages\nThe Python Software Foundation hosts an own repository for official Python packages called PyPI. pip is a command-line interface (CLI) tool for installing Python packages.\npip install &lt;packages&gt;\npip unistall &lt;packages&gt;\npip list\npip freeze # Output in requirement format"
  },
  {
    "objectID": "hs25/pds/pds_notes.html#data-manipulation",
    "href": "hs25/pds/pds_notes.html#data-manipulation",
    "title": "Python for Data Science - Notes",
    "section": "Data Manipulation",
    "text": "Data Manipulation\n\nNumpy\nNumPy is the fundamental package for scientific computing in Python. It is a Python library that provides a multidimensional array object, various derived objects, and an assortment of routines for fast operations on arrays.\n\nMultidimensional Array objects\nMultidimensional array object (ndarray) are sequences, matrices or multidimensional matrices of numerical values. Important differences between NumPy arrays and the standard Python sequences are:\n\nFixed size at creation. Changing size of ndarray creates new array.\nAll elements are required to be of the same data type.\nNumPy arrays facilitate advanced mathematical and other types of operations on large numbers of data.\n\n\n\n\nPandas\nPandas is a fast, powerful, flexible and easy to use open source data analysis and manipulation tool, built on top of the Python programming language.\n\nFast DataFrame Object: A core, efficient object for data manipulation with integrated indexing.\nI/O Capabilities: Easy reading and writing of data across various formats (CSV, Excel, SQL, HDF5).\nData Handling: Intelligent data alignment and integrated missing data handling.\nAggregation: A powerful group by engine for split-apply-combine operations.\n\n\nData Frames\nData frames are tabular data structure commonly used in data analysis and statistical computing.\n\nColumns represent variables (features).\nRows represent observations (records).\nIndexing by labels or numerical indices: [row, col]\n\n\n\n\n\n\n\nNote\n\n\n\nA series is a one dimensional data (index and one column of a data frame)."
  },
  {
    "objectID": "hs25/pds/pds_notes.html#data-visualization",
    "href": "hs25/pds/pds_notes.html#data-visualization",
    "title": "Python for Data Science - Notes",
    "section": "Data Visualization",
    "text": "Data Visualization\n\nMatplotlib\nMatplotlib is a low-level library that provides a lot of flexibility and control over the creation of plots. Matplotlib has three fundamental components used for creating and managing plots:\n\nPyplot: a collection of functions to create figures.\nFigure object: represents the entire figure in which you can plot one or more axes.\nAxes object: represents a single or a set of plots within a figure. This is the area where data is plotted.\n\n\n\nSeaborn\nBuilt on top of Matplotlib, Seaborn is a high-level library specifically designed for statistical data visualization. Since seaborn builds on top of matplotlib, it is mandatory to import pyplot from matplotlib in order to add titles or show the plot directly."
  },
  {
    "objectID": "hs25/pds/pds_notes.html#jupyter-notebook",
    "href": "hs25/pds/pds_notes.html#jupyter-notebook",
    "title": "Python for Data Science - Notes",
    "section": "Jupyter Notebook",
    "text": "Jupyter Notebook\nJupyter Notebook is an open-source web application that allows you to create and share documents that contain code, equations, visualizations, and narrative text. It is widely used for data analysis, scientific research, machine learning, and educational purposes.\n\nInteractive Code Execution: write and execute code in a cell-based format, allowing for iterative development and testing.\nRich Text Support: include Markdown for formatting text, including headings, lists, links, and images.\nVisualizations: create and display plots and figures inline, making it easy to visualize data alongside your code.\nReport: export the notebook as HTML or PDF, allows for having a report always ready."
  },
  {
    "objectID": "hs25/pds/pds_notes.html#deep-vs.-shallow-copy",
    "href": "hs25/pds/pds_notes.html#deep-vs.-shallow-copy",
    "title": "Python for Data Science - Notes",
    "section": "Deep vs.¬†Shallow Copy",
    "text": "Deep vs.¬†Shallow Copy\nPython only has objects and references to them. So, variables are always references to objects stored in the memory in one or more storage cells. Consequently, when copying a variable, we copy the reference to a particular object ‚Äì not the object itself.\n\n# Define a var\nx = 123\ny = x # Copy x to y\n\n# Both vars have the same memory location\nprint(id(x))\nprint(id(y))\n\n11764584\n11764584\n\n\nTo create a copy of a sequence object with a new reference (ie. id), sequence objects implement the copy() method.\n\nNote: The method copy() is only available for mutable objects.\n\nCopying a sequence returns a shallow copy of the object only. References to sub-sequences still remain the same and are affected by the same side-effect as when duplicating the reference by reassignment."
  },
  {
    "objectID": "hs25/pds/pds_notes.html#lambda-function",
    "href": "hs25/pds/pds_notes.html#lambda-function",
    "title": "Python for Data Science - Notes",
    "section": "Lambda Function",
    "text": "Lambda Function\n\nConcept\nWhen associating a function to a variable, this can be done directly without function declaration first. Associated to a variable, they can be called as regular functions by the variable as reference instead of the function name. are typically used for expressions in combination with filter functions such as for the map() or sort() functions.\n\nmap()-Function\nApplies a function to every single item of an iterable.\n\nmy_list = [2, 4, 6, 8, 10]\n# Divide every value from the list by 2\nnew_list = list(map(lambda x: int(x/2), my_list))\nprint(my_list)\nprint(new_list)\n\n[2, 4, 6, 8, 10]\n[1, 2, 3, 4, 5]\n\n\n\n\nsort()-Function\nSorts an iterable based on a given comparator.\n\nmy_list = [4, 10, 6, 2, 8]\n# Sort the values in reverse order\nmy_list.sort(key=lambda x: -x)\nprint(my_list)\n\n[10, 8, 6, 4, 2]"
  },
  {
    "objectID": "hs25/pds/pds_notes.html#list-comprehension",
    "href": "hs25/pds/pds_notes.html#list-comprehension",
    "title": "Python for Data Science - Notes",
    "section": "List Comprehension",
    "text": "List Comprehension\nInstead iterating a list with a for loop for applying a single expression on each element, a single expression can be applied in a simpler way on one line using a list comprehension.\n\nmy_list = [1, 2, 3]\nnew_list = []\n# Iterate over a list\nfor value in my_list:\n    new_list.append(value * 2)\nprint(f\"Original list: {my_list}\")\nprint(f\"New list with loop: {new_list}\")\n\n### IS THE SAME AS ###\n\nmy_list = [value * 2 for value in my_list]\nprint(f\"New list with comprehension {my_list}\")\n\nOriginal list: [1, 2, 3]\nNew list with loop: [2, 4, 6]\nNew list with comprehension [2, 4, 6]\n\n\n\n\n\n\n\n\nNote\n\n\n\nComprehensions can be applied in-place\n\n\nComprehensions only apply a single expression on each list element. However, it provides the option defining conditions for the elements on that it should be applied.\n\nmy_list = [1, 2, 3, 4]\n# Only double even values from the list\nmy_list = [value * 2 if value % 2 == 0 else value for value in my_list]\nprint(my_list)\n\n[1, 4, 3, 8]\n\n\n\nNote: The single expression can also be a regular function\n\n\nNested Loops\ncomprehension allow to apply expressions to multi-dimensional lists ‚Äì nested list comprehension.\n\nmy_list = [[1, 1], [2, 2], [3, 3]]\nnew_list = []\n# Iterate over both lists\nfor coordinate in my_list:\n    new_coordinate = []\n    for entry in coordinate:\n        new_coordinate.append(entry * 2)\n    new_list.append(new_coordinate)\nprint(f\"Original list: {my_list}\")\nprint(f\"New list with loop: {new_list}\")\n\n### IS THE SAME AS ###\n\nmy_list = [[entry * 2 for entry in coordinate] for coordinate in my_list]\nprint(f\"New list with comprehension {my_list}\")\n\nOriginal list: [[1, 1], [2, 2], [3, 3]]\nNew list with loop: [[2, 2], [4, 4], [6, 6]]\nNew list with comprehension [[2, 2], [4, 4], [6, 6]]\n\n\n\n\nTuples\nDespite the similarity between tuple and list in Python, there exist no tuple comprehension.Generating a tuple with a comprehension requires an explicit typecast tuple() or a tweak using unpacking operator for variable assignment.\n\nmy_tuple = (1, 2, 3, 4)\n\nx = tuple([i*2 for i in my_tuple])\nprint(f\"With typecast: {x}\")\n\ny = *[i*2 for i in my_tuple],\nprint(f\"With unpacking operator: {y}\")\n\nWith typecast: (2, 4, 6, 8)\nWith unpacking operator: (2, 4, 6, 8)\n\n\n\n\nDictionary\nDictionary comprehension requires the format of dictionary elements as expression results.\n\nx = [1, 2, 3, 4, 5]\n\nd1 = {i:i for i in x}\nprint(d1)\nd2 = {k:v for (k,v) in enumerate(x)}\nprint(d2)\nd3 = {k:v for (k,v) in zip([\"a\", \"b\", \"c\", \"d\", \"e\"], x)}\nprint(d3)\n\n{1: 1, 2: 2, 3: 3, 4: 4, 5: 5}\n{0: 1, 1: 2, 2: 3, 3: 4, 4: 5}\n{'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5}"
  },
  {
    "objectID": "hs25/pds/pds_notes.html#type-annotation",
    "href": "hs25/pds/pds_notes.html#type-annotation",
    "title": "Python for Data Science - Notes",
    "section": "Type Annotation",
    "text": "Type Annotation\nThe Python runtime does not enforce function and variable type annotations. They can be used by third party tools such as type checkers, IDEs, linters, etc. In particular, we only define the type (any Python class) of references separated by colon (:) and arrows (-&gt;).\nx: int = 10 # Var x is an integer\ndef my_function(x: int) # The param x has to be an integer\ndef my_function(x) -&gt; int: # The function returns an integer"
  },
  {
    "objectID": "hs25/pds/pds_notes.html#assert-function",
    "href": "hs25/pds/pds_notes.html#assert-function",
    "title": "Python for Data Science - Notes",
    "section": "Assert Function",
    "text": "Assert Function\nPython‚Äôs assert statement allows you to write sanity checks in your code. These checks are known as assertions, and you can use them to test if certain assumptions remain true while you‚Äôre developing your code. If any of your assertions turn false, it indicates a bug by raising an AssertionError.\n\ndef division(a, b):\n    assert b != 0, \"Division by Zero\" # Divider can't be Zero\n    \n    res = a / b\n    return res"
  },
  {
    "objectID": "hs25/pds/pds_modul_exam_fs23.html",
    "href": "hs25/pds/pds_modul_exam_fs23.html",
    "title": "Python for Data Science - Modul Exam FS2023",
    "section": "",
    "text": "For each of the following code snippets: What will be printed?\n\n\ns = \"Mojo is the successor programming language to Python!\"\nprint(s[12:19])\nOutput:\nsuccess\n\n\n\ns = \"Mojo is the successor programming language to Python!\"\nprint(s[12:19])\n\nsuccess\n\n\n\n\n\n\ns = \"Mojo is the successor programming language to Python!\"\nprint(s[12::4])\nOutput:\nseromgngot!\n\n\n\ns = \"Mojo is the successor programming language to Python!\"\nprint(s[12::4])\n\nseromgngot!\n\n\n\n\n\n\ns = \"Mojo is a language\"\nprint(s[::-1])\nOutput:\negaugnal a si ojoM\n\n\n\ns = \"Mojo is a language\"\nprint(s[::-1])\n\negaugnal a si ojoM\n\n\n\n\n\n\nL = [\"Mojo\", \"is\", \"a\", \"language\"]\nprint(L[3][:-4])\nOutput:\nlang\n\n\n\nL = [\"Mojo\", \"is\", \"a\", \"language\"]\nprint(L[3][:-4])\n\nlang"
  },
  {
    "objectID": "hs25/pds/pds_modul_exam_fs23.html#task-1.1",
    "href": "hs25/pds/pds_modul_exam_fs23.html#task-1.1",
    "title": "Python for Data Science - Modul Exam FS2023",
    "section": "",
    "text": "s = \"Mojo is the successor programming language to Python!\"\nprint(s[12:19])\nOutput:\nsuccess\n\n\n\ns = \"Mojo is the successor programming language to Python!\"\nprint(s[12:19])\n\nsuccess"
  },
  {
    "objectID": "hs25/pds/pds_modul_exam_fs23.html#task-1.2",
    "href": "hs25/pds/pds_modul_exam_fs23.html#task-1.2",
    "title": "Python for Data Science - Modul Exam FS2023",
    "section": "",
    "text": "s = \"Mojo is the successor programming language to Python!\"\nprint(s[12::4])\nOutput:\nseromgngot!\n\n\n\ns = \"Mojo is the successor programming language to Python!\"\nprint(s[12::4])\n\nseromgngot!"
  },
  {
    "objectID": "hs25/pds/pds_modul_exam_fs23.html#task-1.3",
    "href": "hs25/pds/pds_modul_exam_fs23.html#task-1.3",
    "title": "Python for Data Science - Modul Exam FS2023",
    "section": "",
    "text": "s = \"Mojo is a language\"\nprint(s[::-1])\nOutput:\negaugnal a si ojoM\n\n\n\ns = \"Mojo is a language\"\nprint(s[::-1])\n\negaugnal a si ojoM"
  },
  {
    "objectID": "hs25/pds/pds_modul_exam_fs23.html#task-1.4",
    "href": "hs25/pds/pds_modul_exam_fs23.html#task-1.4",
    "title": "Python for Data Science - Modul Exam FS2023",
    "section": "",
    "text": "L = [\"Mojo\", \"is\", \"a\", \"language\"]\nprint(L[3][:-4])\nOutput:\nlang\n\n\n\nL = [\"Mojo\", \"is\", \"a\", \"language\"]\nprint(L[3][:-4])\n\nlang"
  },
  {
    "objectID": "hs25/pds/pds_modul_exam_fs23.html#task-2.1",
    "href": "hs25/pds/pds_modul_exam_fs23.html#task-2.1",
    "title": "Python for Data Science - Modul Exam FS2023",
    "section": "Task 2.1",
    "text": "Task 2.1\nprint(\"1) for_loop_a:\", upper_with_for_loop(letter_list))\nprint(\"2) for_loop_b:\", *upper_with_for_loop(letter_list), sep=\"\")\nOutput:\n1) for_loop_a: ['H', 'S', 'L', 'U', ' ', 'M', 'E', 'P', '!']\n2) for_loop_b:HSLU MEP!\n\nProve\n\nprint(\"1) for_loop_a:\", upper_with_for_loop(letter_list))\nprint(\"2) for_loop_b:\", *upper_with_for_loop(letter_list), sep=\"\")\n\n1) for_loop_a: ['H', 'S', 'L', 'U', ' ', 'M', 'E', 'P', '!']\n2) for_loop_b:HSLU MEP!"
  },
  {
    "objectID": "hs25/pds/pds_modul_exam_fs23.html#task-2.2",
    "href": "hs25/pds/pds_modul_exam_fs23.html#task-2.2",
    "title": "Python for Data Science - Modul Exam FS2023",
    "section": "Task 2.2",
    "text": "Task 2.2\nprint(\"3) lambda_a:\", upper_with_lambda(letter_list))\nprint(\"4) lambda_b:\", *upper_with_lambda(letter_list))\nOutput:\n3) lambda_a: ['H', 'S', 'L', 'U', ' ', 'M', 'E', 'P', '!']\n4) lambda_b: H S L U   M E P !\n\nProve\n\nprint(\"3) lambda_a:\", upper_with_lambda(letter_list))\nprint(\"4) lambda_b:\", *upper_with_lambda(letter_list))\n\n3) lambda_a: ['H', 'S', 'L', 'U', ' ', 'M', 'E', 'P', '!']\n4) lambda_b: H S L U   M E P !"
  },
  {
    "objectID": "hs25/pds/pds_modul_exam_fs23.html#task-3.1",
    "href": "hs25/pds/pds_modul_exam_fs23.html#task-3.1",
    "title": "Python for Data Science - Modul Exam FS2023",
    "section": "Task 3.1",
    "text": "Task 3.1\n\nclass AAA:\n    def m(self):\n        print(\"AAA\")\n\nclass BB(AAA):\n    def m(self):\n        print(\"BB\")\n\nclass CC(AAA):\n    def m(self):\n        print(\"CC\")\n\nclass D(BB, CC):\n    def m(self):\n        print(\"D\")\n\nd = D()\nd.m()\nOutput:\nD\n\nProve\n\nd = D()\nd.m()\n\nD"
  },
  {
    "objectID": "hs25/pds/pds_modul_exam_fs23.html#task-3.2",
    "href": "hs25/pds/pds_modul_exam_fs23.html#task-3.2",
    "title": "Python for Data Science - Modul Exam FS2023",
    "section": "Task 3.2",
    "text": "Task 3.2\n\nclass AAA:\n    def m(self):\n        print(\"AAA\")\n\nclass BB(AAA):\n    def m(self):\n        print(\"BB\")\n\nclass CC(AAA):\n    def m(self):\n        print(\"CC\")\n\nclass D(BB, CC):\n    pass\n\nd = D()\nd.m()\nOutput:\nBB\n\nProve\n\nd = D()\nd.m()\n\nBB"
  },
  {
    "objectID": "hs25/pds/pds_modul_exam_fs23.html#task-3.3",
    "href": "hs25/pds/pds_modul_exam_fs23.html#task-3.3",
    "title": "Python for Data Science - Modul Exam FS2023",
    "section": "Task 3.3",
    "text": "Task 3.3\n\nclass AAA:\n    def m(self):\n        print(\"AAA\")\n\nclass BB(AAA):\n    pass\n\nclass CC(AAA):\n    def m(self):\n        print(\"CC\")\n\nclass D(BB, CC):\n    pass\n\nd = D()\nd.m()\nOutput:\nCC\n\nProve\n\nd = D()\nd.m()\n\nCC"
  },
  {
    "objectID": "hs25/pds/pds_modul_exam_fs23.html#task-3.4",
    "href": "hs25/pds/pds_modul_exam_fs23.html#task-3.4",
    "title": "Python for Data Science - Modul Exam FS2023",
    "section": "Task 3.4",
    "text": "Task 3.4\n\nclass AAA:\n    def m(self):\n        print(\"AAA\")\n\nclass BB(AAA):\n    pass\n\nclass CC(AAA):\n    pass\n\nclass D(BB, CC):\n    pass\n\nd = D()\nd.m()\nOutput:\nAAA\n\nProve:\n\nd = D()\nd.m()\n\nAAA"
  },
  {
    "objectID": "hs25/pds/pds_modul_exam_fs23.html#task-4.1",
    "href": "hs25/pds/pds_modul_exam_fs23.html#task-4.1",
    "title": "Python for Data Science - Modul Exam FS2023",
    "section": "Task 4.1",
    "text": "Task 4.1\nname = input(\"Enter your name: \") # your input: Anna\nage = int(input(\"Enter your age: \")) # your input: 23\n\nprint(\"My name is %s and I am %d years old.\" % (name, age))\nOutput:\nMy name is Anna and I am 23 years old.\n\nProve\n\nname = \"Anna\"\nage = 23\n\nprint(\"My name is %s and I am %d years old.\" % (name, age))\n\nMy name is Anna and I am 23 years old."
  },
  {
    "objectID": "hs25/pds/pds_modul_exam_fs23.html#task-4.2",
    "href": "hs25/pds/pds_modul_exam_fs23.html#task-4.2",
    "title": "Python for Data Science - Modul Exam FS2023",
    "section": "Task 4.2",
    "text": "Task 4.2\nfirst_name = input(\"Enter your first name: \") # your input: Anna\nlast_name = input(\"Enter your last name: \") # your input: Meier\nbirth_year = input(\"Enter your birth year: \") # your input: 1998\nusername = \"%s%s%s\" % (first_name[0].lower(), last_name[:3].lower(), birth_year[-2:])\n\nprint(\"Generated username: %s\" % username)\nOutput:\nGenerated username: amei98\n\nProve\n\nfirst_name = \"Anna\"\nlast_name = \"Meier\"\nbirth_year = \"1998\"\nusername = \"%s%s%s\" % (first_name[0].lower(), last_name[:3].lower(), birth_year[-2:])\n\nprint(\"Generated username: %s\" % username)\n\nGenerated username: amei98"
  },
  {
    "objectID": "hs25/pds/pds_modul_exam_fs23.html#task-4.3",
    "href": "hs25/pds/pds_modul_exam_fs23.html#task-4.3",
    "title": "Python for Data Science - Modul Exam FS2023",
    "section": "Task 4.3",
    "text": "Task 4.3\nFor the following code snippet: Change the C-style string format below to the ‚Äúpythonic way‚Äù with the format()-function. Write the ‚Äúpythonic way‚Äù with the format()-function as result.\n\n\n\n\n\n\nCaution\n\n\n\nYour inputs are given in the comments!\n\n\nname = input(\"Enter your name: \") # your input: Anna\nage = int(input(\"Enter your age: \")) # your input: 23\n\n# replace the next line with a 'format(...)' function:\nprint(\"Hello, my name is %s and I am %d years old.\" % (name, age))\nSolution:\nprint(\"Hello, my name is {} and I am {} years old.\".format(name, age))\nOutput:\nMy name is Anna and I am 23 years old.\n\nProve\n\nname = \"Anna\"\nage = 23\n\nprint(\"Hello, my name is {} and I am {} years old.\".format(name, age))\n\nHello, my name is Anna and I am 23 years old."
  },
  {
    "objectID": "hs25/pds/pds_modul_exam_fs23.html#task-4.4",
    "href": "hs25/pds/pds_modul_exam_fs23.html#task-4.4",
    "title": "Python for Data Science - Modul Exam FS2023",
    "section": "Task 4.4",
    "text": "Task 4.4\nFor the following code snippet: Change the C-style string format below to the ‚Äúpythonic way‚Äù with the format()-function. Write the ‚Äúpythonic way‚Äù with the format()-function as result.\n\n\n\n\n\n\nCaution\n\n\n\nYour inputs are given in the comments!\n\n\nfirst_name = input(\"Enter your first name: \") # your input: Anna\nlast_name = input(\"Enter your last name: \") # your input: Meier\nbirth_year = input(\"Enter your birth year: \") # your input: 1998\n\n# replace the next two code lines with 'format(...)' functions:\nusername = \"%s%s%s\" % (first_name[0].lower(), last_name[:3].lower(), birth_year[-2:])\nprint(\"Generated username: %s\" % username)\nSolution:\nprint(\"Generated username: {}\".format(username))\nOutput:\nGenerated username: amei98\n\nProve\n\nfirst_name = \"Anna\"\nlast_name = \"Meier\"\nbirth_year = \"1998\"\nusername = \"%s%s%s\" % (first_name[0].lower(), last_name[:3].lower(), birth_year[-2:])\n\nprint(\"Generated username: {}\".format(username))\n\nGenerated username: amei98"
  },
  {
    "objectID": "hs25/csc/csc_notes.html",
    "href": "hs25/csc/csc_notes.html",
    "title": "Comuter Science Concepts for Data Science - Notes",
    "section": "",
    "text": "Data Science improves traditional productio nwith basic function by Digital services using Data Science driven functions. The result is a new poroduct type, for Example watch vs.¬†smart watch. To do so, data has to be processec, visialized, tranferd storaged and used in a program."
  },
  {
    "objectID": "hs25/csc/csc_notes.html#how-can-data-science-improve-products-services",
    "href": "hs25/csc/csc_notes.html#how-can-data-science-improve-products-services",
    "title": "Comuter Science Concepts for Data Science - Notes",
    "section": "",
    "text": "Data Science improves traditional productio nwith basic function by Digital services using Data Science driven functions. The result is a new poroduct type, for Example watch vs.¬†smart watch. To do so, data has to be processec, visialized, tranferd storaged and used in a program."
  },
  {
    "objectID": "hs25/csc/csc_notes.html#fundaments-of-computer-networks",
    "href": "hs25/csc/csc_notes.html#fundaments-of-computer-networks",
    "title": "Comuter Science Concepts for Data Science - Notes",
    "section": "Fundaments of Computer Networks",
    "text": "Fundaments of Computer Networks\nA computer network is build of several components:\n\nConeccted devises: Hosts (end stystems).\nCommunications linsk: Wired and wireless.\nProtocols: Sending and receiving data.\nPacket switches: routers and switches.\n\n\nExample Net\n\n\n\nEnterprise Network"
  },
  {
    "objectID": "hs25/csc/csc_notes.html#packet-switching",
    "href": "hs25/csc/csc_notes.html#packet-switching",
    "title": "Comuter Science Concepts for Data Science - Notes",
    "section": "Packet Switching",
    "text": "Packet Switching\nThe Host dates applicatins messages and breaks them into smaller chunks (aka. packets) of length \\(L\\) bits. The packets are transmitted into access network at rate \\(R\\), called link capacity/bandwith.\n\nPackaet Transmission Delay\n\n\\(L\\): Packet lenght (bits).\n\\(R\\): Link bandwith (dps).\n\n\\[\nd_{\\text{trans}} = \\dfrac{L \\quad \\text{(bits)}}{R \\quad \\text{(bits/sec)}}\n\\]\n\n\nPropagation delay\n\n\\(d\\): Length of physical link.\n\\(s\\): Propagation speed in medium.\n\n\\[\nd_{\\text{prop}} = \\dfrac{d}{s}\n\\]\n\n\nRate\nRate (bits/time unit) at which bits transferred between sender/receiver. We disquinsh between:\n\nInstantaneous: Rate at given point in time.\nAverage: Rate over longer period of time."
  },
  {
    "objectID": "hs25/csc/csc_notes.html#protocol-layers",
    "href": "hs25/csc/csc_notes.html#protocol-layers",
    "title": "Comuter Science Concepts for Data Science - Notes",
    "section": "Protocol Layers",
    "text": "Protocol Layers\nProtocols define format, order of msgs sent and received among network entities, and actions taken on msg transmission, receipt.\n\nApplications: FTP, SMTP, HTTP.\nTransport: TCP, UDP.\nNetwork: IP, routing protocols.\nLink: Ethernet, WiFi.\nPhysical: Ethernet, WiFi."
  },
  {
    "objectID": "hs25/csc/csc_notes.html#addressing-in-computer-networks",
    "href": "hs25/csc/csc_notes.html#addressing-in-computer-networks",
    "title": "Comuter Science Concepts for Data Science - Notes",
    "section": "Addressing in Computer Networks",
    "text": "Addressing in Computer Networks\n\nDomain Name System\nTranslates domain names to numerical IP addresses.\n\nDNS Recursor (Client Side): Initiates the query. It‚Äôs the first stop and acts as a librarian trying to find the IP address.\nRoot Nameserver (The Dot ‚Äò.‚Äô): The starting point. It directs the Recursor to the correct Top-Level Domain (TLD) Nameserver.\nTLD Nameserver (e.g., .com, .de, .org): Manages all domains under its specific extension. It points the Recursor to the Authoritative Nameserver for the specific domain requested.\nAuthoritative Nameserver: Holds the definitive DNS records (A, CNAME, MX, etc.) for the requested domain. It provides the actual IP address back to the Recursor.\nDNS Recursor / Client: Receives the IP address and finally connects to the web server to load the website.\n\n\n\nIP Addressing\nEach device is assigned a unique IP address build up by Net ID + Host ID"
  },
  {
    "objectID": "hs25/csc/csc_notes.html#switch",
    "href": "hs25/csc/csc_notes.html#switch",
    "title": "Comuter Science Concepts for Data Science - Notes",
    "section": "Switch",
    "text": "Switch\nA network switch is a central component in almost every wired network, especially in local area networks (LANs). It acts as an intelligent distribution station for data traffic. Based on incoming frames switch ‚Äúlearns‚Äù location of sender. Records sender/location pair in switch table.\n\nNote: Layer 2 ‚Äì Data Link Layer"
  },
  {
    "objectID": "hs25/csc/csc_notes.html#router",
    "href": "hs25/csc/csc_notes.html#router",
    "title": "Comuter Science Concepts for Data Science - Notes",
    "section": "Router",
    "text": "Router\nA router is a network device that forwards data packets between different networks. It ensures that information (e.g.¬†a website, video or email) reaches the recipient from the sender ‚Äì even if it has to pass through many intermediate stations.\n\nNote: Layer 3 ‚Äì Network Layer"
  },
  {
    "objectID": "hs25/csc/csc_notes.html#client-server-communication-pattern",
    "href": "hs25/csc/csc_notes.html#client-server-communication-pattern",
    "title": "Comuter Science Concepts for Data Science - Notes",
    "section": "Client Server Communication Pattern",
    "text": "Client Server Communication Pattern\nClients (e.g.¬†Browser) send service requests. Servers (e.g.¬†Web, Database) wait for requests to arrive from clients and then respond to. Client receive service responses from centralized server."
  },
  {
    "objectID": "hs25/csc/csc_notes.html#uniform-resource-locator-url",
    "href": "hs25/csc/csc_notes.html#uniform-resource-locator-url",
    "title": "Comuter Science Concepts for Data Science - Notes",
    "section": "Uniform Resource Locator (URL)",
    "text": "Uniform Resource Locator (URL)\nReference to a web resource that specifies its location in a computer network (e.g.¬†web page, video, image, etc.)\n\n\n\nURL Structure"
  },
  {
    "objectID": "hs25/csc/csc_notes.html#html",
    "href": "hs25/csc/csc_notes.html#html",
    "title": "Comuter Science Concepts for Data Science - Notes",
    "section": "HTML",
    "text": "HTML\nDescriptive Language HTML, with a set of HTML elements/tags, is used to create Websites and publish content on the Internet in a simple and standardized way. The Hypertext Transfer Protocol (HTTP) ensures that content on a Web server can be accessed and interpreted by a Web client and thus displayed within a browser.\n\nElements & Tags\nMost HTML Elements are characterized by having a start and end tag.\n&lt;h1&gt;Header 1&lt;/h1&gt;\n&lt;p&gt;Paragraph&lt;/p&gt; \n\nHeadings: Headings are text size pre-sets ranging from &lt;h1&gt; to &lt;h6&gt;\nParagraphs: Paragraphs are used to create text blocks with &lt;p&gt;content&lt;/p&gt;\nBold: With &lt;b&gt; text &lt;/b&gt; text can be set to bold.\nItalic: With &lt;i&gt; text &lt;/i&gt; text can be set to italic.\nUnderline: With &lt;u&gt; text &lt;/u&gt; text can be underlined.\nHyperlinks: Using the anchor tag with an link as attribute: &lt;a href=\"Reference target\"&gt; Text &lt;/a&gt;\nImages: Image tag with at least a source attribute: &lt;img src = \"path/file\" &gt;\n\n\nNested Elements\nIt is possible to include elements within elements. Such constructs are being referred to as nested elements.\n&lt;p&gt;Star&lt;b&gt;Wars&lt;/b&gt;&lt;/p&gt;\n\n\nStructural Elements\nThe structural elements can be considered as the core setup of any HTML Website.\n\n&lt;!DOCTYPE html&gt;: Declares using HTML5\n&lt;html&gt; &lt;/html&gt;: Defines the root of an HTML document\n&lt;head&gt; &lt;/head&gt;: Meta data about the HTML document\n&lt;body&gt; &lt;/body&gt;: All content of the HTML document"
  },
  {
    "objectID": "hs25/csc/csc_notes.html#css",
    "href": "hs25/csc/csc_notes.html#css",
    "title": "Comuter Science Concepts for Data Science - Notes",
    "section": "CSS",
    "text": "CSS\nCSS is a stylesheet language that is primarily used to describe the appearance and formatting of a document written in a markup language such as HTML."
  },
  {
    "objectID": "hs25/csc/csc_notes.html#algorithms",
    "href": "hs25/csc/csc_notes.html#algorithms",
    "title": "Comuter Science Concepts for Data Science - Notes",
    "section": "Algorithms",
    "text": "Algorithms\nA computational problem specifies an input-output relationship. An algorithm is an exact specification of how to solve a computational problem. Algorithms must be: - Correct: For each input produce an appropriate output - Efficient: Run as quickly as possible, and use as little memory as possible\n\nDesigning Algorithms\nBreak problem up into smaller (easier) sub-problems. Think only about how to use the smaller solution to get the larger one Do not worry about how to solve to smaller problem (it will be solved using an even smaller one).\n\n\nRecursion\nRecursion is a method of solving a problem where the solution depends on solutions to smaller instances of the same problem. This allows programming in a style that reflects divide-n-conquer algorithmic thinking."
  },
  {
    "objectID": "hs25/csc/csc_notes.html#search-algorithms",
    "href": "hs25/csc/csc_notes.html#search-algorithms",
    "title": "Comuter Science Concepts for Data Science - Notes",
    "section": "Search Algorithms",
    "text": "Search Algorithms\nLinear search or sequential search is a simple method for finding an element within a sorted list. It sequentially checks each element of the list until a match is found or the whole list has been searched. A linear search runs in at worst linear time and makes at most \\(n\\) comparisons.\n\nBinary Search\nBinary search is a search algorithm that finds the position of a target value within a sorted list of values. Binary search compares the target value to the middle element of the list. If they are not equal, the half in which the target cannot lie is eliminated and the search continues on the remaining half, again taking the middle element to compare to the target value, and repeating this until the target value is found."
  },
  {
    "objectID": "hs25/csc/csc_notes.html#low-code-environments",
    "href": "hs25/csc/csc_notes.html#low-code-environments",
    "title": "Comuter Science Concepts for Data Science - Notes",
    "section": "Low Code Environments",
    "text": "Low Code Environments\nCombines visual program elements like variables, loops or conditional statements rather than specifying them textually."
  },
  {
    "objectID": "hs25/csc/csc_notes.html#data-types",
    "href": "hs25/csc/csc_notes.html#data-types",
    "title": "Comuter Science Concepts for Data Science - Notes",
    "section": "Data Types",
    "text": "Data Types\n\n\n\nData Types"
  },
  {
    "objectID": "hs25/csc/csc_notes.html#visual-variables",
    "href": "hs25/csc/csc_notes.html#visual-variables",
    "title": "Comuter Science Concepts for Data Science - Notes",
    "section": "Visual Variables",
    "text": "Visual Variables\n\nMark / Shape: Used shapes to distinguish between different types in a plot\nPosition: Position of an object Used to encode data\nSize (Length, Area and Volume): Sizes to encode data\nBrightness: Mapping values to the plot\nColor: Colormap that can be used to encode a data variable\nOrientation: Used to encode data\nTexture: Mapping values to the plot\nMotion: Associated with any of the other visual variables"
  },
  {
    "objectID": "hs25/csc/csc_notes.html#design-principles",
    "href": "hs25/csc/csc_notes.html#design-principles",
    "title": "Comuter Science Concepts for Data Science - Notes",
    "section": "Design Principles",
    "text": "Design Principles\n\n\n\n\n\n\nNote\n\n\n\nThe purpose of visualization is insight, not pictures.\n\n\n\nDo not expect the user to spot changes in interactive diagrams\nOverview first, zoom and filter, then details on demand\nSimilarity in feature space corresponds to similarity in visual space\nOrder between data items corresponds to visual order\nChoose your coloring wisely\nThe importance of data items corresponds to their visual saliency\nA single visualization can only reveal one data facet\nVisualize only the interesting information"
  },
  {
    "objectID": "hs25/csc/csc_notes.html#cloud-computing-definition",
    "href": "hs25/csc/csc_notes.html#cloud-computing-definition",
    "title": "Comuter Science Concepts for Data Science - Notes",
    "section": "Cloud Computing Definition",
    "text": "Cloud Computing Definition\n\nGossmann (2009): Clouds, or clusters of distributed computers, provide on-demand resources and services over a network, usually the Internet, with the scale and reliability of a data center.\nNIST Definition: Cloud computing is a model for enabling convenient, on-demand network access to a shared pool of configurable computing resources that can be rapidly provisioned and released with minimal management effort or serviceprovider interaction.\n\n\nBusiness Model\n\nClient: Pay by use instead of provisioning for peak.\nProvider: Share capabilities.\n\n\n\nCloud Properties\n\nSelf-managing services: A consumer can provision cloud services as needed and automatically without requiring human interaction with each service‚Äôs provider.\nAccessible and highly available: Cloud resources are available over the network anytime and anywhere.\n\n\n\nDeployment Model\n\nPublic clouds: Owned by cloud service providers who charge for the use of cloud resources (AWS (Amazon), Azure (Microsoft))\nPrivate clouds: Cloud infrastructure belongs to and is operated by only one organization\nHybrid clouds: Cloud infrastructure is a composition of two or more clouds (private or public). Bound together by standardized or proprietary technology that enables data and application portability.\n\n\n\nIaaS, PaaS and SaaS\n\nInfrastructure as a Service (IaaS): Servers, Storage, Network\nPlatform as a Service (PaaS): OS, Application Stack\nSoftware as a Service (SaaS): Packaged Software"
  },
  {
    "objectID": "hs25/csc/csc_notes.html#virtualization",
    "href": "hs25/csc/csc_notes.html#virtualization",
    "title": "Comuter Science Concepts for Data Science - Notes",
    "section": "Virtualization",
    "text": "Virtualization\nVirtualization is essentially a way to trick a computer into thinking it is running multiple separate machines, all on the same physical hardware. It lets you run many independent operating systems (called Virtual Machines or VMs) side-by-side. The piece of software that makes this possible is called a Hypervisor.\nThere are two main types of Hypervisors:\n- Type 1 (Bare-Metal): This is the most powerful type. It is installed directly onto the physical hardware, without needing an operating system underneath it. It manages the server's resources (CPU, RAM, etc.) immediately. Because it has direct access to the hardware, it is very fast, efficient, and secure. This type is used mainly in large data centers and enterprise servers (e.g., VMware ESXi).\n\n- Type 2 (Hosted): This type is installed like a regular application on top of a host operating system (like Windows or macOS). It relies on the host OS to manage the hardware. This makes it easier for casual use, development, and testing on a personal computer, but it is less efficient and slower than Type 1 (e.g., VirtualBox).\n\nKey Advantages of Using Virtualization\nThe main benefit is efficiency. You can run many servers on just one physical machine, which is called server consolidation. This saves a lot of money on buying hardware, paying for electricity (power), and cooling. It also improves security because if one VM gets a virus, the others stay isolated. Finally, it makes tasks like backup and disaster recovery much easier, as you can quickly move or restore an entire VM onto different hardware."
  },
  {
    "objectID": "hs25/csc/csc_notes.html#processing-data",
    "href": "hs25/csc/csc_notes.html#processing-data",
    "title": "Comuter Science Concepts for Data Science - Notes",
    "section": "Processing Data",
    "text": "Processing Data\n\n\n\n\n\n\nNote\n\n\n\nAll Linux commands consist of three parts:\n\ncommand (e.g., grep)\noptions: to modify the behavior of the command\narguments: objects upon which the command acts\n\n\n\n\ngrep\nTake a stream of text or data, perform operations on it, and produce a modified version of that stream as output.\ngrep -e &lt;REGEX_PATTERN&gt; &lt;FILE&gt;\n\n\ncut\nSelects portions of each line (as specified by list) from each file and writes them to the output.\ncut -d &lt;DELIMITER&gt; -f &lt;FIELD_SELECTION&gt; &lt;FILE&gt;\n\n\nwget\nWget is a free utility for non-interactive download of files and whole websites (follows links) from the Internet.\n\n\nPipes & Filters Pattern\nA pipe is used in Linux to send the output of one command/process to another command/process for further processing. Decompose a task that performs complex processing into a series of separate processing steps that can be reused.\ngrep -e &lt;REGEX_PATTERN&gt; &lt;FILE&gt; | cut -d &lt;DELIMITER&gt; -f &lt;FIELD_SELECTION&gt; &lt;FILE&gt;"
  },
  {
    "objectID": "hs25/csc/csc_notes.html#v-model",
    "href": "hs25/csc/csc_notes.html#v-model",
    "title": "Comuter Science Concepts for Data Science - Notes",
    "section": "5V-Model",
    "text": "5V-Model\nThe 5 V‚Äôs of big data are Volume, Velocity, Variety, Veracity, and Value. These characteristics help define the challenges and opportunities associated with managing and analyzing large data sets."
  },
  {
    "objectID": "hs25/csc/csc_notes.html#regular-expressions",
    "href": "hs25/csc/csc_notes.html#regular-expressions",
    "title": "Comuter Science Concepts for Data Science - Notes",
    "section": "Regular Expressions",
    "text": "Regular Expressions\nA regular expression, often shortened to regex, is a sequence of characters that defines a search pattern. It uses a specific syntax combining literal characters (e.g., a, 1) and metacharacters (e.g., . , *, []) which have special meaning.\n\nEssetials\n\nMetacharacters: These are the building blocks, defining rules like matching any character (.), the start of a line (^), or the end of a line ($).\nQuantifiers: Symbols like * (zero or more), + (one or more), and ? (zero or one) specify how many times the preceding element must occur.\nCharacter Classes/Sets: Square brackets [] define a set of characters, matching any one character within the set (e.g., [0-9] matches any digit).\nAnchors: Characters like ^, $, and word boundary) match a position within the text, not an actual character.\nGrouping: Parentheses () are used to combine parts of the pattern and create capturing groups, allowing the extraction of specific matched sub-strings.\nApplications: Primarily used for data validation (e.g., emails, phone numbers), complex search and replace operations, and parsing/extracting data from text."
  },
  {
    "objectID": "hs25/lia1/lia1_notes.html",
    "href": "hs25/lia1/lia1_notes.html",
    "title": "Linear Algebra 01",
    "section": "",
    "text": "Linear algebra is the theory of linear mappings between vector spaces. Broadly, it‚Äôs the theory of certain linear data transformations or manipulations. The main actors are vectors and matrices.\n\n\nA vector \\(\\overrightarrow{a}\\) is data of a number (or magnitude) and a direction. A vector is defined only by its length and direction. Two arrows represent the same vector if one is a parallel translation (shift) of the other. A vector is determined by giving the initial and terminal points of a representative, also called the tail and head of the vector. A vector, such as \\(\\overrightarrow{PQ}\\), is defined by the arrow with initial point \\(P\\) (tail) and terminal point \\(Q\\) (head).\n\nNote: The position of the arrow is not relevant.\n\n\\[\n\\overrightarrow{a} = \\begin{bmatrix}\n1 \\\\\n-3 \\\\\n\\end{bmatrix}\n\\]\n\n\nThe sum of two vectors is calculated component-wise. The summation of vectors is commutative and associative, includes a neutral element (the zero vector), and can be inverted by its negative vector to result in the zero vector.\n\\[\n\\overrightarrow{a} + \\overrightarrow{b} = \\begin{bmatrix}\n1 \\\\\n-3 \\\\\n\\end{bmatrix}\n+\n\\begin{bmatrix}\n4 \\\\\n-1 \\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n5 \\\\\n-2 \\\\\n\\end{bmatrix}\n\\]\n\n\n\nThe difference of two vectors \\(\\overrightarrow{a}\\) and \\(\\overrightarrow{b}\\) is the sum of \\(\\overrightarrow{a}\\) and the opposite of \\(\\overrightarrow{b}\\).\n\\[\n\\overrightarrow{a} - \\overrightarrow{b} = \\overrightarrow{a} + (-\\overrightarrow{b})\n\\]\n\n\n\nScalar multiplication of a vector involves multiplying each component of the vector by a scalar (a real number). This changes the magnitude of the vector, keeping its direction the same if the scalar is positive or reversing it if the scalar is negative. Scalar multiplication of vectors is associative and distributive and includes a neutral element (the scalar 1).\n\\[\n\\dfrac{1}{2}(\\overrightarrow{a} + \\overrightarrow{b})\n=\n\\dfrac{1}{2}(\\begin{bmatrix}\n2 \\\\\n6 \\\\\n\\end{bmatrix}\n+\n\\begin{bmatrix}\n4 \\\\\n2 \\\\\n\\end{bmatrix})\n=\n\\begin{bmatrix}\n3 \\\\\n4 \\\\\n\\end{bmatrix}\n\\]\n\n\n\nThe magnitude (or norm) of a vector \\(\\overrightarrow{a}\\) is its length, and it is denoted by \\(|\\overrightarrow{a}|\\).\n\\[\n\\lvert \\vec{a} \\rvert = \\sqrt{a_x^{2} + a_y^{2}}\n\\]\n\nNote: Length of vector is never negative: \\(\\lvert \\overrightarrow{a} \\rvert \\ge 0\\).\n\n\n\n\nThe vector with a norm of zero is denoted by \\(\\overrightarrow{0}\\). The length of the zero vector is \\(0\\).\n\\[\n|\\overrightarrow{0}| = 0\n\\]\n\nNote: A zero vector has no direction.\n\n\n\n\nThe opposite vector of \\(\\overrightarrow{a}\\) is a vector with the same norm but the opposite direction. It is denoted as \\(-\\overrightarrow{a}\\). In a representative, the initial and terminal points are reversed.\n\nNote: \\(\\overrightarrow{PQ} = -\\overrightarrow{QP}\\), but \\(\\overrightarrow{PQ} \\neq \\overrightarrow{QP}\\)\n\n\n\n\nA unit vector is a vector that has a magnitude of 1 and is often used to indicate direction.\n\\[\n\\lvert \\overrightarrow{e} \\rvert = 1\n\\]\n\n\n\nTwo vectors \\(\\overrightarrow{a}\\) and \\(\\overrightarrow{b}\\) are called collinear or linearly dependent, if:\n\\[\n\\overrightarrow{b} = r \\overrightarrow{a} \\quad \\text{for } r \\in \\mathbb{R}\n\\] \\[\ns \\overrightarrow{b} =  \\overrightarrow{a} \\quad \\text{for } s \\in \\mathbb{R}\n\\]\nMore generally: \\[\nr \\overrightarrow{a} + s \\overrightarrow{b} = \\overrightarrow{0} \\quad \\text{for } r, s \\in \\mathbb{R} \\quad \\text{with } r \\neq 0 \\quad \\text{or } s \\neq 0\n\\]\nThis will be used to generalize definition of linear independence.\n\n\n\nFor every non-zero vector \\(\\overrightarrow{a}\\), there is exactly one unit vector (\\(\\overrightarrow{e}_a\\)) with the same direction. This process is called normalizing a vector.\n\\[\n\\overrightarrow{e}_a = \\dfrac{1}{\\lvert \\overrightarrow{a} \\rvert}\\overrightarrow{a}\n\\]\n\n\n\n\\[\n\\overrightarrow{PQ}\n=\n\\begin{bmatrix}\nx_2 - x_1 \\\\\ny_2 - y_1 \\\\\n\\end{bmatrix}\n\\]\n\n\n\n\nA Cartesian coordinate system is one in which the axes are perpendicular and the units on each axis have the same length. The unit vectors along the axes are typically denoted by \\(\\overrightarrow{e}_x\\) and \\(\\overrightarrow{e}_y\\). Every vector in this system can be represented as a linear combination of these unit vectors.\n\\[\n\\overrightarrow{a} = a_x\\overrightarrow{e}_x + a_y\\overrightarrow{e}_y\n\\]\n\nNote: \\(a_x\\) and \\(a_y\\) are called scalar components of \\(\\overrightarrow{a}\\).\n\n\n\n\nVectors in 3D space have an additional component to represent the third dimension.\n\\[\n\\overrightarrow{a} = \\begin{bmatrix}\n1 \\\\\n-3 \\\\\n2 \\\\\n\\end{bmatrix}\n\\]\n\nNote: The mathematical rules do not change by adding more dimensions."
  },
  {
    "objectID": "hs25/lia1/lia1_notes.html#vectors",
    "href": "hs25/lia1/lia1_notes.html#vectors",
    "title": "Linear Algebra 01",
    "section": "",
    "text": "A vector \\(\\overrightarrow{a}\\) is data of a number (or magnitude) and a direction. A vector is defined only by its length and direction. Two arrows represent the same vector if one is a parallel translation (shift) of the other. A vector is determined by giving the initial and terminal points of a representative, also called the tail and head of the vector. A vector, such as \\(\\overrightarrow{PQ}\\), is defined by the arrow with initial point \\(P\\) (tail) and terminal point \\(Q\\) (head).\n\nNote: The position of the arrow is not relevant.\n\n\\[\n\\overrightarrow{a} = \\begin{bmatrix}\n1 \\\\\n-3 \\\\\n\\end{bmatrix}\n\\]\n\n\nThe sum of two vectors is calculated component-wise. The summation of vectors is commutative and associative, includes a neutral element (the zero vector), and can be inverted by its negative vector to result in the zero vector.\n\\[\n\\overrightarrow{a} + \\overrightarrow{b} = \\begin{bmatrix}\n1 \\\\\n-3 \\\\\n\\end{bmatrix}\n+\n\\begin{bmatrix}\n4 \\\\\n-1 \\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n5 \\\\\n-2 \\\\\n\\end{bmatrix}\n\\]\n\n\n\nThe difference of two vectors \\(\\overrightarrow{a}\\) and \\(\\overrightarrow{b}\\) is the sum of \\(\\overrightarrow{a}\\) and the opposite of \\(\\overrightarrow{b}\\).\n\\[\n\\overrightarrow{a} - \\overrightarrow{b} = \\overrightarrow{a} + (-\\overrightarrow{b})\n\\]\n\n\n\nScalar multiplication of a vector involves multiplying each component of the vector by a scalar (a real number). This changes the magnitude of the vector, keeping its direction the same if the scalar is positive or reversing it if the scalar is negative. Scalar multiplication of vectors is associative and distributive and includes a neutral element (the scalar 1).\n\\[\n\\dfrac{1}{2}(\\overrightarrow{a} + \\overrightarrow{b})\n=\n\\dfrac{1}{2}(\\begin{bmatrix}\n2 \\\\\n6 \\\\\n\\end{bmatrix}\n+\n\\begin{bmatrix}\n4 \\\\\n2 \\\\\n\\end{bmatrix})\n=\n\\begin{bmatrix}\n3 \\\\\n4 \\\\\n\\end{bmatrix}\n\\]\n\n\n\nThe magnitude (or norm) of a vector \\(\\overrightarrow{a}\\) is its length, and it is denoted by \\(|\\overrightarrow{a}|\\).\n\\[\n\\lvert \\vec{a} \\rvert = \\sqrt{a_x^{2} + a_y^{2}}\n\\]\n\nNote: Length of vector is never negative: \\(\\lvert \\overrightarrow{a} \\rvert \\ge 0\\).\n\n\n\n\nThe vector with a norm of zero is denoted by \\(\\overrightarrow{0}\\). The length of the zero vector is \\(0\\).\n\\[\n|\\overrightarrow{0}| = 0\n\\]\n\nNote: A zero vector has no direction.\n\n\n\n\nThe opposite vector of \\(\\overrightarrow{a}\\) is a vector with the same norm but the opposite direction. It is denoted as \\(-\\overrightarrow{a}\\). In a representative, the initial and terminal points are reversed.\n\nNote: \\(\\overrightarrow{PQ} = -\\overrightarrow{QP}\\), but \\(\\overrightarrow{PQ} \\neq \\overrightarrow{QP}\\)\n\n\n\n\nA unit vector is a vector that has a magnitude of 1 and is often used to indicate direction.\n\\[\n\\lvert \\overrightarrow{e} \\rvert = 1\n\\]\n\n\n\nTwo vectors \\(\\overrightarrow{a}\\) and \\(\\overrightarrow{b}\\) are called collinear or linearly dependent, if:\n\\[\n\\overrightarrow{b} = r \\overrightarrow{a} \\quad \\text{for } r \\in \\mathbb{R}\n\\] \\[\ns \\overrightarrow{b} =  \\overrightarrow{a} \\quad \\text{for } s \\in \\mathbb{R}\n\\]\nMore generally: \\[\nr \\overrightarrow{a} + s \\overrightarrow{b} = \\overrightarrow{0} \\quad \\text{for } r, s \\in \\mathbb{R} \\quad \\text{with } r \\neq 0 \\quad \\text{or } s \\neq 0\n\\]\nThis will be used to generalize definition of linear independence.\n\n\n\nFor every non-zero vector \\(\\overrightarrow{a}\\), there is exactly one unit vector (\\(\\overrightarrow{e}_a\\)) with the same direction. This process is called normalizing a vector.\n\\[\n\\overrightarrow{e}_a = \\dfrac{1}{\\lvert \\overrightarrow{a} \\rvert}\\overrightarrow{a}\n\\]\n\n\n\n\\[\n\\overrightarrow{PQ}\n=\n\\begin{bmatrix}\nx_2 - x_1 \\\\\ny_2 - y_1 \\\\\n\\end{bmatrix}\n\\]"
  },
  {
    "objectID": "hs25/lia1/lia1_notes.html#cartesian-coordinate-systems",
    "href": "hs25/lia1/lia1_notes.html#cartesian-coordinate-systems",
    "title": "Linear Algebra 01",
    "section": "",
    "text": "A Cartesian coordinate system is one in which the axes are perpendicular and the units on each axis have the same length. The unit vectors along the axes are typically denoted by \\(\\overrightarrow{e}_x\\) and \\(\\overrightarrow{e}_y\\). Every vector in this system can be represented as a linear combination of these unit vectors.\n\\[\n\\overrightarrow{a} = a_x\\overrightarrow{e}_x + a_y\\overrightarrow{e}_y\n\\]\n\nNote: \\(a_x\\) and \\(a_y\\) are called scalar components of \\(\\overrightarrow{a}\\)."
  },
  {
    "objectID": "hs25/lia1/lia1_notes.html#d-space",
    "href": "hs25/lia1/lia1_notes.html#d-space",
    "title": "Linear Algebra 01",
    "section": "",
    "text": "Vectors in 3D space have an additional component to represent the third dimension.\n\\[\n\\overrightarrow{a} = \\begin{bmatrix}\n1 \\\\\n-3 \\\\\n2 \\\\\n\\end{bmatrix}\n\\]\n\nNote: The mathematical rules do not change by adding more dimensions."
  },
  {
    "objectID": "hs25/lia1/lia1_notes.html#non-linear-equations",
    "href": "hs25/lia1/lia1_notes.html#non-linear-equations",
    "title": "Linear Algebra 01",
    "section": "Non-Linear equations",
    "text": "Non-Linear equations\n\nProduct of two unknown variables: \\(x \\cdot y + 1 = x\\)\nTrigonometric terms: \\(3\\sin x + y = 0\\)\nFractions of unknown variables: \\(\\dfrac{1}{x} + y = 1\\)"
  },
  {
    "objectID": "hs25/lia1/lia1_notes.html#matrix-notifications",
    "href": "hs25/lia1/lia1_notes.html#matrix-notifications",
    "title": "Linear Algebra 01",
    "section": "Matrix Notifications",
    "text": "Matrix Notifications\nTo generalize determination of solutions of linear equations, we can use the matrix notification.\n\\[\n2x + 3y = 10\n\\]\n\\[\nx - y = -5\n\\]\nShort hand notation by writing down coefficients only.\n\\[\n\\begin{pmatrix}\n2 & 3 & | & 10 \\\\\n1 & -1 & | & -5\n\\end{pmatrix}\n\\]\n\nNote: Called coefficient matrix."
  },
  {
    "objectID": "hs25/lia1/lia1_notes.html#gaussian-elimination-method",
    "href": "hs25/lia1/lia1_notes.html#gaussian-elimination-method",
    "title": "Linear Algebra 01",
    "section": "Gaussian Elimination Method",
    "text": "Gaussian Elimination Method\nGoal of Gaussian elimination method is to apply sequence of elementary row operations in order to transform augmented matrix of a system into a matrix in row echelon form.\n\nNote: Echelon row form is not unique, since interchanging rows is allowed.\n\n\nBackward Substitution\nThe system of linear equations is written in a special type of matrix. Solution are easy to determine with so-called backward substitution.\n\\[\n\\begin{pmatrix}\n2 & 1 & 1 & | & 5 \\\\\n0 & 8 & 3 & | & 14 \\\\\n0 & 0 & 1 & | & 2\n\\end{pmatrix}\n\\]\n\n\nPivot element\nThe pivot element is a key element chosen at each step of an algorithm used to solve a system of linear equations.\n\nNote: The pivot element must be non-zero.\n\n\n\nTypes of Row Echelon Forms\n\nIn all rows and in all columns there is a pivot: System has unique solutions\nIn all rows there is a pivot, but not in all columns: Free variables, so system has infinitely many solutions.\nSome row has no pivot: System is inconsistent (no solutions)."
  },
  {
    "objectID": "hs25/lia1/lia1_notes.html#set-of-solutions",
    "href": "hs25/lia1/lia1_notes.html#set-of-solutions",
    "title": "Linear Algebra 01",
    "section": "Set of Solutions",
    "text": "Set of Solutions\nOften a free parameter is denoted by \\(t\\): \\(t = y\\)\n\\[\nL = \\left\\{ \\begin{bmatrix} 3 \\\\ 0 \\\\ 1 \\end{bmatrix} + t \\begin{bmatrix} -3 \\\\ 1 \\\\ 0 \\end{bmatrix} \\mid t \\in \\mathbb{R} \\right\\}\n\\]\n\nNote: \\(t\\) vary over whole set \\(\\mathbb{R}\\), i.e., from \\(-\\infty\\) to \\(\\infty\\)"
  },
  {
    "objectID": "hs25/lia1/lia1_notes.html#special-matrices",
    "href": "hs25/lia1/lia1_notes.html#special-matrices",
    "title": "Linear Algebra 01",
    "section": "Special Matrices",
    "text": "Special Matrices\n\nSquared matrix: \\(n \\times n\\)\nColumn vector of dimension \\(n\\) (or vector): \\(n \\times 1\\)\nRow vector of dimension \\(n\\): \\(1 \\times n\\)\nZero matrix: All entries are zero.\nUpper/Lower square matrix\nDiagonal matrix: Only entries in main diagonal can be nonzero.\n\n\nNote: Set of all \\(n\\)-vectors with real entries: \\(\\mathbb{R}^{n}\\)"
  },
  {
    "objectID": "hs25/lia1/lia1_notes.html#matrix-operations",
    "href": "hs25/lia1/lia1_notes.html#matrix-operations",
    "title": "Linear Algebra 01",
    "section": "Matrix Operations",
    "text": "Matrix Operations\n\nTransposition\nTransposing a matrix means swapping rows and columns. If \\(A\\) is a matrix, then its transposed matrix \\(A^{T}\\) is defined by:\n\\[\n(A^{T})_{ij} = A_{ji}\n\\]\n\nNote: Square matrix \\(A\\) is symmetric, if: \\(A^{T} = A\\)\n\n\n\nAddition and Subtraction\nAddition and subtraction of matrices are performed element by element. &gt; Note: Both matrices must have the same dimensions.\n\n\nScalar Multiplication\nIn scalar multiplication, each element is multiplied individually by the number.\n\nRules for addition and scalar multiplication of matrices\nLet \\(A, B, C \\in \\mathbb{R}^{m \\times n}\\) and \\(r, s \\in \\mathbb{R}\\):\n\n\\((A+B)+C = A+(B+C)\\) (Associativity)\n\\(A+B = B+A\\) (Commutativity)\n\\(A+\\mathcal{O}_{m,n} = A\\) (Neutral element of addition)\n\\(A+(-A) = \\mathcal{O}_{m,n}\\) (Inverse element of addition)\n\\(r(sA) = (rs)A\\) (Associativity)\n\\((r+s)A = rA+sA\\) (Distributivity)\n\\(r(A+B) = rA+rB\\) (Distributivity)\n\\(1 \\cdot A = A\\) (Neutral element of scalar mult.)\n\\((A+B)^{T} = A^{T}+B^{T}\\)\n\n\n\n\nMatrix Multiplication\nMatrix multiplication is the process of combining the rows of the first matrix with the columns of the second matrix. The number of columns in the first matrix must be equal to the number of rows in the second matrix. Each element of the result matrix is calculated by forming the scalar product (element-wise product and then sum) of a row from the first matrix and a column from the second matrix.\n\nNote: The order is crucial: \\(A \\times B\\) can be different from \\(B \\times A\\).\n\n\nMnemonic\n\\[\n(m \\times \\mathbf{\\color{red}{n}}) \\cdot (\\mathbf{\\color{red}{n}} \\times p) = (m \\times p)\n\\]\n\n\nRules for matrix multiplication\nLet \\(A, B, C\\) matrices such that following matrix multiplications exist:\n\n\\((AB)C = A(BC)\\) (Associativity)\n\\((A+B)C = AC + BC\\) (Distributivity)\n\\(A(B+C) = AB + AC\\) (Distributivity)\n\\((rA)B = A(rB) = r(AB)\\) for \\(r \\in \\mathbb{R}\\)\n\\(A \\cdot \\mathcal{O}_{n,q} = \\mathcal{O}_{m,q}\\) and \\(\\mathcal{O}_{p,m} \\cdot A = \\mathcal{O}_{p,n}\\) for \\(A \\in \\mathbb{R}^{m \\times n}\\)\n\\(I_m \\cdot A = A \\cdot I_n = A\\) for \\(A \\in \\mathbb{R}^{m \\times n}\\) (Neutr. El.)\n\\((AB)^{T} = B^{T} A^{T}\\)"
  },
  {
    "objectID": "hs25/lia1/lia1_notes.html#linear-sytsems-in-matrice-form",
    "href": "hs25/lia1/lia1_notes.html#linear-sytsems-in-matrice-form",
    "title": "Linear Algebra 01",
    "section": "Linear Sytsems in Matrice Form",
    "text": "Linear Sytsems in Matrice Form\nSystem with m equations and n unknowns can be expressed in form \\(Ax = b\\), where A is the coefficient matrix and b is the right-hand side of the system."
  },
  {
    "objectID": "hs25/lia1/lia1_notes.html#linear-systems-on-vector-form",
    "href": "hs25/lia1/lia1_notes.html#linear-systems-on-vector-form",
    "title": "Linear Algebra 01",
    "section": "Linear Systems on Vector Form",
    "text": "Linear Systems on Vector Form\nThe system can be presented in form \\(x_aa_1 + \\dots x_na_n = b\\). If \\(x \\in \\mathbb{R^{n}}\\) is a solution of system, then b is a linear combination of column vectors \\(a_1, \\dots, a_n\\)."
  },
  {
    "objectID": "hs25/lia1/lia1_notes.html#homogeneous-systems",
    "href": "hs25/lia1/lia1_notes.html#homogeneous-systems",
    "title": "Linear Algebra 01",
    "section": "Homogeneous Systems",
    "text": "Homogeneous Systems\nA linear system is homogeneous, if right-hand side is zero vector: \\(Ax = 0\\), where \\(A \\in \\mathbb{R}^{m \\times n}\\) and \\(x\\) is a vector of unknowns.\n\nNote: Zero vector \\(x = 0 \\in \\mathbb{R^{n}}\\) is trivially a solution of a homogeneous system\n\n\nInformation in a Linear System\nLet \\(A\\) be an (\\(m \\times n\\))-matrix and \\(T\\) be a row echelon form obtained from \\(A\\) using elementary row operations.\n\nRank of \\(A\\): Number of pivot-elements in \\(T\\).\nNullity of \\(A\\): Number of columns of \\(T\\) without pivot-elements.\n\n\nNote: Rank of matrix \\(A\\) is denoted by rk \\(A\\) and nullity of \\(A\\) by nullity \\(A\\).\n\nTherefore\n\\[\n\\text{rk } A + \\text{nullity } A = n = \\textsf{number of cols of } A\n\\]"
  },
  {
    "objectID": "hs25/lia1/lia1_notes.html#inhomogeneous-systems",
    "href": "hs25/lia1/lia1_notes.html#inhomogeneous-systems",
    "title": "Linear Algebra 01",
    "section": "Inhomogeneous Systems",
    "text": "Inhomogeneous Systems\nForm where \\(b \\ne 0\\) is a non-zero vector. Every solution x of the inhomogeneous system (\\(Ax=b\\)) can be written as the sum of a special (particular) solution \\(x_p\\) and a homogeneous solution \\(x_h\\):\n\\[\nx = x_p + x_h\n\\]\nThe entire solution set of the inhomogeneous system \\(Ax=b\\) thus consists of the shift of the solution space (or zero space) of the homogeneous system \\(Ax=0\\) by the vector \\(x_p\\).\n\n\n\nSolution set of a inhomogeneous system"
  },
  {
    "objectID": "hs25/lia1/lia1_notes.html#square-linear-systems",
    "href": "hs25/lia1/lia1_notes.html#square-linear-systems",
    "title": "Linear Algebra 01",
    "section": "Square Linear Systems",
    "text": "Square Linear Systems\nIf the number of equations and numbers of unknowns in a linear system coincide (\\(m = n\\)), than:\n\nnullity \\(A = 0\\).\nrk \\(A = n\\).\n\\(Ax = 0\\) admits only trivial solution \\(0\\).\n\\(Ax = b\\) has one and only one solution."
  },
  {
    "objectID": "hs25/lia1/lia1_notes.html#rank-criterion",
    "href": "hs25/lia1/lia1_notes.html#rank-criterion",
    "title": "Linear Algebra 01",
    "section": "Rank Criterion",
    "text": "Rank Criterion\nA linear equation system \\(Ax=b\\) has at least one solution (is consistent) if and only if the rank of the coefficient matrix A is equal to the rank of the augmented coefficient matrix \\([A \\quad b]\\). The rank of the extended coefficient matrix \\([A \\quad b]\\) is created by appending the inhomogeneity vector b as an additional last column to the matrix \\(A\\)."
  },
  {
    "objectID": "hs25/lia1/lia1_notes.html#identity-matrix",
    "href": "hs25/lia1/lia1_notes.html#identity-matrix",
    "title": "Linear Algebra 01",
    "section": "Identity Matrix",
    "text": "Identity Matrix\nThe identity matrix of size \\(n\\) is the \\(n \\times n\\) square matrix with ones on the main diagonal and zeros elsewhere.\n\\[\nI =\n\\begin{bmatrix}\n1 & 0 & 0 \\\\\n0 & 1 & 0 \\\\\n0 & 0 & 1 \\\\\n\\end{bmatrix}\n\\]"
  },
  {
    "objectID": "hs25/lia1/lia1_notes.html#calculate-the-inverse-matrix",
    "href": "hs25/lia1/lia1_notes.html#calculate-the-inverse-matrix",
    "title": "Linear Algebra 01",
    "section": "Calculate the Inverse Matrix",
    "text": "Calculate the Inverse Matrix\n\\[\n[A|I_n]\n\\]\nBy using elementary rows transformations transform left term A to row echelon form.\n\\[\n[I_n|\\tilde{A}]\n\\]\n\nRules of Inverse\nLet \\(A\\) and \\(B\\) be invertible (\\(n \\times n\\))-matrices and \\(s \\ne 0\\) a scalar. Then \\(A^{‚àí1}\\), \\(sA\\), \\(AB\\) and \\(A^{T}\\) are invertible and the following hold:\n\n\\((A^{-1})^{-1} = A\\)\n\\((sA)^{-1} = s^{-1}A^{-1}\\)\n\\((AB)^{-1} = B^{-1}A^{-1}\\)\n\\((A^{T})^{-1} = (A^{-1})^{T}\\)\n\n\n\n\n\n\n\nCaution\n\n\n\nGenerally: \\[\n(AB)^{‚àí1} \\ne A^{‚àí1}B^{‚àí1}\n\\]\nFurthermore there is no rule for sum, so no rule for \\((A + B)^{‚àí1}\\), which could even not exist."
  },
  {
    "objectID": "hs25/lia1/lia1_notes.html#invers-matrix-by-determinant",
    "href": "hs25/lia1/lia1_notes.html#invers-matrix-by-determinant",
    "title": "Linear Algebra 01",
    "section": "Invers Matrix by Determinant",
    "text": "Invers Matrix by Determinant\n\n\n\n\n\n\nImportant\n\n\n\nMatrix \\(A\\) is invertible if and only if det \\(A \\ne 0\\)\n\n\n\\[\nA^{-1} = \\frac{1}{\\det A} \\begin{bmatrix} a_{22} & -a_{12} \\\\ -a_{21} & a_{11} \\end{bmatrix}\n\\]"
  },
  {
    "objectID": "hs25/lia1/lia1_notes.html#properties-of-determinant",
    "href": "hs25/lia1/lia1_notes.html#properties-of-determinant",
    "title": "Linear Algebra 01",
    "section": "Properties of Determinant",
    "text": "Properties of Determinant\n\\[\n\\det(v,w) = ‚àí \\det(w,v)\n\\]\n\\[\n\\det(x \\times v,w) = \\det(v,x \\times w) = x \\times \\det(v,w)\n\\]\n\\[\n\\det(v + x \\times w, w) = \\det(v, w + x \\times v) = \\det(v,w)\n\\]"
  },
  {
    "objectID": "hs25/lia1/lia1_notes.html#times-3-matrices",
    "href": "hs25/lia1/lia1_notes.html#times-3-matrices",
    "title": "Linear Algebra 01",
    "section": "\\(3 \\times 3\\)-Matrices",
    "text": "\\(3 \\times 3\\)-Matrices\n\\[\n\\begin{vmatrix}\na_{11} & a_{12} & a_{13} \\\\\na_{21} & a_{22} & a_{23} \\\\\na_{31} & a_{32} & a_{33}\n\\end{vmatrix}\n= a_{11}a_{22}a_{33} + a_{12}a_{23}a_{31} + a_{13}a_{21}a_{32}\n- a_{13}a_{22}a_{31} - a_{11}a_{23}a_{32} - a_{12}a_{21}a_{33}\n\\]\n\n\n\n3x3-Matrices Determinant"
  },
  {
    "objectID": "hs25/lia1/lia1_notes.html#determinant-of-triangular-matrices",
    "href": "hs25/lia1/lia1_notes.html#determinant-of-triangular-matrices",
    "title": "Linear Algebra 01",
    "section": "Determinant of Triangular Matrices",
    "text": "Determinant of Triangular Matrices\nDeterminant is product of main diagonal elements. If an entry of main diagonal is zero, then det \\(U = 0\\).\n\n\n\n\n\n\nCaution\n\n\n\nSign switched: As many times as row swappings.\n\n\n\nCalculation of Determinant of Square Matrix A\nBy performing elementary rows operations, bring A into an upper triangular matrix."
  },
  {
    "objectID": "hs25/lia1/lia1_notes.html#rules-for-determinants",
    "href": "hs25/lia1/lia1_notes.html#rules-for-determinants",
    "title": "Linear Algebra 01",
    "section": "Rules for determinants",
    "text": "Rules for determinants\n\\[\n\\det A^{T} = \\det A\n\\]\n\\[\n\\det(sA) = s^{n} \\det A\n\\]\n\nNote: \\(n\\) is the dimension of the square matrix \\(A\\).\n\n\\[\n\\det(AB) = (\\det A)(\\det B)\n\\]"
  },
  {
    "objectID": "hs25/lia1/lia1_notes.html#corollary",
    "href": "hs25/lia1/lia1_notes.html#corollary",
    "title": "Linear Algebra 01",
    "section": "Corollary",
    "text": "Corollary\nProduct AB of two square matrices of same size is invertible if and only if A and B are both invertible."
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Useful Resources",
    "section": "",
    "text": "Python\n\nW3Schools: A great starting point for beginners with Python basics and simple examples.\nReal Python: Comprehensive tutorials and advanced topics for a deeper dive into the language.\nGeeks for Geeks: A comprehensive educational portal that empowers learners across domains.\nNumpy Cheat Sheet: A quick reference guide covering essential functions for numerical operations.\nPandas Cheat Sheet: Summarizes the core commands for efficient data manipulation and analysis.\nMatplotlib Cheat Sheet: Overview to create static, animated, and interactive visualizations.\n\n\n\n\nSoftware Development\n\nW3Schools Git Tutorial: An easy-to-follow introduction to the fundamentals of version control with Git.\nLinux Cheat Sheet: Overview of the most common Linux terminal commands, written by Maths et al.\n\n\n\n\nData Science\n\nTowards Data Science: Collection of articles, tutorials, and guides on data analysis, ML, and AI.\nMedium: A knowledge base for technical topics and more.\n\n\n\n\nYouTube Channels\n\n3Blue1Brown: Visual explanations that make complex math and scientific concepts intuitive.\nFireship: High-intensity code tutorials and tech news.\n\n\n\n\nVisualisations\n\nThe Wall Street journal guide to information graphics: Dos and dont‚Äôs of presenting data."
  },
  {
    "objectID": "howTo/pythonPackages.html",
    "href": "howTo/pythonPackages.html",
    "title": "How to‚Ä¶ Python Packages",
    "section": "",
    "text": "Introduction\nPython inherently offers useful functionalities such as print(), enumerate(), or list.append(). However, our projects often require more specific tools. This is where packages (or libraries) come in. Packages are extensions for Python that provide specialized functions and tools to efficiently solve a variety of problems.\nThe most frequently used packages include:\n\nnumpy: For fast numerical and mathematical computations.\npandas: For the efficient processing of large amounts of structured data (tables).\nmatplotlib: For creating data visualizations and diagrams.\n\nInstead of treating every function of these packages in detail, which would be too extensive, this summary focuses on practical application examples for each presented package.\n\n\nNumPy\nTransposing a matrix means swapping rows and columns. If \\(A\\) is a matrix, then its transposed matrix \\(A^T\\) is defined by:\n\\[\n(A^T)_{ij} = A_{ji}\n\\]\nIf one were to perform a matrix transposition with pure Python, one would have to manually iterate over rows and columns, leading to comparatively inefficient code.\n\nmatrix = [[1, 2], [3, 4]]\nrows = len(matrix)\ncols = len(matrix[0])\ntransposed = []\n\nfor i in range(cols):\n    new_row = []\n    for j in range(rows):\n        new_row.append(matrix[j][i])\n    transposed.append(new_row)\n\nprint(transposed)\n\n[[1, 3], [2, 4]]\n\n\nDepending on the size of the matrix, this process can be very time-consuming. With NumPy, we can use the optimized transposition function to solve this problem quickly and elegantly. NumPy operations are vectorized and run with significantly better performance.\n\nimport numpy as np\n\nmatrix = np.array([[1, 2], [3, 4]])\ntransposed = matrix.T\n\nprint(transposed)\n\n[[1 3]\n [2 4]]\n\n\n\n\n\n\n\n\nTip\n\n\n\nCheck out the Numpy Cheat Sheet.\n\n\n\n\nPandas\nWorking with structured data in native Python is possible, but quickly becomes complicated and error-prone with larger data sets. Even simply summarizing a table already requires a considerable amount of code and manual data processing.\n\nsum_col_a = 0.0\nsum_col_b = 0.0\ncount = 0\n\nwith open(\"data/pandasTable.csv\", \"r\") as f:\n    header = f.readline() \n    \n    for line in f:\n        values = line.strip().split(',')\n        sum_col_a += float(values[1])\n        sum_col_b += float(values[2])\n        count += 1\n\navg_col_a = 0.0\navg_col_b = 0.0\n\nif count &gt; 0:\n    avg_col_a = sum_col_a / count\n    avg_col_b = sum_col_b / count\n\nprint(\"Number of Records:\", count)\nprint(\"Column ColA:\")\nprint(\"  Sum:\", sum_col_a)\nprint(\"  Average:\", avg_col_a)\nprint(\"Column ColB:\")\nprint(\"  Sum:\", sum_col_b)\nprint(\"  Average:\", avg_col_b)\n\nNumber of Records: 5\nColumn ColA:\n  Sum: 82.2\n  Average: 16.44\nColumn ColB:\n  Sum: 805.0\n  Average: 161.0\n\n\nWith Pandas, we can easily read in structured data and retrieve summary statistics with a single function call, which simplifies data analysis considerably.\n\nimport pandas as pd\n\ndf = pd.read_csv(\"data/pandasTable.csv\")\ndf.describe()\n\n\n\n\n\n\n\n\nID\nhight\nwidth\nGroup\n\n\n\n\ncount\n5.000000\n5.000000\n5.000000\n5.00000\n\n\nmean\n3.000000\n16.440000\n161.000000\n1.80000\n\n\nstd\n1.581139\n10.582911\n108.880669\n0.83666\n\n\nmin\n1.000000\n5.900000\n50.000000\n1.00000\n\n\n25%\n2.000000\n10.500000\n100.000000\n1.00000\n\n\n50%\n3.000000\n12.700000\n125.000000\n2.00000\n\n\n75%\n4.000000\n20.100000\n200.000000\n2.00000\n\n\nmax\n5.000000\n33.000000\n330.000000\n3.00000\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nCheck out the Pandas Cheat Sheet.\n\n\n\n\nMatplotlib\nData visualization in pure Python is a challenge, as the language was not designed for drawing diagrams without specialized packages.\n\ndata = {\"A\": 5, \"B\": 10, \"C\": 3}\nmax_val = max(data.values())\nscale = 50 / max_val  # Skalierung auf max. 50 Zeichen Breite\n\nfor key, value in data.items():\n    bar_length = int(value * scale)\n    print(f\"{key}: {'#' * bar_length} {value}\")\n\nA: ######################### 5\nB: ################################################## 10\nC: ############### 3\n\n\nFortunately, Matplotlib provides us with a versatile library with which we can create various types of diagrams.\n\nimport matplotlib.pyplot as plt\n\ndata = {\"A\": 5, \"B\": 10, \"C\": 3}\n\nkeys = list(data.keys())\nvalues = list(data.values())\n\nplt.figure()\nplt.bar(keys, values, color=['blue', 'red', 'green'])\n\nplt.title('Simple Data Visualization')\nplt.xlabel('Category')\nplt.ylabel('Value')\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nCheck out the Matplotlib Cheat Sheet.\n\n\n\n\nMore to explore\nThousands of packages are available for Python. However, it is advisable to use well-maintained and established standard packages such as numpy, pandas, and matplotlib, as these are regularly updated and have large communities.\nIf you are looking for a specific tool, PyPI (Python Package Index) is the central hub: PIPY"
  },
  {
    "objectID": "howTo/git.html",
    "href": "howTo/git.html",
    "title": "How to‚Ä¶ Git and GitHub",
    "section": "",
    "text": "Git is a program designed to track and manage your code changes over time. We will discuss the difference between Git and GitHub in a moment, but first, let‚Äôs look at Git itself. You typically use Git in your terminal, though some IDEs (Integrated Development Environments) have Git extensions that provide a graphical user interface (UI)."
  },
  {
    "objectID": "howTo/git.html#create-a-git-repository",
    "href": "howTo/git.html#create-a-git-repository",
    "title": "How to‚Ä¶ Git and GitHub",
    "section": "1. Create a Git Repository",
    "text": "1. Create a Git Repository\nTo begin, we need to create a Git repository (a special folder) where Git starts tracking our code.\ngit init"
  },
  {
    "objectID": "howTo/git.html#write-code",
    "href": "howTo/git.html#write-code",
    "title": "How to‚Ä¶ Git and GitHub",
    "section": "2. Write Code",
    "text": "2. Write Code\nFirst, we‚Äôll create an empty code file to have a change to track.\ntouch my_code.py"
  },
  {
    "objectID": "howTo/git.html#stage-the-file",
    "href": "howTo/git.html#stage-the-file",
    "title": "How to‚Ä¶ Git and GitHub",
    "section": "3. Stage the File",
    "text": "3. Stage the File\nBy staging our changes, we prepare all files to be versioned by Git. They are moved into the ‚ÄúStaging Area‚Äù.\ngit add my_code.py"
  },
  {
    "objectID": "howTo/git.html#commit-the-changes",
    "href": "howTo/git.html#commit-the-changes",
    "title": "How to‚Ä¶ Git and GitHub",
    "section": "4. Commit the Changes",
    "text": "4. Commit the Changes\nNow we can commit our changes by saving them with a short note. The git commit command will save all changes we staged in the previous step.\ngit commit -m \"Initial commit: Created an empty file\"\nDone! Now we can start coding and come back to this point anytime we make a mistake."
  },
  {
    "objectID": "howTo/git.html#get-the-latest-code",
    "href": "howTo/git.html#get-the-latest-code",
    "title": "How to‚Ä¶ Git and GitHub",
    "section": "1. Get the Latest Code",
    "text": "1. Get the Latest Code\nBefore you start coding, make sure you have the newest version of the code from the Cloud.\ngit pull\nNow you can follow the normal Git workflow as you learned above."
  },
  {
    "objectID": "howTo/git.html#update-the-code-on-github",
    "href": "howTo/git.html#update-the-code-on-github",
    "title": "How to‚Ä¶ Git and GitHub",
    "section": "5. Update the Code on GitHub",
    "text": "5. Update the Code on GitHub\nYour committed changes are only saved locally. You need to push your commit to GitHub to update the code for all other users.\ngit push\n\nNote: This step only works when you have correctly followed the Git workflow by staging (git add) and committing (git commit) your changes first."
  }
]